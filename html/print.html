<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>thin-edge.io docs</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="././mdbook-admonish.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="SUMMARY.html"><strong aria-hidden="true">1.</strong> Summary</a></li><li class="chapter-item "><a href="001_overview.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item "><a href="user_doc.html"><strong aria-hidden="true">3.</strong> User Documentation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tutorials/tutorials.html"><strong aria-hidden="true">3.1.</strong> Tutorials</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tutorials/getting-started.html"><strong aria-hidden="true">3.1.1.</strong> Getting started with thin-edge.io</a></li><li class="chapter-item "><a href="tutorials/connect-c8y.html"><strong aria-hidden="true">3.1.2.</strong> Connect my device to Cumulocity IoT</a></li><li class="chapter-item "><a href="tutorials/connect-azure.html"><strong aria-hidden="true">3.1.3.</strong> Connect my device to Azure IoT</a></li><li class="chapter-item "><a href="tutorials/connect-aws.html"><strong aria-hidden="true">3.1.4.</strong> Connect my device to AWS IoT</a></li><li class="chapter-item "><a href="tutorials/send-thin-edge-data.html"><strong aria-hidden="true">3.1.5.</strong> Send measurements</a></li><li class="chapter-item "><a href="tutorials/raise-alarm.html"><strong aria-hidden="true">3.1.6.</strong> Raise alarms</a></li><li class="chapter-item "><a href="tutorials/send-events.html"><strong aria-hidden="true">3.1.7.</strong> Send events</a></li><li class="chapter-item "><a href="tutorials/device-monitoring.html"><strong aria-hidden="true">3.1.8.</strong> Monitor my device</a></li><li class="chapter-item "><a href="tutorials/software-management.html"><strong aria-hidden="true">3.1.9.</strong> Manage my device software</a></li><li class="chapter-item "><a href="tutorials/write-my-software-management-plugin.html"><strong aria-hidden="true">3.1.10.</strong> Write my software management plugin</a></li><li class="chapter-item "><a href="tutorials/supported_operations.html"><strong aria-hidden="true">3.1.11.</strong> Supported Operations Management for Cumulocity IoT</a></li><li class="chapter-item "><a href="tutorials/yocto-linux.html"><strong aria-hidden="true">3.1.12.</strong> Build Thin Edge for a Yocto Linux distribution</a></li><li class="chapter-item "><a href="tutorials/child-device-config-management.html"><strong aria-hidden="true">3.1.13.</strong> Configuration management on child-devices</a></li></ol></li></ol></li><li class="chapter-item "><a href="howto-guides/howto-guides.html"><strong aria-hidden="true">4.</strong> How-to Guides</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="howto-guides/002_installation.html"><strong aria-hidden="true">4.1.</strong> Installation</a></li><li class="chapter-item "><a href="howto-guides/003_registration.html"><strong aria-hidden="true">4.2.</strong> How to create a test certificate</a></li><li class="chapter-item "><a href="howto-guides/004_connect.html"><strong aria-hidden="true">4.3.</strong> How to connect a cloud end-point</a></li><li class="chapter-item "><a href="howto-guides/005_pub_sub.html"><strong aria-hidden="true">4.4.</strong> How to send MQTT messages</a></li><li class="chapter-item "><a href="howto-guides/007_test_connection.html"><strong aria-hidden="true">4.5.</strong> How to test the cloud connection?</a></li><li class="chapter-item "><a href="howto-guides/008_config_local_mqtt_bind_address_and_port.html"><strong aria-hidden="true">4.6.</strong> How to configure the local mqtt bind address and port</a></li><li class="chapter-item "><a href="howto-guides/009_trouble_shooting_monitoring.html"><strong aria-hidden="true">4.7.</strong> How to trouble shoot device monitoring</a></li><li class="chapter-item "><a href="howto-guides/010_add_self_signed_trusted.html"><strong aria-hidden="true">4.8.</strong> How to add self-signed certificate root to trusted certificates list?</a></li><li class="chapter-item "><a href="howto-guides/011_retrieve_jwt_token_from_cumulocity.html"><strong aria-hidden="true">4.9.</strong> How to retrieve JWT token from Cumulocity?</a></li><li class="chapter-item "><a href="howto-guides/012_install_and_enable_software_management.html"><strong aria-hidden="true">4.10.</strong> How to install and enable software management?</a></li><li class="chapter-item "><a href="howto-guides/013_connect_external_device.html"><strong aria-hidden="true">4.11.</strong> How to connect an external device?</a></li><li class="chapter-item "><a href="howto-guides/014_thin_edge_logs.html"><strong aria-hidden="true">4.12.</strong> How to access the logs on the device?</a></li><li class="chapter-item "><a href="howto-guides/015_installation_without_deb_support.html"><strong aria-hidden="true">4.13.</strong> How to install thin-edge.io on any Linux OS (no deb support)?</a></li><li class="chapter-item "><a href="howto-guides/016_restart_device_operation.html"><strong aria-hidden="true">4.14.</strong> How to restart your thin-edge.io device</a></li><li class="chapter-item "><a href="howto-guides/017_apama_software_management_plugin.html"><strong aria-hidden="true">4.15.</strong> How to use apama software management plugin</a></li><li class="chapter-item "><a href="howto-guides/018_change_temp_path.html"><strong aria-hidden="true">4.16.</strong> How to change temp path</a></li><li class="chapter-item "><a href="howto-guides/019_how_to_use_preferred_init_system.html"><strong aria-hidden="true">4.17.</strong> How to use thin-edge.io with your preferred init system</a></li><li class="chapter-item "><a href="howto-guides/020_monitor_tedge_health.html"><strong aria-hidden="true">4.18.</strong> How to monitor health of tedge daemons</a></li><li class="chapter-item "><a href="howto-guides/021_enable_tedge_watchdog_using_systemd.html"><strong aria-hidden="true">4.19.</strong> How to enable systemd watchdog monitoring for tedge services?</a></li><li class="chapter-item "><a href="howto-guides/022_c8y_fragments.html"><strong aria-hidden="true">4.20.</strong> How to add custom fragments to Cumulocity</a></li><li class="chapter-item "><a href="howto-guides/023_c8y_log_plugin.html"><strong aria-hidden="true">4.21.</strong> How to retrieve logs with the log plugin</a></li><li class="chapter-item "><a href="howto-guides/024_smartrest_templates.html"><strong aria-hidden="true">4.22.</strong> How to use Cumulocity Custom SmartREST 2.0 Templates with thin-edge.io</a></li><li class="chapter-item "><a href="howto-guides/025_config_management_plugin.html"><strong aria-hidden="true">4.23.</strong> How to manage configuration files with Cumulocity</a></li><li class="chapter-item "><a href="howto-guides/026_how_to_install_thin_edge_manually.html"><strong aria-hidden="true">4.24.</strong> How to install thin-edge manually with OpenRC</a></li><li class="chapter-item "><a href="howto-guides/child_device_config_management_agent.html"><strong aria-hidden="true">4.25.</strong> How to enable configuration management on child devices</a></li><li class="chapter-item "><a href="howto-guides/027_remote_access_with_cumulocity.html"><strong aria-hidden="true">4.26.</strong> How to connect to your thin-edge.io device with Cumulocity remote access</a></li><li class="chapter-item "><a href="howto-guides/028_c8y_service_monitoring.html"><strong aria-hidden="true">4.27.</strong> How to monitor a service from Cumulocity</a></li></ol></li><li class="chapter-item "><a href="dev_doc.html"><strong aria-hidden="true">5.</strong> Developer Documentation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="architecture/architecture.html"><strong aria-hidden="true">5.1.</strong> Architecture</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="architecture/domain-model.html"><strong aria-hidden="true">5.1.1.</strong> Domain Model</a></li><li class="chapter-item "><a href="architecture/data-model.html"><strong aria-hidden="true">5.1.2.</strong> Data Model</a></li><li class="chapter-item "><a href="architecture/thin-edge-json.html"><strong aria-hidden="true">5.1.3.</strong> Thin Edge Json</a></li><li class="chapter-item "><a href="architecture/mapper.html"><strong aria-hidden="true">5.1.4.</strong> The Mapper</a></li><li class="chapter-item "><a href="architecture/software-management.html"><strong aria-hidden="true">5.1.5.</strong> Software Management</a></li><li class="chapter-item "><a href="architecture/faq.html"><strong aria-hidden="true">5.1.6.</strong> Architecture FAQ</a></li><li class="chapter-item "><a href="supported-platforms.html"><strong aria-hidden="true">5.1.7.</strong> Platform support</a></li><li class="chapter-item "><a href="references/init-system-config.html"><strong aria-hidden="true">5.1.8.</strong> Init System configuration</a></li></ol></li><li class="chapter-item "><a href="tutorials/write-my-software-management-plugin.html"><strong aria-hidden="true">5.2.</strong> Write my own software management plugin</a></li><li class="chapter-item "><a href="references/c8y-configuration-management.html"><strong aria-hidden="true">5.3.</strong> Device Configuration Management using Cumulocity</a></li><li class="chapter-item "><a href="api.html"><strong aria-hidden="true">5.4.</strong> APIs</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="references/bridged-topics.html"><strong aria-hidden="true">5.4.1.</strong> The Bridged Topics</a></li><li class="chapter-item "><a href="references/plugin-api.html"><strong aria-hidden="true">5.4.2.</strong> The Software Management Plugin API</a></li></ol></li><li class="chapter-item "><a href="BUILDING.html"><strong aria-hidden="true">5.5.</strong> Building</a></li></ol></li><li class="chapter-item "><a href="references/references.html"><strong aria-hidden="true">6.</strong> Command Line Reference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="references/tedge.html"><strong aria-hidden="true">6.1.</strong> The tedge command</a></li><li class="chapter-item "><a href="references/tedge-config.html"><strong aria-hidden="true">6.2.</strong> The tedge config command</a></li><li class="chapter-item "><a href="references/tedge-cert.html"><strong aria-hidden="true">6.3.</strong> The tedge cert command</a></li><li class="chapter-item "><a href="references/tedge-connect.html"><strong aria-hidden="true">6.4.</strong> The tedge connect command</a></li><li class="chapter-item "><a href="references/tedge-disconnect.html"><strong aria-hidden="true">6.5.</strong> The tedge disconnect command</a></li><li class="chapter-item "><a href="references/tedge-mqtt.html"><strong aria-hidden="true">6.6.</strong> The tedge mqtt command</a></li><li class="chapter-item "><a href="references/thin-edge-config-files.html"><strong aria-hidden="true">6.7.</strong> Thin-edge.io configuration files</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">thin-edge.io docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<ul>
<li>
<p><a href="./SUMMARY.html">Summary</a></p>
</li>
<li>
<p><a href="001_overview.html">Introduction</a></p>
</li>
<li>
<p><a href="user_doc.html">User Documentation</a></p>
<ul>
<li><a href="tutorials/tutorials.html">Tutorials</a>
<ul>
<li><a href="./tutorials/getting-started.html">Getting started with thin-edge.io</a></li>
<li><a href="./tutorials/connect-c8y.html">Connect my device to Cumulocity IoT</a></li>
<li><a href="./tutorials/connect-azure.html">Connect my device to Azure IoT</a></li>
<li><a href="./tutorials/connect-aws.html">Connect my device to AWS IoT</a></li>
<li><a href="./tutorials/send-thin-edge-data.html">Send measurements</a></li>
<li><a href="./tutorials/raise-alarm.html">Raise alarms</a></li>
<li><a href="./tutorials/send-events.html">Send events</a></li>
<li><a href="./tutorials/device-monitoring.html">Monitor my device</a></li>
<li><a href="./tutorials/software-management.html">Manage my device software</a></li>
<li><a href="./tutorials/write-my-software-management-plugin.html">Write my software management plugin</a></li>
<li><a href="./tutorials/supported_operations.html">Supported Operations Management for Cumulocity IoT</a></li>
<li><a href="tutorials/yocto-linux.html">Build Thin Edge for a Yocto Linux distribution</a></li>
<li><a href="./tutorials/child-device-config-management.html">Configuration management on child-devices</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="howto-guides/howto-guides.html">How-to Guides</a></p>
<ul>
<li><a href="howto-guides/002_installation.html">Installation</a></li>
<li><a href="./howto-guides/003_registration.html">How to create a test certificate</a></li>
<li><a href="./howto-guides/004_connect.html">How to connect a cloud end-point</a></li>
<li><a href="./howto-guides/005_pub_sub.html">How to send MQTT messages</a></li>
<li><a href="./howto-guides/007_test_connection.html">How to test the cloud connection?</a></li>
<li><a href="./howto-guides/008_config_local_mqtt_bind_address_and_port.html">How to configure the local mqtt bind address and port</a></li>
<li><a href="./howto-guides/009_trouble_shooting_monitoring.html">How to trouble shoot device monitoring</a></li>
<li><a href="./howto-guides/010_add_self_signed_trusted.html">How to add self-signed certificate root to trusted certificates list?</a></li>
<li><a href="./howto-guides/011_retrieve_jwt_token_from_cumulocity.html">How to retrieve JWT token from Cumulocity?</a></li>
<li><a href="./howto-guides/012_install_and_enable_software_management.html">How to install and enable software management?</a></li>
<li><a href="./howto-guides/013_connect_external_device.html">How to connect an external device?</a></li>
<li><a href="./howto-guides/014_thin_edge_logs.html">How to access the logs on the device?</a></li>
<li><a href="./howto-guides/015_installation_without_deb_support.html">How to install thin-edge.io on any Linux OS (no deb support)?</a></li>
<li><a href="./howto-guides/016_restart_device_operation.html">How to restart your thin-edge.io device</a></li>
<li><a href="./howto-guides/017_apama_software_management_plugin.html">How to use apama software management plugin</a></li>
<li><a href="./howto-guides/018_change_temp_path.html">How to change temp path</a></li>
<li><a href="./howto-guides/019_how_to_use_preferred_init_system.html">How to use thin-edge.io with your preferred init system</a></li>
<li><a href="./howto-guides/020_monitor_tedge_health.html">How to monitor health of tedge daemons</a></li>
<li><a href="./howto-guides/021_enable_tedge_watchdog_using_systemd.html">How to enable systemd watchdog monitoring for tedge services?</a></li>
<li><a href="./howto-guides/022_c8y_fragments.html">How to add custom fragments to Cumulocity</a></li>
<li><a href="./howto-guides/023_c8y_log_plugin.html">How to retrieve logs with the log plugin</a></li>
<li><a href="./howto-guides/024_smartrest_templates.html">How to use Cumulocity Custom SmartREST 2.0 Templates with <code>thin-edge.io</code></a></li>
<li><a href="./howto-guides/025_config_management_plugin.html">How to manage configuration files with Cumulocity</a></li>
<li><a href="./howto-guides/026_how_to_install_thin_edge_manually.html">How to install thin-edge manually with OpenRC</a></li>
<li><a href="./howto-guides/child_device_config_management_agent.html">How to enable configuration management on child devices</a></li>
<li><a href="./howto-guides/027_remote_access_with_cumulocity.html">How to connect to your thin-edge.io device with Cumulocity remote access</a></li>
<li><a href="./howto-guides/028_c8y_service_monitoring.html">How to monitor a service from Cumulocity</a></li>
</ul>
</li>
<li>
<p><a href="dev_doc.html">Developer Documentation</a></p>
<ul>
<li>
<p><a href="architecture/architecture.html">Architecture</a></p>
<ul>
<li><a href="architecture/domain-model.html">Domain Model</a></li>
<li><a href="architecture/data-model.html">Data Model</a></li>
<li><a href="architecture/thin-edge-json.html">Thin Edge Json</a></li>
<li><a href="architecture/mapper.html">The Mapper</a></li>
<li><a href="architecture/software-management.html">Software Management</a></li>
<li><a href="architecture/faq.html">Architecture FAQ</a></li>
<li><a href="supported-platforms.html">Platform support</a></li>
<li><a href="references/init-system-config.html">Init System configuration</a></li>
</ul>
</li>
<li>
<p><a href="./tutorials/write-my-software-management-plugin.html">Write my own software management plugin</a></p>
</li>
<li>
<p><a href="./references/c8y-configuration-management.html">Device Configuration Management using Cumulocity</a></p>
</li>
<li>
<p><a href="api.html">APIs</a></p>
<ul>
<li><a href="./references/bridged-topics.html">The Bridged Topics</a></li>
<li><a href="./references/plugin-api.html">The Software Management Plugin API</a></li>
</ul>
</li>
<li>
<p><a href="./BUILDING.html">Building</a></p>
</li>
</ul>
</li>
<li>
<p><a href="references/references.html">Command Line Reference</a></p>
<ul>
<li><a href="./references/tedge.html">The <code>tedge</code> command</a></li>
<li><a href="./references/tedge-config.html">The <code>tedge config</code> command</a></li>
<li><a href="./references/tedge-cert.html">The <code>tedge cert</code> command</a></li>
<li><a href="./references/tedge-connect.html">The <code>tedge connect</code> command</a></li>
<li><a href="./references/tedge-disconnect.html">The <code>tedge disconnect</code> command</a></li>
<li><a href="./references/tedge-mqtt.html">The <code>tedge mqtt</code> command</a></li>
<li><a href="./references/thin-edge-config-files.html">Thin-edge.io configuration files</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<h2 id="why-thin-edgeio"><a class="header" href="#why-thin-edgeio">Why <code>thin-edge.io</code></a></h2>
<p>An open-source &amp; cloud-agnostic IoT framework designed for resource-constrained Edge devices.</p>
<ul>
<li>Simple and secure device connectivity.</li>
<li>Freedom of cloud platform.</li>
<li>Freedom of programming language.</li>
</ul>
<h2 id="how-to-start"><a class="header" href="#how-to-start">How to start</a></h2>
<ol>
<li>The very first step is to <a href="howto-guides/002_installation.html">install <code>thin-edge.io</code></a>
and to connect your device to your IoT cloud,
either <a href="tutorials/connect-c8y.html">Cumulocity IoT</a>,
<a href="tutorials/connect-azure.html">Azure IoT</a>
or <a href="tutorials/connect-aws.html">AWS IoT</a> (10 minutes).</li>
<li>You will then be able to <a href="tutorials/send-thin-edge-data.html">send telemetry data</a> to the cloud
using a <a href="architecture/thin-edge-json.html">cloud-agnostic message format</a> (5 minutes).</li>
<li>The next step is to write your own telemetry component, using your preferred programming language,
say Rust or Python.</li>
</ol>
<h2 id="grow-your-skills"><a class="header" href="#grow-your-skills">Grow your skills</a></h2>
<ul>
<li>Explore the <a href="tutorials/tutorials.html">tutorials and use-cases</a>.</li>
<li>Understand the <a href="architecture/architecture.html">architecture</a>.</li>
<li>Use the <a href="howto-guides/howto-guides.html">how-to guides</a> on a daily basis.</li>
<li>Refer to the <a href="references/references.html">reference guides</a> for any in-depth details.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-documentation"><a class="header" href="#user-documentation">User Documentation</a></h1>
<p>This part of the documentation is meant for users, that want to use thin-edge.io with the feature set that is provided. If you want to develop something on top of thin-edge.io, head over to the <a href="dev_doc.html">Developer Documentation</a>. Even if you do not yet plan to develop for thin-edge.io some of the contents there might be of interest to you to get a deeper technical understanding.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<ul>
<li><a href="tutorials/./connect-c8y.html">Connect my device to Cumulocity IoT</a></li>
<li><a href="tutorials/./connect-azure.html">Connect my device to Azure IoT</a></li>
<li><a href="tutorials/./connect-aws.html">Connect my device to AWS IoT</a></li>
<li><a href="tutorials/./send-thin-edge-data.html">Send Thin Edge Json data</a></li>
<li><a href="tutorials/./device-monitoring.html">Monitor my device</a></li>
<li><a href="tutorials/./software-management.html">Manage my device software</a></li>
<li><a href="tutorials/./child-device-config-management.html">Child device config management</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-thin-edgeio-on-a-raspberry-pi"><a class="header" href="#getting-started-with-thin-edgeio-on-a-raspberry-pi">Getting started with thin-edge.io on a Raspberry Pi</a></h1>
<p>After following this tutorial you will have an overview of the installation and configuration of thin-edge.io. As an example, a Raspberry Pi is used. This tutorial explains in small steps to reach the goal of sending data to Cumulocity IoT and performing some additional device management tasks.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>thin-edge.io is an open-source project to provide a cloud-agnostic edge framework. It is much more generic than the device management agent, so it can connect to multiple IoT cloud platforms, and it allows flexible logic executed on the device. It is optimized for a very small footprint and high performance.</p>
<p>The Raspberry PI is a relatively simple and cheap device but powerful. Therefore it is ideal for testing and try-outs and some production use cases.</p>
<h2 id="prerequisite"><a class="header" href="#prerequisite">Prerequisite</a></h2>
<p>To follow this guide, you only need the following:</p>
<ul>
<li>
<p>A <a href="https://www.softwareag.cloud/site/product/cumulocity-iot.html">Cumulocity IoT</a> Trial tenant.</p>
</li>
<li>
<p>A Raspberry Pi (3 or 4) with Raspian installed, for other boards and OS'es have a look <a href="https://github.com/thin-edge/thin-edge.io/blob/main/docs/src/supported-platforms.md">here</a></p>
</li>
<li>
<p>Updated device:
<code>sudo apt-get update &amp;&amp; sudo apt-get upgrade</code></p>
</li>
</ul>
<h2 id="steps"><a class="header" href="#steps">Steps</a></h2>
<p>This tutorial is divided into small steps. The first three steps are needed to install and connect to Cumulocity IoT. The last three are optional but needed to get a good overview of the capabilities of thin-edge.io.</p>
<p><a href="tutorials/getting-started.html#Step-1-Install-thin-edge.io">Step 1 Install thin-edge.io</a></p>
<p><a href="tutorials/getting-started.html#Step-2-Configure-and-Connect-to-Cumulocity-IoT">Step 2 Configure and Connect to Cumulocity IoT</a></p>
<p><a href="tutorials/getting-started.html#Step-3-Sending-Device-Data">Step 3 Sending Device Data</a></p>
<p><a href="tutorials/getting-started.html#Step-4-Monitor-the-device">Step 4 Monitor the device</a></p>
<p><a href="tutorials/getting-started.html#Step-5-Add-software-management">Step 5 Add software management</a></p>
<p><a href="tutorials/getting-started.html#Step-6-Manage-configuration-files">Step 6 Manage configuration files</a></p>
<p><a href="tutorials/getting-started.html#Step-7-Manage-Log-Files">Step 7 Manage Log Files</a></p>
<h2 id="step-1-install-thin-edgeio"><a class="header" href="#step-1-install-thin-edgeio">Step 1 Install thin-edge.io</a></h2>
<p>There are two ways to install thin-edge.io:</p>
<ul>
<li>Use a script</li>
<li>Manually</li>
</ul>
<p>The easiest way is to use the installation script with this command:</p>
<pre><code>curl -fsSL https://raw.githubusercontent.com/thin-edge/thin-edge.io/main/get-thin-edge_io.sh | sudo sh -s
</code></pre>
<p>This script will install the latest version of thin-edge.io with the following components:</p>
<ul>
<li>Mosquitto</li>
<li>Command line Interface (CLI) tool</li>
<li>Tedge mapper</li>
</ul>
<p>It is possible to do the installation of thin-edge.io manually or install another version or upgrade the current version. For more information on that, please have a look <a href="https://thin-edge.github.io/thin-edge.io/html/howto-guides/002_installation.html#thin-edgeio-manual-installation">here</a> for more information.</p>
<p>After a successful installation, it is possible to use thin-edge.io via the CLI and use the tedge commands.</p>
<h3 id="tedge-cli"><a class="header" href="#tedge-cli">Tedge CLI</a></h3>
<p>In the previous step, the CLI tool is installed, which is a very powerful</p>
<p>The usage is as follows:</p>
<pre><code>tedge [OPTIONS] [SUBCOMMAND]
</code></pre>
<p>and <code>-h</code> can be used to see the help for the latest subcommand.</p>
<p>When running this command something similar like the following will be displayed:</p>
<pre><code class="language-shell">sudo tedge -h
</code></pre>
<pre><code>tedge 0.9.0
tedge is the cli tool for thin-edge.io

USAGE:
    tedge [OPTIONS] [SUBCOMMAND]

OPTIONS:
        --config-dir &lt;CONFIG_DIR&gt;    [default: /etc/tedge]
    -h, --help                       Print help information
        --init                       Initialize the tedge
    -V, --version                    Print version information

SUBCOMMANDS:
    cert          Create and manage device certificate
    config        Configure Thin Edge
    connect       Connect to connector provider
    disconnect    Remove bridge connection for a provider
    help          Print this message or the help of the given subcommand(s)
    mqtt          Publish a message on a topic and subscribe a topic
</code></pre>
<p>Here is an <a href="https://thin-edge.github.io/thin-edge.io/html/references/references.html">overview of the commands for the CLI tool</a>.</p>
<p>The CLI will be used to configure the thin-edge.io installation on the device in the next steps.</p>
<h2 id="step-2-configure-and-connect-to-cumulocity-iot"><a class="header" href="#step-2-configure-and-connect-to-cumulocity-iot">Step 2 Configure and Connect to Cumulocity IoT</a></h2>
<p>To connect the device to the Cumulocity IoT it needs to be configured.
The following configuration parameter is mandatory:</p>
<pre><code>C8Y URL
</code></pre>
<p>This URL is needed to allow the upload of the certificate to the specific tenant and the registration of the device. It can be configured via:</p>
<pre><code>sudo tedge config set c8y.url {{YOUR_C8Y_URL}}
</code></pre>
<h3 id="certificate"><a class="header" href="#certificate">Certificate</a></h3>
<p>thin-edge.io connects via MQTT protocol using a X.509 certificate for authentication. To do so, a certificate must be trusted by Cumulocity IoT. A certificate is trusted when it is added to the trusted certificates and is in an activated state.</p>
<p>First, we need to create the device certificate locally (If the device certificate is already uploaded, directly via the UI to Cumulocity IoT this step can be skipped).</p>
<pre><code>sudo tedge cert create --device-id {{YOUR_UNIQUE_DEVICE_ID}}
</code></pre>
<p>The device id is a unique identifier e.g. the MAC address that identifies the physical device.</p>
<p>The certificate is uploaded to the Cumulocity IoT Tenant via:</p>
<pre><code>sudo tedge cert upload c8y --user {{YOUR_USERNAME}}
</code></pre>
<p>If the password prompt appears, enter your password.</p>
<p><code>NOTE</code>: In a production environment, it is not recommended to use the above self-signed certificate, which is for demo purposes. If you plan to use this tutorial as a basis for production, please have a look here: <a href="https://cumulocity.com/guides/10.7.0/device-sdk/mqtt/#device-certificates">Registering devices using certificates</a>.</p>
<h3 id="connect"><a class="header" href="#connect">Connect</a></h3>
<p>We now are ready to connect the device to Cumulocity IoT. This can be achieved via:</p>
<pre><code>sudo tedge connect c8y
</code></pre>
<p>When the connection is established, the device will be created in Cumulocity IoT. When you go to Device Management -&gt; Devices -&gt; All devices, the device is visible in the list.</p>
<p><img src="tutorials/./images/DevicesList.png" alt="NewDevice" /></p>
<h2 id="step-3-sending-device-data"><a class="header" href="#step-3-sending-device-data">Step 3 Sending Device Data</a></h2>
<p>Once your device is configured and connected to Cumulocity IoT, you can start sending measurements, events or alarms. In the standard configuration, you can not connect externally to the mosquito broker and thus the messages have to be sent directly from the device itself.</p>
<p>The tedge CLI allows you to send payloads via MQTT the following way:</p>
<pre><code>tedge mqtt pub {{TOPIC}} {{PAYLOAD}}
</code></pre>
<p>thin-edge.io comes with a tedge-mapper daemon. This process collects the data from the <code>tedge/#</code> topics and translates them to the tedge payloads on the <code>c8y/#</code> topics which are mapped directly to Cumulocity IoT. The mapper translates simple JSON to the desired target payload for Cumulocity IoT.</p>
<h3 id="sending-measurements"><a class="header" href="#sending-measurements">Sending measurements</a></h3>
<p>Measurements within Cumulocity IoT represent regularly acquired readings and statistics from sensors.</p>
<p>A simple single-valued measurement like a temperature measurement can be represented in Thin Edge JSON as follows:</p>
<pre><code>{ &quot;temperature&quot;: 25 }
</code></pre>
<p>With the key-value pair representing the measurement type and the numeric value of the measurement. The endpoint that is supervised by the tedge-mapper for measurements is:</p>
<pre><code>tedge/measurements
</code></pre>
<p>The temperature measurement described above can be sent as follows:</p>
<pre><code>tedge mqtt pub tedge/measurements '{ &quot;temperature&quot;: 25 }'
</code></pre>
<h3 id="sending-events"><a class="header" href="#sending-events">Sending events</a></h3>
<p>Events are used to pass real-time information, which is not just plain sensor values, through Cumulocity IoT.</p>
<p>A simple event can be represented in Thin Edge JSON as follows:</p>
<pre><code>{
    &quot;text&quot;: &quot;A door was closed&quot;,
    &quot;time&quot;: &quot;2022-06-10T05:30:45+00:00&quot;
}
</code></pre>
<p>The endpoint that is supervised by the tedge-mapper for events is:</p>
<pre><code>tedge/events/{{event-type}}
</code></pre>
<p>So the door open event described above can be sent as follows:</p>
<pre><code>tedge mqtt pub tedge/events/door '{&quot;text&quot;: &quot;A door was closed&quot;,&quot;time&quot;: &quot;2022-06-10T05:30:45+00:00&quot;}'
</code></pre>
<p>When you go to events (<code>Device management -&gt; your device -&gt; events </code>), you should see this:</p>
<p><img src="tutorials/./images/SendingEvents.png" alt="Sending Events" /></p>
<h2 id="step-4-monitor-the-device"><a class="header" href="#step-4-monitor-the-device">Step 4 Monitor the device</a></h2>
<p>With thin-edge.io device monitoring, you can collect metrics from the device and forward these device metrics to Cumulocity IoT.</p>
<p>thin-edge.io uses the open source component <code>collectd</code> to collect the metrics from the device. thin-edge.io translates the <code>collected</code> metrics from their native format to the thin-edge.io JSON format and then into the cloud-vendor-specific format.</p>
<p>Enabling monitoring on your device is a 3-steps process:</p>
<ul>
<li>Install collectd</li>
<li>Configure collectd</li>
<li>Enable thin-edge.io monitoring</li>
</ul>
<h3 id="install-collectd"><a class="header" href="#install-collectd">Install collectd</a></h3>
<p>Because thin-edge.io uses the MQTT plugin of collectd, installation of the Mosquitto client library (either libmosquitto1 or mosquitto-clients) is required.</p>
<pre><code>sudo apt-get install libmosquitto1
</code></pre>
<p>To install collectd:</p>
<pre><code>sudo apt-get install collectd-core
</code></pre>
<h3 id="configure-collectd"><a class="header" href="#configure-collectd">Configure collectd</a></h3>
<p>thin-edge.io provides a basic collectd configuration that can be used to collect CPU, memory and disk metrics.</p>
<p>Simply copy the file to the main collectd configuration file and restart the daemon.</p>
<pre><code>sudo cp /etc/tedge/contrib/collectd/collectd.conf /etc/collectd/collectd.conf
sudo systemctl restart collectd
</code></pre>
<p>What you should see by now is that data arrives on the <code>collectd/#</code> topics. You can check that via:</p>
<pre><code>tedge mqtt sub collectd/#
</code></pre>
<p>The output will be similar like:</p>
<pre><code class="language-shell">tedge mqtt sub 'collectd/#'
</code></pre>
<pre><code>INFO: Connected
[collectd/raspberrypi/df-root/percent_bytes-used] 1667205183.407:11.7998857498169
[collectd/raspberrypi/memory/percent-used] 1667205183.408:4.87045198079293
[collectd/raspberrypi/cpu/percent-active] 1667205184.398:1.52284263959391

</code></pre>
<h3 id="enable-collectd"><a class="header" href="#enable-collectd">Enable Collectd</a></h3>
<p>To enable monitoring on your device, you have to launch the <code>tedge-mapper-collectd daemon</code> process. This process collects the data from the <code>collectd/#</code> topics and translates them to the tedge payloads on the <code>c8y/#</code> topics.</p>
<pre><code>sudo systemctl start tedge-mapper-collectd
sudo systemctl enable tedge-mapper-collectd
</code></pre>
<p>You can inspect the collected and translated metrics, by subscribing to these topics:</p>
<pre><code>tedge mqtt sub 'c8y/#'

</code></pre>
<p>The output will be similar like:</p>
<pre><code class="language-shell">tedge mqtt sub 'c8y/#'
</code></pre>
<pre><code class="language-shell">INFO: Connected
[c8y/measurement/measurements/create] {&quot;type&quot;:&quot;ThinEdgeMeasurement&quot;,&quot;time&quot;:&quot;2022-10-31T08:35:44.398000001Z&quot;,&quot;cpu&quot;:{&quot;percent-active&quot;:{&quot;value&quot;:1.26262626262626}},&quot;memory&quot;:{&quot;percent-used&quot;:{&quot;value&quot;:4.87024847292786}}}
[c8y/measurement/measurements/create] {&quot;type&quot;:&quot;ThinEdgeMeasurement&quot;,&quot;time&quot;:&quot;2022-10-31T08:35:45.398000001Z&quot;,&quot;memory&quot;:{&quot;percent-used&quot;:{&quot;value&quot;:4.87024847292786}},&quot;cpu&quot;:{&quot;percent-active&quot;:{&quot;value&quot;:1.01522842639594}}}
[c8y/measurement/measurements/create] {&quot;type&quot;:&quot;ThinEdgeMeasurement&quot;,&quot;time&quot;:&quot;2022-10-31T08:35:46.398000001Z&quot;,&quot;memory&quot;:{&quot;percent-used&quot;:{&quot;value&quot;:4.87024847292786}},&quot;cpu&quot;:{&quot;percent-active&quot;:{&quot;value&quot;:0.759493670886076}}}
[c8y/measurement/measurements/create] {&quot;type&quot;:&quot;ThinEdgeMeasurement&quot;,&quot;time&quot;:&quot;2022-10-31T08:35:47.398000001Z&quot;,&quot;memory&quot;:{&quot;percent-used&quot;:{&quot;value&quot;:4.87024847292786}},&quot;cpu&quot;:{&quot;percent-active&quot;:{&quot;value&quot;:2.01005025125628}}}
[c8y/measurement/measurements/create] {&quot;type&quot;:&quot;ThinEdgeMeasurement&quot;,&quot;time&quot;:&quot;2022-10-31T08:35:48.398000001Z&quot;,&quot;memory&quot;:{&quot;percent-used&quot;:{&quot;value&quot;:4.87004496506279}},&quot;cpu&quot;:{&quot;percent-active&quot;:{&quot;value&quot;:0.254452926208651}}}

</code></pre>
<p>The monitoring data will appear in Cumulocity IoT on the device in the measurement section.
<img src="tutorials/./images/CollectdMeasurements.png" alt="CollectdMeasurements" /></p>
<h3 id="edit-collectd"><a class="header" href="#edit-collectd">Edit Collectd</a></h3>
<p>To change the monitored data, it is needed to change the collectd.conf. This can be done via Cumulocity IoT. In Step 6 is explained how to do that.</p>
<h2 id="step-5-add-software-management"><a class="header" href="#step-5-add-software-management">Step 5 Add software management</a></h2>
<p>Software management takes care of allowing installation and management of any type of software from Cumulocity IoT. Since the type is generic, any type of software can be managed. In thin-edge.io this can be extended with plugins. For every software type, a particular plugin is needed.</p>
<p>The following plugins do exist:</p>
<ul>
<li>Docker</li>
<li>APT</li>
<li>Docker-compose</li>
<li>Snap</li>
</ul>
<p>To use those plugins they need to be copied to:</p>
<p><code>/etc/tedge/sm-plugins</code></p>
<p>The APT plugin is installed automatically. You can find the other plugins in the repository. Make sure to disconnect/reconnect the device after adding plugins via:</p>
<pre><code>sudo tedge disconnect c8y
sudo tedge connect c8y
</code></pre>
<h2 id="adding-new-software-into-the-software-repository-in-cumulocity-iot"><a class="header" href="#adding-new-software-into-the-software-repository-in-cumulocity-iot">Adding new software into the software repository in Cumulocity IoT</a></h2>
<ol>
<li>
<p>Go to Cumulocity IoT</p>
</li>
<li>
<p>Go to <code>Management</code> -&gt; <code>Software repository</code> (left in the menu) and click <code>Add software</code> at the right of the top menu bar.</p>
</li>
<li>
<p>In the dialog box, enter a name for the software and confirm it by clicking <code>Add new</code>, a description and its version.</p>
</li>
<li>
<p>thin-edge.io contains a default plugin supporting <code>debian</code> packages from both <code>apt</code> repositories as well as remote locations.
If you prefer to use packages from an <code>apt</code> repository, select the <code>Provide a file path</code> option and give an empty space (' ').</p>
</li>
</ol>
<p><img src="tutorials/./images/AddSoftware.png" alt="Add new software" /></p>
<p>If you would like to use other sources (eg. a file uploaded to your cloud or an external source), provide the full URL to the file.
If you would like to upload your binaries, select <code>Upload a binary</code> option and upload the file to Cumulocity IoT software repository.</p>
<ol start="5">
<li>Press <code>Add Software</code> button.</li>
</ol>
<h2 id="installing-software-on-a-device"><a class="header" href="#installing-software-on-a-device">Installing software on a device</a></h2>
<ol>
<li>Go to Cumulocity IoT</li>
<li>Click <code>All devices</code> in the Devices menu, select the desired device from the device list and open its Software tab.</li>
</ol>
<p>The Software tab shows a list of all available software installed on the device. If a given software has a type, it will be displayed next to its name. It is possible to search for a particular software by its name or filter the list by software type.
3. Click on <code>Install software</code>, on the bottom of the page
4. Find/select the software which was added to the repository in the previous step.
5. Select the right version and click on <code>install</code>
6. Then click on <code>apply changes</code>, the software will be installed.</p>
<p>When a different version of the already installed software needs to be installed, choose in step 4 the installed software from the list and in step 5 the right version.</p>
<p>Find more information about <a href="https://cumulocity.com/guides/users-guide/device-management/#managing-software-on-a-device">how to manage the software</a> on a device.</p>
<p>How to <a href="https://thin-edge.github.io/thin-edge.io/html/tutorials/write-my-software-management-plugin.html">develop your own plugins</a> is described here.</p>
<h2 id="step-6-manage-configuration-files"><a class="header" href="#step-6-manage-configuration-files">Step 6 Manage configuration files</a></h2>
<p>With thin-edge.io it is possible to manage config files on a device by using the Cumulocity IoT configuration management feature as a part of Device Management.</p>
<p>This functionality is directly installed with the initial script. However, it is needed to configure the <code>/etc/tedge/c8y/c8y-configuration-plugin.toml</code> and add the entries for the configuration files which need to be managed. Just copy the following content to that file:</p>
<pre><code>files = [
    { path = '/etc/tedge/tedge.toml' },
    { path = '/etc/tedge/mosquitto-conf/c8y-bridge.conf', type = 'c8y-bridge.conf' },
    { path = '/etc/tedge/mosquitto-conf/tedge-mosquitto.conf', type = 'tedge-mosquitto.conf' },
    { path = '/etc/mosquitto/mosquitto.conf', type = 'mosquitto.conf' }
]
</code></pre>
<p>where:</p>
<ul>
<li>path is the full path to the configuration file.</li>
<li>type is a unique alias for each file entry which will be used to represent that file in Cumulocity UI.</li>
</ul>
<p>Then start the configuration plugin process and enable it on boot by <code>systemctl</code> .</p>
<pre><code>sudo systemctl start c8y-configuration-plugin.service
sudo systemctl enable c8y-configuration-plugin.service
</code></pre>
<p>Then navigate to  Cumulocity IoT Device Management and the desired device. Open its Configuration tab. You can find c8y-configuration-plugin and more are listed as supported configuration types, as declared in the plugin configuration file. Here you can save the configuration files into the repository or download them.</p>
<h2 id="change-configuration-files-via-cumulocity-iot"><a class="header" href="#change-configuration-files-via-cumulocity-iot">Change configuration files via Cumulocity IoT.</a></h2>
<p>If there is a need to change one or more configuration files, there is more than one option to follow:</p>
<ul>
<li>Create a whole new configuration file</li>
<li>Change an existing configuration file</li>
</ul>
<p>In this tutorial the last option is explained, there are some steps to be taken:</p>
<p><img src="tutorials/./images/ConfigurationManagement.png" alt="Configuration Management" /></p>
<ol>
<li>
<p>Save the configuration file to the repository (<code>Device management -&gt; configuration</code>. In the list of configuration files  pick  a file to change and click on <code>Save to repository</code>).</p>
</li>
<li>
<p>Go to <code>Management -&gt; configuration snapshots repository</code>.</p>
</li>
<li>
<p>Download the configuration file which needs to be changed (the one you saved to the repository in step 1).</p>
</li>
<li>
<p>Edit this file as needed.</p>
</li>
<li>
<p>Click on <code>Add configuration snapshot</code> (top right).</p>
</li>
<li>
<p>Fill the fields, make sure the device type is <code>thin-edge.io</code>, select the right Configuration type and add the (just edited) configuration file and click on  <code>Add configuration</code>.</p>
</li>
<li>
<p>Go back to the device and then to the configuration. In the Available supported configuration you will see the configuration file which was just created. When you click on it, you will see the content.</p>
</li>
<li>
<p>Then click on  <code>send configuration to device</code> the configuration file is uploaded to the device.</p>
</li>
<li>
<p>If you then click on <code>get snapshot from device</code> (select the right configuration file in device supported configurations), you will see the change of the configuration file.</p>
</li>
<li>
<p>Then click on  <code>send configuration to device</code> the configuration file is uploaded to the device.</p>
</li>
<li>
<p>If you then click on <code>get snapshot from device</code> (select the right configuration file in device-supported configurations), you will see the change of the configuration file.</p>
</li>
</ol>
<p><img src="tutorials/./images/ChangeConfiguration.png" alt="Change Configuration" /></p>
<h2 id="change-collectd-configuration-file-via-cumulocity-iot"><a class="header" href="#change-collectd-configuration-file-via-cumulocity-iot">Change collectd configuration file via Cumulocity IoT.</a></h2>
<p>To change the collectd metrics of the device, which are displayed in Cumulocity IoT, the next steps are needed. These are similar to the steps in the previous paragraphs.</p>
<ol>
<li>
<p>Add this line <code>{ path = '/etc/collectd/collectd.conf', type = 'collectd.conf' }, </code> to the <code>/etc/tedge/c8y/c8y-configuration-plugin.toml</code> file.</p>
</li>
<li>
<p>Save the configuration file to the repository</p>
</li>
<li>
<p>Go to <code>Management -&gt; configuration</code> snapshots repository</p>
</li>
<li>
<p>Download the configuration file which needs to be changed</p>
</li>
<li>
<p>Edit this file as needed</p>
</li>
<li>
<p>Click on <code>Add configuration snapshot</code> (top right)</p>
</li>
<li>
<p>Fill in the fields, make sure the device type is <code>thin-edge.io</code> and select the right Configuration type and add the (just edited) configuration file.) and click on  <code>Add configuration </code></p>
</li>
<li>
<p>Go back to the device and then to the configuration. In the Available supported configuration you will see the configuration file which was just created. When you click on it, you will see the content</p>
</li>
<li>
<p>Then click on  <code>send configuration toe device</code> the configuration file is uploaded to the device.</p>
</li>
<li>
<p>If you then click on get snapshot from device (select the right configuration file in device supported configurations), you will see the change of the configuration file.</p>
</li>
</ol>
<h2 id="step-7-manage-log-files"><a class="header" href="#step-7-manage-log-files">Step 7 Manage Log Files</a></h2>
<p>With thin-edge.io it is possible to request log files from a device by using the Cumulocity IoT log request feature as a part of Device Management.</p>
<p>This functionality is also directly installed with the initial script, but some configuration is needed for the <code>/etc/tedge/c8y/c8y-log-plugin.toml</code> and add the entries for the log files that can be requested. Just copy the following content to that file:</p>
<pre><code>files = [
  { type = &quot;software-management&quot;, path = &quot;/var/log/tedge/agent/software-*&quot; },
  { type = &quot;mosquitto&quot;, path = &quot;/var/log/mosquitto/mosquitto.log&quot; },
  { type = &quot;daemon&quot;, path = &quot;/var/log/daemon.log&quot; },
  { type = &quot;user&quot;, path = &quot;/var/log/user.log&quot; },
  { type = &quot;apt-history&quot;, path = &quot;/var/log/apt/history.log&quot; },
  { type = &quot;apt-term&quot;, path = &quot;/var/log/apt/term.log&quot; },
  { type = &quot;auth&quot;, path = &quot;/var/log/auth.log&quot; },
  { type = &quot;dpkg&quot;, path = &quot;/var/log/dpkg.log&quot; },
  { type = &quot;kern&quot;, path = &quot;/var/log/kern.log&quot; }
]
</code></pre>
<p>The daemon is started/enabled via:</p>
<pre><code>sudo systemctl start c8y-log-plugin

sudo systemctl enable c8y-log-plugin
</code></pre>
<p>To see the content of the log files in Cumulocity IoT, take the following steps:</p>
<ol>
<li>
<p>Go to device management and select the right device.</p>
</li>
<li>
<p>Select <code>Logs</code>. In this screen, you can request Log files</p>
</li>
<li>
<p>Click on <code>Request log file</code>(the top right).</p>
</li>
<li>
<p>In the next screen you can select a date range and a type of log.</p>
</li>
<li>
<p>Then click on <code>Request log file</code>.</p>
</li>
<li>
<p>Refresh the page.</p>
</li>
<li>
<p>Click on the requested log file, you should see something similar to this:</p>
</li>
</ol>
<p><img src="tutorials/./images/RequestLogfile.png" alt="Request Log file" /></p>
<p>If <code>c8y-log-plugin.toml</code> is added to the <code>c8y-configuration-plugin.toml</code> it is possible to do the administration from there.
However, keep in mind that the daemon has to be restarted every time the <code>/etc/tedge/c8y/c8y-log-plugin.toml</code> is touched via the command line.</p>
<h3 id="final-remarks-and-summary"><a class="header" href="#final-remarks-and-summary">Final remarks and summary</a></h3>
<p>With this getting started tutorial you gained some insights on how to install and configure thin-edge.io on a Raspberry Pi.</p>
<p>If you didn't try the optional steps in this tutorial, it might be a nice idea to work on these as you then get a better insight into the device management capabilities of thin-edge.io. Other things you can work on are capabilities like working with child devices, building your own plugin etc. Tutorials for that can be found <a href="https://thin-edge.github.io/thin-edge.io/html/">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connect-your-device-to-cumulocity-iot"><a class="header" href="#connect-your-device-to-cumulocity-iot">Connect your device to Cumulocity IoT</a></h1>
<p>The very first step to enable <code>thin-edge.io</code> is to connect your device to the cloud.</p>
<ul>
<li>This is a 10 minutes operation to be done only once.</li>
<li>It establishes a permanent connection from your device to the cloud end-point.</li>
<li>This connection is secure (encrypted over TLS), and the two peers are identified by x509 certificates.</li>
<li>Sending data to the cloud will then be as simple as sending data locally.</li>
</ul>
<p>The focus is here on connecting to <a href="https://www.cumulocity.com/guides/concepts/introduction/">Cumulocity IoT</a>.
See this <a href="tutorials/connect-azure.html">tutorial</a>, if you want to connect Azure IoT instead.
See this <a href="tutorials/connect-aws.html">tutorial</a>, if you want to connect AWS IoT instead.</p>
<p>Before you try to connect your device to Cumulocity IoT, you need:</p>
<ul>
<li>The url of the endpoint to connect (e.g. <code>eu-latest.cumulocity.com</code>).</li>
<li>Your credentials to connect Cumulocity:
<ul>
<li>Your tenant identifier (e.g. <code>t00000007</code>), a user name and password.</li>
<li>None of these credentials will be stored on the device.</li>
<li>These are only required once, to register the device.</li>
</ul>
</li>
</ul>
<p>If not done yet, <a href="tutorials/../howto-guides/002_installation.html">install <code>thin-edge.io</code> on your device</a>.</p>
<p>You can now use the <a href="tutorials/../references/tedge.html"><code>tedge</code> command</a> to:</p>
<ul>
<li><a href="tutorials/connect-c8y.html#create-the-certificate">create a certificate for you device</a>,</li>
<li><a href="tutorials/connect-c8y.html#make-the-device-trusted-by-cumulocity">make the device certificate trusted by Cumulocity</a>,</li>
<li><a href="tutorials/connect-c8y.html#connect-the-device">connect the device</a>, and</li>
<li><a href="tutorials/connect-c8y.html#sending-your-first-telemetry-data">send your first telemetry data</a>.</li>
</ul>
<h2 id="configure-the-device"><a class="header" href="#configure-the-device">Configure the device</a></h2>
<p>To connect the device to the Cumulocity IoT, one needs to set the URL of your Cumulocity IoT tenant and the root certificate as below.</p>
<p>Set the URL of your Cumulocity IoT tenant.</p>
<pre><code>sudo tedge config set c8y.url your-tenant.cumulocity.com
</code></pre>
<p>Set the path to the root certificate if necessary. The default is <code>/etc/ssl/certs</code>.</p>
<pre><code>sudo tedge config set c8y.root.cert.path /etc/ssl/certs
</code></pre>
<p>This will set the root certificate path of the Cumulocity IoT.
In most of the Linux flavors, the certificate will be present in /etc/ssl/certs.
If not found download it from <a href="https://www.identrust.com/dst-root-ca-x3">here</a>.</p>
<h2 id="connecting-to-cumulocity-server-signed-with-self-signed-certificate"><a class="header" href="#connecting-to-cumulocity-server-signed-with-self-signed-certificate">Connecting to Cumulocity server signed with self-signed certificate</a></h2>
<p>If the Cumulocity IoT instance that you're connecting to, is signed with a self-signed certificate(eg: Cumulocity IoT Edge instance),
then the path to that server certificate must be set as the c8y.root.cert.path as follows:</p>
<pre><code>sudo tedge config set c8y.root.cert.path /path/to/the/self-signed/certificate
</code></pre>
<blockquote>
<p>Note: This is the certificate chain of the server and not the device's certificate kept at /etc/tedge/device-certs directory.</p>
</blockquote>
<p>If the Cumulocity server's certificate chain file isn't available locally, it can be downloaded using a web browser or using some other
third-party tools like openssl command as follows (to be adjusted based on your env):</p>
<p><code>openssl s_client -connect &lt;hostname&gt;:&lt;port&gt; &lt; /dev/null 2&gt;/dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'</code></p>
<h2 id="create-the-certificate"><a class="header" href="#create-the-certificate">Create the certificate</a></h2>
<p>The <code>tedge cert create</code> command creates a self-signed certificate which can be used for testing purpose.</p>
<p>A single argument is required: an identifier for the device.
This identifier will be used to uniquely identify your devices among others in your cloud tenant.
This identifier will be also used as the Common Name (CN) of the certificate.
Indeed, this certificate aims to authenticate that this device is actually the device with that identity.</p>
<pre><code>sudo tedge cert create --device-id my-device
</code></pre>
<pre><code>Certificate was successfully created
</code></pre>
<p>You can then check the content of that certificate.</p>
<pre><code class="language-shell">sudo tedge cert show
</code></pre>
<pre><code>Device certificate: /etc/tedge/device-certs/tedge-certificate.pem
Subject: CN=my-device, O=Thin Edge, OU=Test Device
Issuer: CN=my-device, O=Thin Edge, OU=Test Device
Valid from: Tue, 09 Feb 2021 17:16:52 +0000
Valid up to: Tue, 11 May 2021 17:16:52 +0000
Thumbprint: CDBF4EC17AA02829CAC4E4C86ABB82B0FE423D3E
</code></pre>
<p>You may notice that the issuer of this certificate is the device itself.
This is a self-signed certificate.
To use a certificate signed by your Certificate Authority,
see the reference guide of <a href="tutorials/../references/tedge-cert.html"><code>tedge cert</code></a>.</p>
<h2 id="make-the-device-trusted-by-cumulocity"><a class="header" href="#make-the-device-trusted-by-cumulocity">Make the device trusted by Cumulocity</a></h2>
<p>For a certificate to be trusted by Cumulocity,
one needs to add the certificate of the signing authority to the list of trusted certificates.
In the Cumulocity GUI, navigate to &quot;Device Management/Management/Trusted certificates&quot;
in order to see this list for your Cumulocity tenant.</p>
<p>Here, the device certificate is self-signed and has to be directly trusted by Certificate.
This can be done:</p>
<ul>
<li>either with the GUI: upload the certificate from your device (<code>/etc/tedge/device-certs/tedge-certificate.pem</code>)
to your tenant &quot;Device Management/Management/Trusted certificates&quot;.</li>
<li>or using the <code>tedge cert upload c8y</code> command.</li>
</ul>
<pre><code class="language-shell">sudo tedge cert upload c8y --user &lt;username&gt;
</code></pre>
<blockquote>
<p>To upload the certificate to cumulocity this user needs to have &quot;Tenant management&quot; admin rights. If you get an error 503 here, check the appropriate rights in cumulocity user management.</p>
</blockquote>
<h2 id="connect-the-device"><a class="header" href="#connect-the-device">Connect the device</a></h2>
<p>Now, you are ready to run <code>tedge connect c8y</code>.
This command configures the MQTT broker:</p>
<ul>
<li>to establish a permanent and secure connection to the cloud,</li>
<li>to forward local messages to the cloud and vice versa.</li>
</ul>
<p>Also, if you have installed <code>tedge-mapper</code>, this command starts and enables the tedge-mapper-c8y systemd service.
At last, it sends packets to Cumulocity to check the connection.
If your device is not yet registered, you will find the digital-twin created in your tenant after <code>tedge connect c8y</code>!</p>
<pre><code class="language-shell">sudo tedge connect c8y
</code></pre>
<pre><code>Checking if systemd is available.

Checking if configuration for requested bridge already exists.

Validating the bridge certificates.

Creating the device in Cumulocity cloud.

Saving configuration for requested bridge.

Restarting mosquitto service.

Awaiting mosquitto to start. This may take up to 5 seconds.

Enabling mosquitto service on reboots.

Successfully created bridge connection!

Sending packets to check connection. This may take up to 2 seconds.

Connection check is successful.

Checking if tedge-mapper is installed.

Starting tedge-mapper-c8y service.

Persisting tedge-mapper-c8y on reboot.

tedge-mapper-c8y service successfully started and enabled!

Enabling software management.

Checking if tedge-agent is installed.

Starting tedge-agent service.

Persisting tedge-agent on reboot.

tedge-agent service successfully started and enabled!
</code></pre>
<h2 id="sending-your-first-telemetry-data"><a class="header" href="#sending-your-first-telemetry-data">Sending your first telemetry data</a></h2>
<p>Sending data to Cumulocity is done using MQTT over topics prefixed with <code>c8y</code>.
Any messages sent to one of these topics will be forwarded to Cumulocity.
The messages are expected to have a format specific to each topic.
Here, we use <code>tedge mqtt pub</code> a raw Cumulocity SmartRest message to be understood as a temperature of 20 Celsius.</p>
<pre><code class="language-shell">tedge mqtt pub c8y/s/us 211,20
</code></pre>
<p>To check that this message has been received by Cumulocity,
navigate to &quot;Device Management/Devices/All devices/&lt;your device id&gt;/Measurements&quot;.
You should observe a &quot;temperature measurement&quot; graph with the new data point.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>You can now:</p>
<ul>
<li>learn how to <a href="tutorials/send-thin-edge-data.html">send various kind of telemetry data</a>
using the cloud-agnostic <a href="tutorials/../architecture/thin-edge-json.html">Thin-Edge-Json data format</a>,</li>
<li>or have a detailed view of the <a href="tutorials/../references/bridged-topics.html#cumulocity-mqtt-topics">topics mapped to and from Cumulocity</a>
if you prefer to use directly Cumulocity specific formats and protocols.</li>
<li>learn how to <a href="tutorials/../howto-guides/022_c8y_fragments.html">add custom fragments to cumulocity</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connect-your-device-to-azure-iot"><a class="header" href="#connect-your-device-to-azure-iot">Connect your device to Azure IoT</a></h1>
<p>The very first step to enable <strong>thin-edge.io</strong> is to connect your device to the cloud.</p>
<ul>
<li>This is a 10 minutes operation to be done only once.</li>
<li>It establishes a permanent connection from your device to the cloud end-point.</li>
<li>This connection is secure (encrypted over TLS), and the two peers are identified by x509 certificates.</li>
<li>Sending data to the cloud will then be as simple as sending data locally.</li>
</ul>
<p>The focus is here on connecting the device to Azure IoT.
See this <a href="tutorials/connect-c8y.html">tutorial</a>, if you want to connect Cumulocity IoT instead.
See this <a href="tutorials/connect-aws.html">tutorial</a>, if you want to connect AWS IoT instead.</p>
<p>Before you try to connect your device to Azure IoT, you need:</p>
<ul>
<li>Create a Azure <strong>IoT Hub</strong> in Azure portal as described <a href="https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-create-through-portal">here</a>.</li>
<li><a href="tutorials/../howto-guides/002_installation.html">Install <code>thin-edge.io</code> on your device</a>.</li>
</ul>
<p>You can now use <a href="tutorials/../references/tedge.html"><code>tedge</code> command</a> to:</p>
<ul>
<li><a href="tutorials/connect-azure.html#create-the-certificate">create a certificate for your device</a>,</li>
<li><a href="tutorials/connect-azure.html#register-the-device-on-Azure">register the device on Azure IoT Hub</a>,</li>
<li><a href="tutorials/connect-azure.html#configure-the-device">configure the device</a>,</li>
<li><a href="tutorials/connect-azure.html#connect-the-device">connect the device</a>, and</li>
<li><a href="tutorials/connect-azure.html#sending-your-first-telemetry-data">send your first telemetry data</a>.</li>
</ul>
<h2 id="create-the-certificate-1"><a class="header" href="#create-the-certificate-1">Create the certificate</a></h2>
<p>The <code>tedge cert create</code> command creates a self-signed certificate which can be used for testing purpose.</p>
<p>A single argument is required: an identifier for the device.
This identifier will be used to uniquely identify your devices among others in your cloud tenant.
This identifier will be also used as the Common Name (CN) of the certificate.
Indeed, this certificate aims to authenticate that this device is the device with that identity.</p>
<pre><code class="language-shell">sudo tedge cert create --device-id my-device
</code></pre>
<pre><code>Certificate was successfully created
</code></pre>
<h2 id="show-certificate-details"><a class="header" href="#show-certificate-details">Show certificate details</a></h2>
<p>You can then check the content of that certificate.</p>
<pre><code class="language-shell">sudo tedge cert show
</code></pre>
<pre><code>Device certificate: /etc/tedge/device-certs/tedge-certificate.pem
Subject: CN=my-device, O=Thin Edge, OU=Test Device
Issuer: CN=my-device, O=Thin Edge, OU=Test Device
Valid from: Tue, 09 Mar 2021 14:10:30 +0000
Valid up to: Thu, 10 Mar 2022 14:10:30 +0000
Thumbprint: 860218AD0A996004449521E2713C28F67B5EA580
</code></pre>
<p>You may notice that the issuer of this certificate is the device itself.
This is a self-signed certificate.
The Thumbprint is the Sha1sum of the certificate. This is required for registering the
device using the self-signed certificate on Azure IoT Hub.
To use a certificate signed by your Certificate Authority,
see the reference guide of <a href="tutorials/../references/tedge-cert.html"><code>tedge cert</code></a>.</p>
<h2 id="register-the-device-on-azure-iot-hub"><a class="header" href="#register-the-device-on-azure-iot-hub">Register the device on Azure IoT Hub</a></h2>
<p>For a device to be trusted by Azure, one needs to add the self-signed certificate thumbprint to the Azure IoT Hub Portal.
In the Azure IoT Hub Portal, navigate to &quot;Explores&quot;-&gt;&quot;IoT Devices&quot; click on &quot;+ New&quot;, this will open a new blade &quot;Create a device&quot;.</p>
<p>Here provide the configuration parameters that are required to create the device as described below.</p>
<ul>
<li>Device ID: Should be the same as the Subject of the certificate.</li>
<li>Authentication type: Select <strong>X.509 Self-Signed</strong> option.
<ul>
<li>Provide the Primary Thumbprint that was displayed in <a href="tutorials/connect-azure.html#show-certificate-details"><code>tedge cert show</code></a>.</li>
<li>Use the same for the Secondary Thumbprint as well (Since we are using a single certificate).</li>
</ul>
</li>
<li>Set &quot;Connect this device to an IoT Hub&quot; to <strong>Enable</strong>.</li>
<li>Then save the configuration.
Upon successfully saved the configuration a new device has been created on the IoT Hub.
The new device can be seen on the IoT Hub portal by navigating to &quot;Explores&quot;-&gt;&quot;IoT Devices&quot;.</li>
</ul>
<p>More info about registering a device can be found <a href="https://docs.microsoft.com/en-us/azure/iot-edge/how-to-authenticate-downstream-device?view=iotedge-2018-06">here</a></p>
<h2 id="configure-the-device-1"><a class="header" href="#configure-the-device-1">Configure the device</a></h2>
<p>To connect the device to the Azure IoT Hub, one needs to set the URL/Hostname of the IoT Hub and the root certificate of the IoT Hub as below.</p>
<p>Set the URL/Hostname of your Azure IoT Hub.</p>
<pre><code class="language-shell">sudo tedge config set az.url your-iot-hub-name.azure-devices.net
</code></pre>
<p>The URL/Hostname can be found in the Azure web portal, clicking on the overview section of your IoT Hub.</p>
<p>Set the path to the root certificate if necessary. The default is <code>/etc/ssl/certs</code>.</p>
<pre><code class="language-shell">sudo tedge config set az.root.cert.path /etc/ssl/certs/Baltimore_CyberTrust_Root.pem
</code></pre>
<p>This will set the root certificate path of the Azure IoT Hub.
In most of the Linux flavors, the certificate will be present in /etc/ssl/certs. If not found download it from <a href="https://www.digicert.com/kb/digicert-root-certificates.htm">here</a>.</p>
<h2 id="connect-the-device-1"><a class="header" href="#connect-the-device-1">Connect the device</a></h2>
<p>Now, you are ready to get your device connected to Azure IoT Hub with <code>tedge connect az</code>.
This command configures the MQTT broker:</p>
<ul>
<li>to establish a permanent and secure connection to the Azure cloud,</li>
<li>to forward local messages to the cloud and vice versa.</li>
</ul>
<p>Also, if you have installed <code>tedge-mapper</code>, this command starts and enables the tedge-mapper-az systemd service.
At last, it sends packets to Azure IoT Hub to check the connection.</p>
<pre><code class="language-shell">sudo tedge connect az
</code></pre>
<pre><code>Checking if systemd is available.

Checking if configuration for requested bridge already exists.

Validating the bridge certificates.

Saving configuration for requested bridge.

Restarting mosquitto service.

Awaiting mosquitto to start. This may take up to 5 seconds.

Enabling mosquitto service on reboots.

Successfully created bridge connection!

Sending packets to check connection. This may take up to 2 seconds.

Connection check is successful.

Checking if tedge-mapper is installed.

Starting tedge-mapper-az service.

Persisting tedge-mapper-az on reboot.

tedge-mapper-az service successfully started and enabled!

</code></pre>
<h2 id="sending-your-first-telemetry-data-1"><a class="header" href="#sending-your-first-telemetry-data-1">Sending your first telemetry data</a></h2>
<p>Sending data to Azure is done using MQTT over topics prefixed with <code>az</code>.
Any messages sent on the topic will be forwarded to Azure.
Here, we use <code>tedge mqtt pub az/messages/events/</code> a message to be understood as a temperature of 20 Degree.</p>
<pre><code class="language-shell">tedge mqtt pub az/messages/events/ '{&quot;temperature&quot;: 20}'
</code></pre>
<p>To view the messages that were sent from the device to the cloud, follow this <a href="https://docs.microsoft.com/en-us/azure/iot-hub/quickstart-send-telemetry-cli#create-and-monitor-a-device">document</a>.</p>
<p>More info about sending telemetry to Azure can be found <a href="https://docs.microsoft.com/en-us/azure/iot-hub/quickstart-send-telemetry-dotnet">here</a></p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>You can now:</p>
<ul>
<li>learn how to <a href="tutorials/send-thin-edge-data.html">send various kind of telemetry data</a>
using the cloud-agnostic <a href="tutorials/../architecture/thin-edge-json.html">Thin-Edge-Json data format</a>,</li>
<li>or have a detailed view of the <a href="tutorials/../references/bridged-topics.html#azure-mqtt-topics">topics mapped to and from Azure</a>
if you prefer to use directly Azure specific formats and protocols.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connect-your-device-to-aws-iot"><a class="header" href="#connect-your-device-to-aws-iot">Connect your device to AWS IoT</a></h1>
<p>The very first step to enable <strong>thin-edge.io</strong> is to connect your device to the cloud.</p>
<ul>
<li>This is a 10 minutes operation to be done only once.</li>
<li>It establishes a permanent connection from your device to the cloud end-point.</li>
<li>This connection is secure (encrypted over TLS), and the two peers are identified by x509 certificates.</li>
<li>Sending data to the cloud will then be as simple as sending data locally.</li>
</ul>
<p>The focus is here on connecting the device to AWS IoT.
See this <a href="tutorials/connect-c8y.html">tutorial</a>, if you want to connect Cumulocity IoT instead.
See this <a href="tutorials/connect-azure.html">tutorial</a>, if you want to connect Azure IoT instead.</p>
<p>Before you try to connect your device to AWS IoT, you need:</p>
<ul>
<li><a href="tutorials/../howto-guides/002_installation.html">Install <code>thin-edge.io</code> on your device</a>.</li>
</ul>
<p>You can now use <a href="tutorials/../references/tedge.html"><code>tedge</code> command</a> to:</p>
<ul>
<li><a href="tutorials/connect-aws.html#create-the-certificate">create a certificate for your device</a>,</li>
<li><a href="tutorials/connect-aws.html#register-the-device-on-AWS">register the device on AWS IoT Hub</a>,</li>
<li><a href="tutorials/connect-aws.html#configure-the-device">configure the device</a>,</li>
<li><a href="tutorials/connect-aws.html#connect-the-device">connect the device</a>, and</li>
<li><a href="tutorials/connect-aws.html#sending-your-first-telemetry-data">send your first telemetry data</a>.</li>
</ul>
<h2 id="create-the-certificate-2"><a class="header" href="#create-the-certificate-2">Create the certificate</a></h2>
<p>The <code>tedge cert create</code> command creates a self-signed certificate which can be used for testing purpose.</p>
<p>A single argument is required: an identifier for the device.
This identifier will be used to uniquely identify your devices among others in your cloud tenant.
This identifier will be also used as the Common Name (CN) of the certificate.
Indeed, this certificate aims to authenticate that this device is the device with that identity.</p>
<pre><code class="language-shell">sudo tedge cert create --device-id my-device
</code></pre>
<h2 id="show-certificate-details-1"><a class="header" href="#show-certificate-details-1">Show certificate details</a></h2>
<p>You can then check the content of that certificate.</p>
<pre><code class="language-shell">$ sudo tedge cert show
Device certificate: /etc/tedge/device-certs/tedge-certificate.pem
Subject: CN=my-device, O=Thin Edge, OU=Test Device
Issuer: CN=my-device, O=Thin Edge, OU=Test Device
Valid from: Tue, 09 Mar 2021 14:10:30 +0000
Valid up to: Thu, 10 Mar 2022 14:10:30 +0000
Thumbprint: 860218AD0A996004449521E2713C28F67B5EA580
</code></pre>
<p>You may notice that the issuer of this certificate is the device itself.
This is a self-signed certificate.
To use a certificate signed by your Certificate Authority,
see the reference guide of <a href="tutorials/../references/tedge-cert.html"><code>tedge cert</code></a>.</p>
<h2 id="register-the-device-on-aws-iot-hub"><a class="header" href="#register-the-device-on-aws-iot-hub">Register the device on AWS IoT Hub</a></h2>
<p>For a device to be trusted by AWS, one needs a device certificate and the <code>tedge cert create</code> command is the simplest way to get one.
Also a policy needs to be attached to the device certificate in AWS IoT Core. AWS IoT Core policies determine what an
authenticated identity can do (here the authenticated identity is the device being connected). More info on AWS IoT Core
policies can be found <a href="https://docs.aws.amazon.com/iot/latest/developerguide/iot-policies.html">here</a>.</p>
<p>To create a new policy, head over to the AWS IoT Core and navigate to <em><strong>Security -&gt; Policies -&gt; Create policy -&gt; Policy properties -&gt; Policy name -&gt; Enter the name of your policy (e.g.tedge)</strong></em></p>
<p>On the Policy statements tab click on <em><strong>JSON</strong></em> and enter the policy in the <em><strong>Policy document</strong></em> (an example policy can be found <a href="tutorials/./aws-example-policy.json">here</a>) then click <em><strong>Create</strong></em></p>
<p>In the AWS IoT Core, navigate to <em><strong>Manage -&gt; All devices -&gt; Things -&gt; Create things -&gt; Create Single thing -&gt; Next</strong></em>. Enter the Thing name which can be obtained from the device with: <code>tedge config get device.id</code></p>
<p>In the Device Shadow section which allows connected devices to sync states with AWS choose <em><strong>Unnamed shadow (classic)</strong></em> and click <em><strong>Next</strong></em> and <em><strong>Configure device certificate - optional</strong></em> page opens.</p>
<p>At <em><strong>Device certificate</strong></em> choose <em><strong>Use my certificate -&gt; CA is not registered with AWS IoT</strong></em> then <em><strong>Choose file</strong></em> and select your tedge-certificate.pem file, click on <em><strong>Open -&gt; Next</strong></em>.</p>
<p>The last step needed is to attach previously created policy to your certificate, <em><strong>Attach policies to certificate -optional</strong></em> -&gt; Select your created policy <em><strong>-&gt; Create thing</strong></em>.</p>
<h2 id="configure-the-device-2"><a class="header" href="#configure-the-device-2">Configure the device</a></h2>
<p>To connect the device to the AWS IoT Hub, one needs to set the URL of the IoT Hub and the root certificate of the IoT
Hub as below.</p>
<p>Set the URL of your AWS IoT Hub.</p>
<pre><code class="language-shell">sudo tedge config set aws.url [your-aws-url.com]
</code></pre>
<p>The URL is unique to the AWS account and region that is used, and can be found in the AWS IoT Core by navigating to
&quot;Settings&quot;. It will be listed under &quot;Device data endpoint&quot; (e.g. <code>a2e8ahbpo21syc.iot.eu-central-1.amazonaws.com</code>)</p>
<p>Set the path to the root certificate if necessary. The default is <code>/etc/ssl/certs</code>.</p>
<pre><code class="language-shell">sudo tedge config set aws.root.cert.path /etc/ssl/certs/AmazonRootCA1.pem
</code></pre>
<p>This will set the root certificate path of the AWS IoT Hub. In most of the Linux flavors, the certificate will be
present in /etc/ssl/certs. If not found download it from
<a href="https://docs.aws.amazon.com/iot/latest/developerguide/server-authentication.html#server-authentication-certs">here</a>.</p>
<h2 id="connect-the-device-2"><a class="header" href="#connect-the-device-2">Connect the device</a></h2>
<p>Now, you are ready to get your device connected to AWS IoT Hub with <code>tedge connect aws</code>.
This command configures the MQTT broker:</p>
<ul>
<li>to establish a permanent and secure connection to the AWS cloud,</li>
<li>to forward local messages to the cloud and vice versa.</li>
</ul>
<p>Also, if you have installed <code>tedge_mapper</code>, this command starts and enables the tedge-mapper-aws systemd service.
At last, it sends packets to AWS IoT Hub to check the connection.</p>
<pre><code class="language-shell">$ sudo tedge connect aws
Checking if systemd is available.

Checking if configuration for requested bridge already exists.

Validating the bridge certificates.

Saving configuration for requested bridge.

Restarting mosquitto service.

Awaiting mosquitto to start. This may take up to 5 seconds.

Enabling mosquitto service on reboots.

Successfully created bridge connection!

Sending packets to check connection. This may take up to 2 seconds.

Received expected response on topic aws/connection-success, connection check is successful.
Connection check is successful.

Checking if tedge-mapper is installed.

Starting tedge-mapper-aws service.

Persisting tedge-mapper-aws on reboot.

tedge-mapper-aws service successfully started and enabled!

</code></pre>
<h2 id="sending-your-first-telemetry-data-2"><a class="header" href="#sending-your-first-telemetry-data-2">Sending your first telemetry data</a></h2>
<p>Using the AWS mapper, you can publish measurement telemetry data to AWS by publishing on the <code>tedge/measurements</code> topic:</p>
<pre><code class="language-shell">tedge mqtt pub tedge/measurements '{&quot;temperature&quot;: 21.3}'
</code></pre>
<p>Alternatively, post your own custom messages on <code>aws/td/#</code> topic:</p>
<pre><code class="language-shell">tedge mqtt pub aws/td '{&quot;text&quot;: &quot;My message&quot;}'
</code></pre>
<p>To view the messages that were sent from the device to the cloud, follow this
<a href="https://docs.aws.amazon.com/iot/latest/developerguide/view-mqtt-messages.html">document</a>.</p>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>You can now:</p>
<ul>
<li>learn how to <a href="tutorials/send-thin-edge-data.html">send various kind of telemetry data</a>
using the cloud-agnostic <a href="tutorials/../architecture/thin-edge-json.html">Thin-Edge-Json data format</a>,</li>
<li>or have a detailed view of the <a href="tutorials/../references/bridged-topics.html#aws-mqtt-topics">topics mapped to and from AWS</a>
if you prefer to use directly AWS specific formats and protocols.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-thin-edge-json-data"><a class="header" href="#send-thin-edge-json-data">Send Thin Edge JSON data</a></h1>
<p>Once your Thin Edge device is configured and connected to an IoT cloud provider, you can start sending measurements.
Refer to <a href="tutorials/../tutorials/connect-c8y.html">Connecting to Cumulocity</a> or tutorials for other cloud providers 
to learn how to connect your Thin Edge device to an IoT cloud provider. </p>
<p>In this tutorial, we'll see how different kinds of measurements are represented in Thin Edge JSON format and 
how they can be sent to the connected cloud provider.
For a more detailed specification of this data format, refer to <a href="tutorials/../architecture/thin-edge-json.html">Thin Edge JSON Specification</a>.</p>
<h2 id="sending-measurements-1"><a class="header" href="#sending-measurements-1">Sending measurements</a></h2>
<p>A simple single-valued measurement like a temperature measurement, can be represented in Thin Edge JSON as follows:</p>
<pre><code class="language-json">{ &quot;temperature&quot;: 25 }
</code></pre>
<p>with the key-value pair representing the measurement type and the numeric value of the measurement.</p>
<p>This measurement can be sent from the Thin Edge device to the cloud by publishing this message to the <code>tedge/measurements</code> MQTT topic.
Processes running on the Thin Edge device can publish messages to the local MQTT broker using any MQTT client or library.
In this tutorial, we'll be using the <code>tedge mqtt pub</code> command line utility for demonstration purposes.</p>
<p>The temperature measurement described above can be sent using the <code>tedge mqtt pub</code> command as follows:</p>
<pre><code class="language-shell">tedge mqtt pub tedge/measurements '{ &quot;temperature&quot;: 25 }'
</code></pre>
<p>The first argument to the <code>tedge mqtt pub</code> command is the topic to which the measurements must be published to.
The second argument is the Thin Edge JSON representation of the measurement itself.</p>
<p>When connected to a cloud provider, a message mapper component for that cloud provider would be running as a daemon, 
listening to any measurements published to <code>tedge/measurements</code>.
The mapper, on receipt of these Thin Edge JSON measurements, will map those measurements to their equivalent
cloud provider native representation and send it to that cloud.</p>
<p>For example, when the device is connected to Cumulocity, the Cumulocity mapper component will be performing these actions.
To check if these measurements have reached Cumulocity, login to your Cumulocity dashboard and navigate to
<em>Device Management =&gt; Devices =&gt; All devices =&gt; <your device id> =&gt; Measurements</em> 
and see if your temperature measurement is appearing in the dashboard.</p>
<h2 id="complex-measurements"><a class="header" href="#complex-measurements">Complex measurements</a></h2>
<p>You can represent measurements that are far more complex than the single-valued ones described above using the Thin Edge JSON format.</p>
<p>A multi-valued measurement like <code>three_phase_current</code> that consists of <code>L1</code>, <code>L2</code> and <code>L3</code> values,
representing the current on each phase can be represented as follows:</p>
<pre><code class="language-json">{
  &quot;three_phase_current&quot;: {
    &quot;L1&quot;: 9.5,
    &quot;L2&quot;: 10.3,
    &quot;L3&quot;: 8.8
  }
}
</code></pre>
<p>Here is another complex message consisting of single-valued measurements: <code>temperature</code> and <code>pressure</code> 
along with a multi-valued <code>coordinate</code> measurement, all sharing a single timestamp captured as <code>time</code>.</p>
<pre><code class="language-json">{
  &quot;time&quot;: &quot;2020-10-15T05:30:47+00:00&quot;,
  &quot;temperature&quot;: 25,
  &quot;current&quot;: {
    &quot;L1&quot;: 9.5,
    &quot;L2&quot;: 10.3,
    &quot;L3&quot;: 8.8
  },
  &quot;pressure&quot;: 98
}
</code></pre>
<p>The <code>time</code> field is not a regular measurement like <code>temperature</code> or <code>pressure</code> but a special reserved field.
Refer to <a href="tutorials/../architecture/thin-edge-json.html">Thin Edge JSON Specification</a> for more details on the kinds of telemetry 
data that can be represented in Thin Edge JSON format and the reserved fields like <code>time</code> used in the above example.</p>
<h2 id="sending-measurements-to-child-devices"><a class="header" href="#sending-measurements-to-child-devices">Sending measurements to child devices</a></h2>
<blockquote>
<p>Note: Currently this feature supports Cumulocity IoT only.</p>
</blockquote>
<p>If valid Thin Edge JSON measurements are published to the <code>tedge/measurements/&lt;child-id&gt;</code> topic,
the measurements are recorded under a child device of your thin-edge.io device.</p>
<p>Given your desired child device ID is <code>child1</code>, publish a Thin Edge JSON message to the <code>tedge/measurements/child1</code> topic:</p>
<pre><code class="language-shell">tedge mqtt pub tedge/measurements/child1 '{ &quot;temperature&quot;: 25 }'
</code></pre>
<p>Then, you will see a child device with the name <code>child1</code> is created in your Cumulocity IoT tenant,
and the measurement is recorded in <code>Measurements</code> of the <code>child1</code> device.</p>
<h2 id="error-detection"><a class="header" href="#error-detection">Error detection</a></h2>
<p>If the data published to the <code>tedge/measurements</code> topic are not valid Thin Edge JSON measurements, those won't be
sent to the cloud but instead you'll get a feedback on the <code>tedge/errors</code> topic, if you subscribe to it.
The error messages published to this topic will be highly verbose and may change in the future.
So, use it only for debugging purposes during the development phase and it should <strong>not</strong> be used for any automation.</p>
<p>You can use the <code>tedge mqtt sub</code> command to subscribe to the error topic as follows:</p>
<pre><code class="language-shell">tedge mqtt sub tedge/errors
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thin-edge-alarm"><a class="header" href="#thin-edge-alarm">Thin Edge Alarm</a></h1>
<p>Alarms on thin-edge.io can be used to create alerts, represent state changes etc.
For example, an alarm can be raised when a certain measurement value breaches some threshold (like high temperature) or when an unexpected event occurs in the system (like a sensor failure).</p>
<p>A typical alarm cycle starts by the raising of an alarm by some monitoring process which alerts a system/human of an event needing some action.
Once some action is taken, the alarm is cleared explicitly by that system/human.</p>
<p>Every alarm is uniquely identified by its type and severity.
That is, for a given alarm type, alarms of varying severities are treated as independent alarms and hence, must be acted upon separately.
For an alarm of a given type and severity, only the last known state is considered relevant.
Thin-edge.io doesn't keep a history of all its state changes but only reacts to the last one it receives.</p>
<h2 id="raising-an-alarm"><a class="header" href="#raising-an-alarm">Raising an alarm</a></h2>
<p>An alarm can be raised on thin-edge.io by sending an MQTT message in Thin Edge JSON format to certain MQTT topics.</p>
<p>The scheme of the topic to publish the alarm data is as follows:</p>
<p><code>tedge/alarms/&lt;severity&gt;/&lt;alarm-type&gt;</code></p>
<p>The payload format must be as follows:</p>
<pre><code class="language-json">{
    &quot;text&quot;: &quot;&lt;alarm text&gt;&quot;,
    &quot;time&quot;: &quot;&lt;Timestamp in ISO-8601 format&gt;&quot;
}
</code></pre>
<blockquote>
<p>Note: These messages must be sent with MQTT retained flag enabled and with QOS &gt; 1 to ensure guaranteed processing by thin-edge.io.
Enabling the retained flag ensures that the alarm stays persisted with the MQTT broker until its state changes again.
These retained messages will make sure that the thin-edge.io processes or any other third-party processes subscribed to these alarms will get those, even if they were down at the moment the alarm was raised.
If multiple messages are sent to the same alarm topic, the last alarm is considered to have overwritten the previous one.</p>
</blockquote>
<p>Here is a sample alarm raised for <code>temperature_high</code> alarm type with <code>critical</code> severity:</p>
<p>Topic: 
<code>tedge/alarms/critical/temperature_high</code></p>
<p>Payload:</p>
<pre><code class="language-json">{
    &quot;text&quot;: &quot;Temperature is very high&quot;,
    &quot;time&quot;: &quot;2021-01-01T05:30:45+00:00&quot;
}
</code></pre>
<blockquote>
<p>Note: Both the <code>text</code> field and the <code>time</code> field are optional.
When a <code>text</code> is not provided, it is assumed to be empty.
When <code>time</code> is not provided, thin-edge.io will use the current system time as the <code>time</code> of the alarm.
When you want to skip both fields, use an empty json fragment <code>{}</code> as the payload to indicate the same.
An empty message can't be used for the same, as empty messages are used to clear alarms, which is discussed in the next section.</p>
</blockquote>
<p>The <code>&lt;severity&gt;</code> value in the MQTT topic can only be one of the following values:</p>
<ol>
<li>critical</li>
<li>major</li>
<li>minor</li>
<li>warning</li>
</ol>
<p>There are no such restrictions on the <code>&lt;alarm-type&gt;</code> value.</p>
<p>Thin-edge.io doesn't keep any history of all alarms raised on an alarm topic.</p>
<h2 id="clearing-alarms"><a class="header" href="#clearing-alarms">Clearing alarms</a></h2>
<p>An already raised alarm can be cleared by sending an empty message with retained flag enabled to the same alarm topic on which the original alarm was raised.</p>
<p>For example <code>temperature_alarm</code> will be cleared by publishing an empty payload message as below:</p>
<pre><code>tedge mqtt pub tedge/alarms/critical/temperature_alarm &quot;&quot; -q 2 -r

</code></pre>
<blockquote>
<p>Note: Using the retained (-r) flag is a must while clearing the alarm as well, without which the alarm won't be cleared properly.</p>
</blockquote>
<p>If alarms of different severities exist for a given alarm type, they must all be cleared separately as they're all treated as independent alarms.</p>
<h3 id="raising-alarms-from-child-devices"><a class="header" href="#raising-alarms-from-child-devices">Raising alarms from child devices</a></h3>
<p>Alarms for child devices can be raised by publishing the alarm payload to <code>tedge/alarms/&lt;severity&gt;/&lt;alarm-type&gt;/&lt;child-device-id&gt;</code> topic,
where the <code>child-device-id</code> is the unique device id of the child device.
The alarm payload structure is the same, as described in the previous section.</p>
<h3 id="raising-an-alarm-with-custom-fragment"><a class="header" href="#raising-an-alarm-with-custom-fragment">Raising an alarm with custom fragment</a></h3>
<p>Thin-edge supports the creation of alarms using custom (user-defined) fragments.
Custom fragments are supported for both the main and child devices.
The custom fragments can be a simple json value or a complex json value.</p>
<p>For example, an alarm with simple custom fragment field named <code>details</code>:</p>
<p>Payload:</p>
<pre><code class="language-json">{
    &quot;text&quot;: &quot;Temperature is very high&quot;,
    &quot;time&quot;: &quot;2021-01-01T05:30:45+00:00&quot;,
    &quot;details&quot;: &quot;A custom alarm info&quot;
}
</code></pre>
<p>For example, an alarm with complex custom fragments</p>
<p>Payload:</p>
<pre><code class="language-json">{
    &quot;text&quot;: &quot;Temperature is very high&quot;,
    &quot;time&quot;: &quot;2021-01-01T05:30:45+00:00&quot;,
    &quot;someOtherCustomFragment&quot;: {
        &quot;nested&quot;: {
            &quot;value&quot;: &quot;extra info&quot;
        }
    }
}
</code></pre>
<blockquote>
<p>Note: Other than <code>text</code> and <code>time</code> fields, all the other fields are considered as custom fragments.</p>
</blockquote>
<h3 id="raising-an-alarm-with-empty-json-payload"><a class="header" href="#raising-an-alarm-with-empty-json-payload">Raising an alarm with empty json payload</a></h3>
<p>Alarms can also be raised with an <code>empty json object</code> as payload as follows:</p>
<p>Payload:</p>
<pre><code class="language-json">{}
</code></pre>
<blockquote>
<p>Note: The <code>default</code> value for the <code>time</code> fragment will be the timestamp in utc time that is added by the <code>tedge-mapper-c8y</code>
while alarm message being translated to cumulocity format.
The default value for the <code>text</code> fragment will be derived from the <code>alarm-type</code> of the topic.</p>
</blockquote>
<h2 id="cloud-data-mapping"><a class="header" href="#cloud-data-mapping">Cloud data mapping</a></h2>
<p>If the device is connected to some supported IoT cloud platform, any alarms raised locally on thin-edge.io will be forwarded to the connected cloud platform as well.
The mapping of thin-edge alarms data to its respective cloud-native representation will be done by the corresponding cloud mapper process.
For example, if the device is connected to Cumulocity IoT cloud platform, the Cumulocity cloud mapper process will translate the thin-edge alarm JSON data to its equivalent Cumulocity SmartREST representation.</p>
<blockquote>
<p>Warning: As of now, alarm data mapping is supported only on Cumulocity IoT cloud platform.</p>
</blockquote>
<h3 id="cumulocity-cloud-data-mapping"><a class="header" href="#cumulocity-cloud-data-mapping">Cumulocity cloud data mapping</a></h3>
<p>The Cumulocity mapper will convert Thin Edge JSON alarm into Cumulocity SmartREST messages and send it to Cumulocity via MQTT.</p>
<p>For example the <code>temperature_high</code> alarm with <code>critical</code> severity described in the earlier sections will be converted to the following Cumulocity SmartREST message:</p>
<pre><code class="language-csv">301,temperature_high,&quot;Temperature is very high&quot;,2021-01-01T05:30:45+00:00
</code></pre>
<p>... and is published to <code>c8y/s/us</code> topic which will get forwarded to the connected Cumulocity cloud instance.</p>
<p>If the alarm is raised from a child device, the payload is published to <code>c8y/s/us/&lt;child-device-id&gt;</code> topic instead.</p>
<p>If an alarm contains a <code>custom fragment</code> then, the alarm message will be converted to <code>cumulocity json</code>
format and then will be published on to <code>c8y/alarm/alarms/create</code> topic.</p>
<p>An example of the translated custom message for <code>thin-edge</code> device will be as below</p>
<pre><code class="language-json">{
    &quot;severity&quot;:&quot;MAJOR&quot;,
    &quot;type&quot;:&quot;temperature_high&quot;,
    &quot;time&quot;:&quot;2023-01-25T18:41:14.776170774Z&quot;,
    &quot;text&quot;:&quot;Temperature High&quot;,
    &quot;someOtherCustomFragment&quot;:
        {
            &quot;nested&quot;:
            {
                &quot;value&quot;: &quot;extra info&quot;
            }
        }
}
</code></pre>
<p>An example of the translated <code>cumulocity</code> alarm message for a <code>child</code> device with a <code>custom</code> fragment will be as below</p>
<pre><code class="language-json">{
    &quot;severity&quot;:&quot;MAJOR&quot;,
    &quot;type&quot;:&quot;pressure_alarm&quot;,
    &quot;time&quot;:&quot;2023-01-25T18:41:14.776170774Z&quot;,
    &quot;text&quot;:&quot;Pressure alarm&quot;,
    &quot;someOtherCustomFragment&quot;:
        {
            &quot;nested&quot;:
            {
                &quot;value&quot;: &quot;extra info&quot;
            }
        }
    &quot;externalSource&quot;:
        {
            &quot;externalId&quot;:&quot;child_device_id&quot;,
            &quot;type&quot;:&quot;c8y_Serial&quot;
        }
}

</code></pre>
<p>Find more information about SmartREST representations for alarms in Cumulocity <a href="https://cumulocity.com/guides/10.11.0/reference/smartrest-two/#alarm-templates">here</a></p>
<p>Find more information about alarms data model in Cumulocity <a href="https://cumulocity.com/guides/concepts/domain-model/#events">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thin-edge-event"><a class="header" href="#thin-edge-event">Thin Edge Event</a></h1>
<p>Events on thin-edge.io can be used to trigger signals when some event happens in the system.
For example, a person entering a room or someone logging into a machine/website can all be represented as events.
Events are stateless and hence are processed as and when they occur.
They don't represent state but can be used to represent state changes.
An event can't be updated/cleared once its triggered, unlike alarms that are cleared explicitly after processing.</p>
<p>Every event is uniquely identified by its type.
If multiple events are raised for a given type, thin-edge.io will process them all separately in the order in which they were raised.</p>
<h2 id="sending-an-event"><a class="header" href="#sending-an-event">Sending an event</a></h2>
<p>An event can be triggered on thin-edge.io by sending an MQTT message in Thin Edge JSON format to certain MQTT topics.</p>
<p>The scheme of the topic to publish the event data is as follows:</p>
<p><code>tedge/events/&lt;event-type&gt;</code></p>
<p>The payload format must be as follows:</p>
<pre><code class="language-json">{
    &quot;text&quot;: &quot;&lt;event text&gt;&quot;,
    &quot;time&quot;: &quot;&lt;Timestamp in ISO-8601 format&gt;&quot;
}
</code></pre>
<p>Here is a sample event triggered for a <code>login_event</code> event type:</p>
<p>Topic: 
<code>tedge/events/login_event</code></p>
<p>Payload:</p>
<pre><code class="language-json">{
    &quot;text&quot;: &quot;A user just logged in&quot;,
    &quot;time&quot;: &quot;2021-01-01T05:30:45+00:00&quot;
}
</code></pre>
<blockquote>
<p>Note: Both the <code>text</code> field and the <code>time</code> field are optional.</p>
</blockquote>
<p>When the <code>message</code> field is not provided, the <code>event-type</code> from the MQTT topic will be used as the message as well if the connected cloud mandates one.
When the <code>time</code> field is not provided, thin-edge.io will use the current system time as the <code>time</code> of the event.
When you want to skip both fields, use an empty payload to indicate the same.
There are no such restrictions on the <code>&lt;event-type&gt;</code> value.</p>
<h3 id="sending-events-from-child-devices"><a class="header" href="#sending-events-from-child-devices">Sending events from child devices</a></h3>
<p>Events for child devices can be sent by publishing the event payload to <code>tedge/events/&lt;event-type&gt;/&lt;child-device-id&gt;</code> topic,
where the <code>child-device-id</code> is the unique device id of the child device.
The event payload structure is the same, as described in the previous section.</p>
<h2 id="cloud-data-mapping-1"><a class="header" href="#cloud-data-mapping-1">Cloud data mapping</a></h2>
<p>If the device is connected to some supported IoT cloud platform, an event that is triggered locally on thin-edge.io will be forwarded to the connected cloud platform as well.
The mapping of thin-edge events data to its respective cloud-native representation will be done by the corresponding cloud mapper process.
For example, if the device is connected to Cumulocity IoT cloud platform, the Cumulocity cloud mapper process will translate the thin-edge event JSON data to its equivalent Cumulocity SmartREST representation.</p>
<blockquote>
<p>Warning: As of now, event data mapping is supported only on Cumulocity IoT cloud platform.</p>
</blockquote>
<h3 id="cumulocity-cloud-data-mapping-1"><a class="header" href="#cumulocity-cloud-data-mapping-1">Cumulocity cloud data mapping</a></h3>
<p>The Cumulocity mapper will convert Thin Edge JSON events into its Cumulocity SmartREST equivalent if the payload only contains either a <code>text</code> field or <code>time</code> field.</p>
<p>For example the <code>login_event</code> described in the earlier sections will be converted to the following Cumulocity SmartREST message:</p>
<pre><code class="language-csv">400,login_event,&quot;A user just logged in&quot;,2021-01-01T05:30:45+00:00
</code></pre>
<p>... and is published to <code>c8y/s/us</code> topic which will get forwarded to the connected Cumulocity cloud instance.</p>
<p>If the event JSON payload contains fields other than <code>text</code> and <code>time</code>, or when the payload size is more than 16K irrespective of its contents, it will be converted to Cumulocity JSON format.</p>
<p>The Cumulocity JSON mapping of the same event would be as follows:</p>
<pre><code class="language-json">{
    &quot;type&quot;:&quot;login_event&quot;,
    &quot;text&quot;:&quot;A user just logged in&quot;,
    &quot;time&quot;:&quot;2021-01-01T05:30:45+00:00&quot;,
    &quot;externalSource&quot;:{
        &quot;externalId&quot;:&quot;&lt;child-device-id&gt;&quot;,
        &quot;type&quot;:&quot;c8y_Serial&quot;
  }
}
</code></pre>
<blockquote>
<p>Note: Mapped events will be sent to Cumulocity via MQTT if the incoming Thin Edge JSON event payload size is less than 16K bytes. If higher, HTTP will be used.</p>
</blockquote>
<p>Find more information about events data model in Cumulocity <a href="https://cumulocity.com/guides/concepts/domain-model/#events">here</a>.</p>
<h2 id="sending-an-event-for-a-childexternal-device-to-the-cloud"><a class="header" href="#sending-an-event-for-a-childexternal-device-to-the-cloud">Sending an event for a child/external device to the cloud</a></h2>
<p>An event for a child/external device can be triggered on thin-edge.io by sending an MQTT message in Thin Edge JSON format to certain MQTT topics.</p>
<p>The scheme of the topic to publish the event data is as follows:</p>
<p><code>tedge/events/&lt;event-type&gt;/&lt;child-device-id&gt;</code></p>
<p>The payload format must be as follows:</p>
<pre><code class="language-json">{
    &quot;type&quot;:&quot;&lt;event type&gt;&quot;,
    &quot;text&quot;: &quot;&lt;event text&gt;&quot;,
    &quot;time&quot;: &quot;&lt;Timestamp in ISO-8601 format&gt;&quot;
}
</code></pre>
<p>Here is a sample event triggered for a <code>login_event</code> event type for the <code>external_sensor</code> child device:</p>
<p>Command to send the event from a external device as below:</p>
<pre><code class="language-shell">sudo tedge mqtt pub tedge/events/login_event/external_sensor '{
    &quot;type&quot;:&quot;login_event&quot;,
    &quot;text&quot;:&quot;A user just logged in&quot;,
    &quot;time&quot;:&quot;2021-01-01T05:30:45+00:00&quot;
}'
</code></pre>
<p>Payload:</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;login_event&quot;,
    &quot;text&quot;: &quot;A user just logged in&quot;,
    &quot;time&quot;: &quot;2021-01-01T05:30:45+00:00&quot;
}
</code></pre>
<h3 id="mapping-of-events-to-cloud-specific-data-format"><a class="header" href="#mapping-of-events-to-cloud-specific-data-format">Mapping of events to cloud-specific data format</a></h3>
<p>If the child/external device is connected to some supported IoT cloud platform, an event that is triggered locally on thin-edge.io will be forwarded to the connected cloud platform as well.
The mapping of thin-edge events data to its respective cloud-native representation will be done by the corresponding cloud mapper process.</p>
<h4 id="cumulocity-cloud-data-mapping-2"><a class="header" href="#cumulocity-cloud-data-mapping-2">Cumulocity cloud data mapping</a></h4>
<p>The Cumulocity mapper will convert Thin Edge JSON events into its Cumulocity JSON equivalent and sends them to the Cumulocity cloud.</p>
<p>The translated payload will be in the below format.</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;login_event&quot;,
    &quot;text&quot;: &quot;A user just logged in&quot;,
    &quot;time&quot;: &quot;2021-01-01T05:30:45+00:00&quot;,
    &quot;externalSource&quot;:{
        &quot;externalId&quot;: &quot;external_sensor&quot;,
        &quot;type&quot;: &quot;c8y_Serial&quot;
  }
}
</code></pre>
<p>Here the <code>externalId</code> will be derived from the <code>child-device-id</code> of the <code>child device event topic</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitor-your-device-with-collectd"><a class="header" href="#monitor-your-device-with-collectd">Monitor your device with collectd</a></h1>
<p>With thin-edge.io device monitoring, you can collect metrics from your device
and forward these device metrics to IoT platforms in the cloud.</p>
<p>Using these metrics, you can monitor the health of devices
and can proactively initiate actions in case the device seems to malfunction.
Additionally, the metrics can be used to help the customer troubleshoot when problems with the device are reported.</p>
<p>Thin-edge.io uses the open source component <a href="https://collectd.org/"><code>collectd</code></a> to collect the metrics from the device.
Thin-edge.io translates the collected metrics from their native format to the <a href="tutorials/../architecture/thin-edge-json.html">thin-edge.io JSON</a> format
and then into the <a href="tutorials/../architecture/mapper.html">cloud-vendor specific format</a>.</p>
<p>Enabling monitoring on your device is a 3-steps process:</p>
<ol>
<li><a href="tutorials/device-monitoring.html#install-collectd">Install <code>collectd</code></a>,</li>
<li><a href="tutorials/device-monitoring.html#configure-collectd">Configure <code>collectd</code></a>,</li>
<li><a href="tutorials/device-monitoring.html#enable-thin-edge-monitoring">Enable thin-edge.io monitoring</a>.</li>
</ol>
<h2 id="install-mosquitto-client-library"><a class="header" href="#install-mosquitto-client-library">Install <code>mosquitto</code> client library</a></h2>
<p>Since thin-edge.io uses the MQTT plugin of <code>collectd</code>, one needs to install the mosquitto client library
(either <code>libmosquitto1</code> or <code>mosquitto-clients</code>).</p>
<pre><code class="language-shell">sudo apt-get install libmosquitto1
</code></pre>
<p>or</p>
<pre><code class="language-shell">sudo apt-get install mosquitto-clients
</code></pre>
<h2 id="install-collectd-1"><a class="header" href="#install-collectd-1">Install <code>collectd</code></a></h2>
<p>Device monitoring is not enabled by default when you install thin edge.
You will have to install and configure <a href="https://collectd.org/"><code>collectd</code></a> first.</p>
<p>To install collectd, follow the <a href="https://collectd.org/download.shtml">collectd installation process</a>
that is specific to your device. On a Debian or Ubuntu linux:</p>
<pre><code class="language-shell">sudo apt-get install collectd-core
</code></pre>
<h2 id="configure-collectd-1"><a class="header" href="#configure-collectd-1">Configure <code>collectd</code></a></h2>
<h3 id="tldr-just-want-it-running"><a class="header" href="#tldr-just-want-it-running">TLDR; Just want it running</a></h3>
<p>Thin-edge.io provides a <a href="https://github.com/thin-edge/thin-edge.io/blob/main/configuration/contrib/collectd/collectd.conf">basic <code>collectd</code> configuration</a>
that can be used to collect cpu, memory and disk metrics.</p>
<p>Simply copy that file to the main collectd configuration file and restart the daemon
(it might be good to keep a copy of the original configuration).</p>
<pre><code class="language-shell">sudo cp /etc/collectd/collectd.conf /etc/collectd/collectd.conf.backup
sudo cp /etc/tedge/contrib/collectd/collectd.conf /etc/collectd/collectd.conf
sudo systemctl restart collectd
</code></pre>
<h3 id="collectdconf"><a class="header" href="#collectdconf"><code>Collectd.conf</code></a></h3>
<p>Unless you opted for the <a href="tutorials/device-monitoring.html#tldr-just-want-it-running">minimal test configuration provided with thin-edge</a>,
you will have to update the
<a href="https://collectd.org/documentation/manpages/collectd.conf.5.shtml"><code>collectd.conf</code> configuration file</a>
(usually located at <code>/etc/collectd/collectd.conf</code>)</p>
<p><strong>Important notes</strong> You can enable or disable the collectd plugins of your choice, but with some notable exceptions:</p>
<ol>
<li><strong>MQTT must be enabled</strong>.
<ul>
<li>Thin-edge.io expects the collectd metrics to be published on the local MQTT bus.
Hence, you must enable the <a href="https://collectd.org/documentation/manpages/collectd.conf.5.shtml#plugin_mqtt">MQTT write plugin of collectd</a>.</li>
<li>The MQTT plugin is available on most distribution of <code>collectd</code>, but this is not the case on MacOS using homebrew.
If you are missing the MQTT plugin, please recompile <code>collectd</code> to include the MQTT plugin.
See <a href="https://github.com/collectd/collectd">https://github.com/collectd/collectd</a> for details.</li>
<li>Here is a config snippet to configure the MQTT write plugin:
<pre><code>   LoadPlugin mqtt

   &lt;Plugin mqtt&gt;
       &lt;Publish &quot;tedge&quot;&gt;
           Host &quot;localhost&quot;
           Port 1883
           ClientId &quot;tedge-collectd&quot;
       &lt;/Publish&gt;
   &lt;/Plugin&gt;
</code></pre>
</li>
</ul>
</li>
<li><strong>RRDTool and CSV might be disabled</strong>
<ul>
<li>The risk with these plugins is to run out of disk space on a small device.</li>
<li>With thin-edge.io the metrics collected by <code>collectd</code> are forwarded to the cloud,
hence it makes sense to <a href="https://github.com/collectd/collectd/issues/2668">disable Local storage</a>.</li>
<li>For that, simply comment out these two plugins:</li>
</ul>
<pre><code>   #LoadPlugin rrdtool
   #LoadPlugin csv
</code></pre>
</li>
<li><strong>Cherry-pick the collected metrics</strong>
<ul>
<li><code>Collectd</code> can collect a lot of detailed metrics,
and it doesn't always make sense to forward all these data to the cloud.</li>
<li>Here is a config snippet that uses the <code>match_regex</code> plugin to select the metrics of interest,
filtering out every metric emitted by the memory plugin other than the used metric&quot;:</li>
</ul>
<pre><code>    PreCacheChain &quot;PreCache&quot;

    LoadPlugin match_regex

    &lt;Chain &quot;PreCache&quot;&gt;
        &lt;Rule &quot;memory_free_only&quot;&gt;
            &lt;Match &quot;regex&quot;&gt;
                Plugin &quot;memory&quot;
            &lt;/Match&gt;
            &lt;Match &quot;regex&quot;&gt;
                TypeInstance &quot;used&quot;
                Invert true
            &lt;/Match&gt;
            Target &quot;stop&quot;
        &lt;/Rule&gt;
    &lt;/Chain&gt;
</code></pre>
</li>
</ol>
<h2 id="enable-thin-edge-monitoring"><a class="header" href="#enable-thin-edge-monitoring">Enable thin-edge monitoring</a></h2>
<p>To enable monitoring on your device, you have to launch the <code>tedge-mapper-collectd</code> daemon process.</p>
<pre><code class="language-shell">sudo systemctl enable tedge-mapper-collectd
sudo systemctl start tedge-mapper-collectd
</code></pre>
<p>This process subscribes to the <code>collectd/#</code> topics to read the monitoring metrics published by collectd
and emits the translated measurements in thin-edge.io JSON format to the <code>tedge/measurements</code> topic.
You can inspect the collected and translated metrics, by subscribing to these topics:</p>
<p>The metrics collected by <code>collectd</code> are emitted to subtopics named after the collectd plugin and the metric name:</p>
<pre><code class="language-shell">tedge mqtt sub 'collectd/#'
</code></pre>
<pre><code>[collectd/raspberrypi/cpu/percent-active] 1623076679.154:0.50125313283208
[collectd/raspberrypi/memory/percent-used] 1623076679.159:1.10760866126707
[collectd/raspberrypi/cpu/percent-active] 1623076680.154:0
[collectd/raspberrypi/df-root/percent_bytes-used] 1623076680.158:71.3109359741211
[collectd/raspberrypi/memory/percent-used] 1623076680.159:1.10760866126707

</code></pre>
<p>The <code>tedge-mapper-collectd</code> translates these collectd measurements into the <a href="tutorials/../architecture/thin-edge-json.html">thin-edge.io JSON</a> format,
<a href="tutorials/../references/bridged-topics.html#collectd-topics">grouping the measurements</a> emitted by each plugin:</p>
<pre><code>tedge mqtt sub 'tedge/measurements'

[tedge/measurements] {&quot;time&quot;:&quot;2021-06-07T15:38:59.154895598+01:00&quot;,&quot;cpu&quot;:{&quot;percent-active&quot;:0.50251256281407},&quot;memory&quot;:{&quot;percent-used&quot;:1.11893578135189}}
[tedge/measurements] {&quot;time&quot;:&quot;2021-06-07T15:39:00.154967388+01:00&quot;,&quot;cpu&quot;:{&quot;percent-active&quot;:0},&quot;df-root&quot;:{&quot;percent_bytes-used&quot;:71.3110656738281},&quot;memory&quot;:{&quot;percent-used&quot;:1.12107875001658}}
</code></pre>
<p>From there, if the device is actually connected to a cloud platform like Cumulocity,
these monitoring metrics will be forwarded to the cloud.</p>
<pre><code>tedge mqtt sub 'c8y/#'
[c8y/measurement/measurements/create] {&quot;type&quot;: &quot;ThinEdgeMeasurement&quot;,&quot;time&quot;:&quot;2021-06-07T15:40:30.155037451+01:00&quot;,&quot;cpu&quot;:{&quot;percent-active&quot;: {&quot;value&quot;: 0.753768844221106}},&quot;memory&quot;:{&quot;percent-used&quot;: {&quot;value&quot;: 1.16587699972141}},&quot;df-root&quot;:{&quot;percent_bytes-used&quot;: {&quot;value&quot;: 71.3117904663086}}}
[c8y/measurement/measurements/create] {&quot;type&quot;: &quot;ThinEdgeMeasurement&quot;,&quot;time&quot;:&quot;2021-06-07T15:40:31.154898577+01:00&quot;,&quot;cpu&quot;:{&quot;percent-active&quot;: {&quot;value&quot;: 0.5}},&quot;memory&quot;:{&quot;percent-used&quot;: {&quot;value&quot;: 1.16608109197519}}}
</code></pre>
<p>If your device is not connected yet see:</p>
<ul>
<li><a href="tutorials/./connect-c8y.html">Connect my device to Cumulocity IoT</a></li>
<li><a href="tutorials/./connect-azure.html">Connect my device to Azure IoT</a></li>
<li><a href="tutorials/./connect-aws.html">Connect my device to AWS IoT</a></li>
</ul>
<h2 id="trouble-shooting"><a class="header" href="#trouble-shooting">Trouble shooting</a></h2>
<p>See here for <a href="tutorials/../howto-guides/009_trouble_shooting_monitoring.html">how to trouble shoot device monitoring?</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manage-the-software-on-your-devices-from-cumulocity-cloud"><a class="header" href="#manage-the-software-on-your-devices-from-cumulocity-cloud">Manage the software on your devices from Cumulocity cloud</a></h1>
<p>This document describes how to manage the software modules that are installed on a thin-edge device from the
cloud using the <strong>software management</strong> feature of thin-edge.io.</p>
<blockquote>
<p>Note: This tutorial shows the Debian based distributions <strong>apt</strong> package manager use-case powered by our official <strong>apt</strong> plugin.
Other package managers can be supported by adding a plugin.
Refer to <a href="tutorials/./write-my-software-management-plugin.html">this</a> document on how to write a plugin to support software management for any other software type.</p>
</blockquote>
<blockquote>
<p>Important: As of now, software management feature is supported only from Cumulocity cloud, which supports only <code>install</code> and <code>delete</code> as an action of c8y_SoftwareUpdate operation.</p>
</blockquote>
<p>Three components are required on your devices to enable software management:</p>
<ol>
<li>
<p>Software management mapper for Cumulocity cloud acts as a proxy between the cloud and the device.
This translates the cloud specific message type into device specific type and vice-versa.(Example: Cumulocity smart-rest to/from thin-edge json)
The messages from cloud will be translated and forwarded to the <code>tedge-agent</code> and messages from <code>tedge-agent</code> will be translated and sent to cumulocity cloud.
You can find this process with the name <code>tedge-mapper c8y</code> in <code>ps</code> once it starts.</p>
</li>
<li>
<p>Software management agent
The thin-edge software management agent is the one that calls the plugins.
You can find this process with the name <code>tedge-agent</code> in <code>ps</code> once it starts.</p>
</li>
<li>
<p>Software management plugin
Plugins are the interfaces that call the package manager (example: apt/apt-get) to do the software management operations (Install, Remove or update)
You can find them in /etc/tedge/sm-plugins.
As of now there is only one (apt) plugin is supported.</p>
</li>
</ol>
<h2 id="enable-software-management-feature"><a class="header" href="#enable-software-management-feature">Enable software management feature</a></h2>
<p>Find more information about <a href="tutorials/../howto-guides/012_install_and_enable_software_management.html">how to install and enable software management.</a></p>
<h2 id="managing-the-device-software-repository-on-cumulocity-cloud"><a class="header" href="#managing-the-device-software-repository-on-cumulocity-cloud">Managing the device software <strong>repository</strong> on Cumulocity cloud</a></h2>
<p>Managing the software packages installed on the devices from your Cumulocity tenant is a two steps operation.</p>
<ul>
<li>Populate the software repository with all the software packages and versions you plan to install.</li>
<li>Trigger software update operations on the devices, to install specific packages from the repository.</li>
</ul>
<p>Find more information about <a href="https://cumulocity.com/guides/users-guide/device-management/#managing-device-software">managing the device software</a></p>
<h3 id="adding-new-software-into-the-software-repository-of-your-tenant"><a class="header" href="#adding-new-software-into-the-software-repository-of-your-tenant">Adding new software into the software repository of your tenant</a></h3>
<ol>
<li>
<p>In the Software repository page, click Add software at the right of the top menu bar.</p>
</li>
<li>
<p>In the resulting dialog box,</p>
<ul>
<li>to add a new software, enter a name for the software (and confirm it by clicking Create new in the resulting window),
a description and its version.</li>
<li>to add a new version, select the software for which you want to add a new version from the dropdown list in the Software
field and enter a version of the package. The version is optional and can be set to &quot;latest&quot; or to an empty space (' '), both meaning the latest version will be used.</li>
</ul>
<blockquote>
<p>Note: The version field format is <code>package_version::plugin_type_name</code>.The plugin type name that is provided here is used to pick
the appropriate plugin among those installed in /etc/tedge/sm-plugins.</p>
</blockquote>
<blockquote>
<p>Note 2: If the postfix <code>::plugin_type_name</code> is left empty, a <code>default</code> plugin will be used if defined or if only a single plugin is installed.</p>
</blockquote>
</li>
<li>
<p>Optionally, you can define the device type filter when adding a new software.</p>
</li>
<li>
<p>thin-edge.io ships a default plugin supporting <code>debian</code> packages from both <code>apt</code> repositories as well as remote locations.
If you prefer to use packages from an <code>apt</code> repository, select the <strong>Provide a file path</strong> option and give an <strong>empty space</strong> (' ').
<img src="tutorials/./images/add-new-software-to-repo.png" alt="Add new software" /></p>
<p>If you would like to use other sources (eg. file uploaded to your cloud or an external source), provide the full url to the file.
<img src="tutorials/./images/add-new-software-to-repo-binary.png" alt="Add new software from uploaded binary" /></p>
<p>If you would like to upload your binaries, select <code>Upload a binary</code> option and upload the file to Cumulocity software repository.
<img src="tutorials/./images/add-new-software-to-repo-remote.png" alt="Add new software from remote" /></p>
<blockquote>
<p>Note: Bear in mind that some external remotes may require additional authentication which is not supported at the moment.</p>
</blockquote>
</li>
<li>
<p>Press <code>Add Software</code> button.</p>
</li>
</ol>
<h3 id="deleting-software-or-software-version"><a class="header" href="#deleting-software-or-software-version">Deleting software or software version</a></h3>
<p>One can remove a software module or a specific version of it from the software repository.
Find more information about <a href="https://cumulocity.com/guides/users-guide/device-management/#deleting-softwares-or-software-versions">how to delete the software or the specific software version</a></p>
<h2 id="managing-software-on-a-device"><a class="header" href="#managing-software-on-a-device">Managing software on a device</a></h2>
<p>Find more information about <a href="https://cumulocity.com/guides/users-guide/device-management/#managing-software-on-a-device">how to manage the software</a> on a device.</p>
<p>From the Cumulocity cloud <code>Software</code> tab of a device, software can be</p>
<ul>
<li><a href="https://cumulocity.com/guides/users-guide/device-management/#to-install-software-on-a-device">installed</a></li>
</ul>
<blockquote>
<p>Note: Software profiles are not supported as of now on thin-edge.</p>
</blockquote>
<ul>
<li><a href="https://cumulocity.com/guides/users-guide/device-management/#to-update-software-on-a-device">updated</a></li>
</ul>
<blockquote>
<p>Note: Thin-edge treats install and update same.</p>
</blockquote>
<ul>
<li><a href="https://cumulocity.com/guides/users-guide/device-management/#to-delete-software-from-a-device">removed</a></li>
</ul>
<blockquote>
<p>Note: Once the above mentioned operation is selected, one should click on <strong>Apply changes</strong> to confirm operation.</p>
</blockquote>
<h2 id="default-plugin"><a class="header" href="#default-plugin">Default plugin</a></h2>
<p>When there are multiple plugins installed on the device, one can set one of them as a default plugin.
If there is only one plugin installed on the device, then implicitly this will be the default plugin.</p>
<h3 id="usage-of-default-plugin"><a class="header" href="#usage-of-default-plugin">Usage of <code>default plugin</code></a></h3>
<p>When the default plugin is set, then the software operation does not need to provide an explicit type of the software, then the default will be used.
In Cumulocity, one can then simply provide the package to update without having to annotate the version field with its type.</p>
<h3 id="configuring-the-default-plugin"><a class="header" href="#configuring-the-default-plugin">Configuring the default plugin</a></h3>
<p>Default plugin can be configured using the thin-edge cli command <code>tedge</code>.</p>
<p>For example set <code>apt</code> plugin as a <code>default plugin</code></p>
<pre><code class="language-shell">sudo tedge config set software.plugin.default apt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-my-software-management-plugin"><a class="header" href="#write-my-software-management-plugin">Write my software management plugin</a></h1>
<p><strong>thin-edge.io</strong> Software Management natively supports APT (Debian) packages.
However, there are many package management systems in the world,
and you may want to have a plugin that is suitable for your device.
For such a demand, we provide the <a href="tutorials/./../references/plugin-api.html"><strong>Package Manager Plugin API</strong></a>
to write a custom Software Management plugin in your preferred programming language.</p>
<p>In this tutorial, we will look into the <strong>Package Manager Plugin API</strong>,
and learn how to write your own plugin with a docker plugin shell script example.</p>
<h2 id="create-a-plugin"><a class="header" href="#create-a-plugin">Create a plugin</a></h2>
<p>Create a <em>docker</em> file in the directory <em>/etc/tedge/sm-plugins/</em>. 
A plugin must be an executable file located in that directory.</p>
<p>Filename: /etc/tedge/sm-plugins/docker</p>
<pre><code class="language-shell">#!/bin/sh

COMMAND=&quot;$1&quot;
IMAGE_NAME=&quot;$2&quot;

case &quot;$COMMAND&quot; in
    list)
        docker image list --format '{{.Repository}}\t{{.Tag}}' || exit 2
        ;;
    install)
        docker pull $IMAGE_NAME || exit 2
        ;;
    remove)
        docker rmi $IMAGE_NAME || exit 2
        ;;
    prepare)
        ;;
    finalize)
        ;;
    update-list)
        exit 1
        ;;
esac
exit 0
</code></pre>
<blockquote>
<p><strong>Info</strong>: the filename will be used as a plugin type to report the software list to a cloud.
If you name it <code>docker.sh</code>, you will see <code>docker.sh</code> as a plugin type in cloud.</p>
</blockquote>
<p>If you execute <code>./docker list</code>, you will see this kind of output.</p>
<pre><code class="language-csv">alpine  3.14
eclipse-mosquitto   2.0-openssl
...
</code></pre>
<p>The Software Management Agent runs executable plugins with a special argument, like <code>list</code>.
Let's call the pre-defined argument such as <code>list</code>, <code>install</code>, and <code>remove</code> a <strong>command</strong> here. 
As you can see from this example, a plugin should be an executable file 
that accepts the commands and outputs to stdout and stderr.
Hence, you can implement a plugin in your preferred language.</p>
<p>Here is the table of the commands that you can use in a plugin.</p>
<table><thead><tr><th>Command</th><th>Input arguments</th><th>Expected output</th><th>Description</th></tr></thead><tbody>
<tr><td>list</td><td>-</td><td>lines with tab separated values</td><td>Returns the list of software modules that have been installed with this plugin.</td></tr>
<tr><td>prepare</td><td>-</td><td>-</td><td>Executes the provided actions before a sequence of install and remove commands.</td></tr>
<tr><td>finalize</td><td>-</td><td>-</td><td>Executes the provided actions after a sequence of install and remove commands.</td></tr>
<tr><td>install</td><td>NAME [--module-version VERSION] [--file FILE]</td><td>-</td><td>Executes the action of installation.</td></tr>
<tr><td>remove</td><td>NAME [--module-version VERSION]</td><td>-</td><td>Executes the action of uninstallation.</td></tr>
<tr><td>update-list</td><td>COMMAND NAME [--module-version VERSION] [--file FILE]</td><td>-</td><td>Executes the list of <code>install</code> and <code>remove</code> commands.</td></tr>
</tbody></table>
<p>The order of the commands invoked by the Software Management Agent is:
<code>prepare</code> -&gt; <code>update-list</code> or [<code>install</code>, <code>remove</code>] -&gt;<code>finalize</code></p>
<blockquote>
<p><strong>info</strong>: There is no guarantee of the order between <code>install</code> and <code>remove</code>.
If you need a specific order, use <code>update-list</code> command instead.</p>
</blockquote>
<p>In the following sections, we will dive into each command and other rules deeply.</p>
<h2 id="input-output-and-errors"><a class="header" href="#input-output-and-errors">Input, Output, and Errors</a></h2>
<p>Before we dive into each command, we should clarify the basic rules of plugins.</p>
<h3 id="input"><a class="header" href="#input">Input</a></h3>
<p>The command themselves and further required arguments must be given as command-line arguments.
The only exception is <code>update-list</code>, which requires <strong>stdin</strong> input.</p>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<p>The <strong>stdout</strong> and <strong>stderr</strong> of the process running a plugin command are captured by the Software Management Agent.</p>
<h3 id="exit-status"><a class="header" href="#exit-status">Exit status</a></h3>
<p>The exit status of plugins are interpreted by sm-agent as follows:</p>
<ul>
<li><strong>0</strong>: success.</li>
<li><strong>1</strong>: usage. The command arguments cannot be interpreted, and the command has not been launched.</li>
<li><strong>2</strong>: failure. The command failed and there is no point to retry.</li>
<li><strong>3</strong>: retry. The command failed but might be successful later (for instance, when the network will be back).</li>
</ul>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<p>The <code>list</code> command is responsible to return the list of the installed software modules.</p>
<p>Rules:</p>
<ul>
<li>This command takes no arguments.</li>
<li>The list is returned using <a href="https://en.wikipedia.org/wiki/Tab-separated_values">CSV with tabulations as separators</a>,
including:
<ul>
<li><strong>name</strong>: the name of the software module, e.g. <code>mosquitto</code>.
This name is the name that has been used to install it and that needs to be used to remove it.</li>
<li><strong>version</strong>: the version currently installed.
This is a string that can only be interpreted in the context of the plugin.
&gt;Note: If the version is not present for a module, then list can return only the module name without trailing tabulation.
Given that your plugin is named <code>docker</code>, then the Software Management Agent calls</li>
</ul>
</li>
</ul>
<pre><code class="language-shell">sudo /etc/tedge/sm-plugins/docker list
</code></pre>
<p>to report the list of software modules installed.</p>
<blockquote>
<p><strong>Important</strong>: the Software Management Agent executes a plugin using <code>sudo</code> and as <code>tedge-agent</code> user.</p>
</blockquote>
<p><code>docker</code> should output in the CSV with tabulations as separators like</p>
<pre><code class="language-csv">alpine  3.14
eclipse-mosquitto   2.0-openssl
rust    1.51-alpine
</code></pre>
<p>with exit code <code>0</code> (successful).</p>
<p>In most cases, the output of the <code>list</code> command is multi-lines.
The line separator should be <code>\n</code>.</p>
<p>A plugin must return a CSV line per software module, using a tabulation <code>\t</code> as separator.
If there is no version field then only the module name will be returned.
In the <em>docker</em> file example, the following command outputs CSV structures with tabulations as separator.</p>
<pre><code class="language-shell">docker image list --format '{{.Repository}}\t{{.Tag}}'
</code></pre>
<h2 id="prepare"><a class="header" href="#prepare">Prepare</a></h2>
<p>The <code>prepare</code> command is invoked by the sm-agent before a sequence of install and remove commands.</p>
<p>Rules:</p>
<ul>
<li>It takes no argument and no output is expected.</li>
<li>If the <code>prepare</code> command fails,
then the whole Software Management operation is cancelled.</li>
</ul>
<p>For many plugins, this command has nothing specific to do, and can simply return with a <code>0</code> exit status.</p>
<p>In some plugin types, this <code>prepare</code> command can help you.
For example, assume that you want to implement a plugin for APT,
and want to run <code>apt-get update</code> always before calling the <code>install</code> command. 
In this example, the <code>prepare</code> command is the right place to invoke <code>apt-get update</code>.</p>
<h2 id="finalize"><a class="header" href="#finalize">Finalize</a></h2>
<p>The <code>finalize</code> command closes a sequence of install and removes commands started by a prepare command.</p>
<p>Rules:</p>
<ul>
<li>It takes no argument and no output is expected.</li>
<li>If the <code>finalize</code> command fails, then the whole Software Management operation is reported as failed,
even if all the atomic actions have been successfully completed.</li>
</ul>
<p>Similar to the <code>prepare</code> plugin, you must define the command even if you want nothing in the <code>finalize</code> command.</p>
<p>The command can be used in several situations. For example, </p>
<ul>
<li>remove any unnecessary software module after a sequence of actions.</li>
<li>commit or roll back the sequence of actions.</li>
<li>restart any processes using the modules,
e.g. restart the analytics engines if the modules have changed.</li>
</ul>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>The <code>install</code> command installs a software module, possibly of some expected version.
A plugin must be executable in the below format.</p>
<pre><code class="language-shell">myplugin install NAME [--module-version VERSION] [--file FILE]
</code></pre>
<p>This command takes 1 mandatory argument and has 2 optional flags.</p>
<ul>
<li><strong>NAME</strong>: the name of the software module to be installed, e.g. <code>mosquitto</code>. (Mandatory)</li>
<li><strong>VERSION</strong>: the version to be installed. e.g. <code>1.5.7-1+deb10u1</code>.
The version can be blank, so it's recommended to define the behaviour if a version is not provided. 
For example, always installs the &quot;latest&quot; version if a version is not provided. (Optional)</li>
<li><strong>FILE</strong>: the path to the software to be installed. (Optional)</li>
</ul>
<p>The installation phase may fail due to the following reasons.
An error must be reported if:</p>
<ul>
<li>The module name is unknown.</li>
<li>There is no version for the module that matches the constraint provided by the <code>--module-version</code> option.</li>
<li>The file content provided by <code>--file</code> option:
<ul>
<li>is not in the expected format,</li>
<li>doesn't correspond to the software module name,</li>
<li>has a version that doesn't match the constraint provided by the <code>--module-version</code> option (if any).</li>
</ul>
</li>
<li>The module cannot be downloaded.</li>
<li>The module cannot be installed.</li>
</ul>
<p>At the API level, there is no command to distinguish install or upgrade.</p>
<p>Back to the first <em>docker</em> example, it doesn't address the case with version. 
Let's expand the example file as below.</p>
<p>Filename: /etc/tedge/sm-plugins/docker</p>
<pre><code class="language-shell">#!/bin/sh

COMMAND=&quot;$1&quot;
IMAGE_NAME=&quot;$2&quot;
VERSION_FLAG=&quot;$3&quot;
IMAGE_TAG=&quot;$4&quot;

case &quot;$COMMAND&quot; in
    list)
        docker image list --format '{{.Repository}}\t{{.Tag}}' || exit 2
        ;;
    install)
        if [ $# -eq 2 ]; then
            docker pull $IMAGE_NAME || exit 2
        elif [ $# -eq 4 ] &amp;&amp; [ $VERSION_FLAG = &quot;--module-version&quot; ]; then
            docker pull $IMAGE_NAME:$IMAGE_TAG || exit 2
        else
            echo &quot;Invalid arguments&quot;
            exit 1
        fi
        ;;
    remove)
        if [ $# -eq 2 ]; then
            docker rmi $IMAGE_NAME || exit 2
        elif [ $# -eq 4 ] &amp;&amp; [ $VERSION_FLAG = &quot;--module-version&quot; ]; then
            docker rmi $IMAGE_NAME:$IMAGE_TAG || exit 2
        else
            echo &quot;Invalid arguments&quot;
            exit 1
        fi
        ;;
    prepare)
        ;;
    finalize)
        ;;
    update-list)
        exit 1
        ;;
esac
exit 0
</code></pre>
<p>Pay attention to the exit statuses.
In case of invalid arguments, the plugin returns <code>1</code>.
If a command is executed but fails, the plugin returns <code>2</code>.
Each exit status is defined <a href="tutorials/write-my-software-management-plugin.html#exit-status">here</a>.</p>
<p>If the given NAME is <code>mosquitto</code>, and the given VERSION is <code>1.5.7-1+deb10u1</code>,
the Software Management Agent calls</p>
<pre><code class="language-shell">sudo /etc/tedge/sm-plugins/docker install mosquitto --module-version 1.5.7-1+deb10u1
</code></pre>
<p>Then, the plugin executes</p>
<pre><code class="language-shell">docker pull mosquitto:1.5.7-1+deb10u1
</code></pre>
<h2 id="remove"><a class="header" href="#remove">Remove</a></h2>
<p>The <code>remove</code> command uninstalls a software module,
and possibly its dependencies if no other modules are dependent on those.
A plugin must be executable in the below format.</p>
<pre><code class="language-shell">myplugin remove NAME [--module-version VERSION]
</code></pre>
<p>This command takes 1 mandatory argument and 1 optional argument with a flag.</p>
<ul>
<li><strong>NAME</strong>: the name of the software module to be removed, e.g. <code>mosquitto</code>. (Mandatory)</li>
<li><strong>VERSION</strong>: the version to be installed. e.g. <code>1.5.7-1+deb10u1</code>.
The version can be blank, so it's recommended to define the behaviour if a version is not provided.
For example, uninstall a software module regardless of its version if a version is not provided. (Optional)</li>
</ul>
<p>The uninstallation phase can be failed due to several reasons. An error must be reported if:</p>
<ul>
<li>The module name is unknown.</li>
<li>The module cannot be uninstalled.</li>
</ul>
<p>Back to the first <em>docker</em> plugin example,
if the NAME is <code>mosquitto</code>, and the VERSION is <code>1.5.7-1+deb10u1</code>,
the Software Management Agent calls</p>
<pre><code class="language-shell">sudo /etc/tedge/sm-plugins/docker remove mosquitto --module-version 1.5.7-1+deb10u1
</code></pre>
<p>Then, the plugin executes</p>
<pre><code class="language-shell">docker rmi mosquitto:1.5.7-1+deb10u1
</code></pre>
<h2 id="update-list"><a class="header" href="#update-list">Update-list</a></h2>
<p>The <code>update-list</code> command accepts a list of software modules and associated operations as <code>install</code> or <code>remove</code>.
This basically achieves the same purpose as original commands install and remove,
but gets passed all software modules to be processed in one command.
This can be needed when an order of processing software modules is relevant.</p>
<p>In other words, you can choose a combination of the <code>install</code> or <code>remove</code> commands or this <code>update-list</code> command up to your requirement.
If you don't want to use <code>update-list</code>, the plugin must return <code>1</code> like the first <em>docker</em> plugin example.</p>
<pre><code class="language-shell">case &quot;$COMMAND&quot; in
    ...
    update-list)
        exit 1
        ;;
esac
</code></pre>
<p>Let's expand the first <em>docker</em> plugin example to use <code>update-list</code>.
First, learn what is the input of <code>update-list</code>.</p>
<p>The Software Management Agent calls a plugin as below. Note that each argument is tab separated:</p>
<pre><code class="language-shell">sudo /etc/tedge/sm-plugins/docker update-list &lt;&lt;EOF
  install	name1	version1
  install	name2		path2
  remove	name3	version3
  remove	name4
EOF
</code></pre>
<p>The point is that it doesn't take any command-line argument, 
but the software action list is sent through <strong>stdin</strong>.</p>
<p>The behaviour of operations <code>install</code> and <code>remove</code> is the same as for original commands <code>install</code> and <code>remove</code>. 
The above input is equivalent to the use of original commands (<code>install</code> and <code>remove</code>):</p>
<pre><code class="language-shell">/etc/tedge/sm-plugins/docker install name1 --module-version version1
/etc/tedge/sm-plugins/docker install name2 --file path2
/etc/tedge/sm-plugins/docker remove &quot;name 3&quot; --module-version version3
/etc/tedge/sm-plugins/docker remove name4
</code></pre>
<p>To make the <em>docker</em> plugin accept a list of install and remove actions,
let's change the file as below.
Note that this example works only in bash.</p>
<p>Filename: /etc/tedge/sm-plugins/docker</p>
<pre><code class="language-shell">#!/bin/bash

COMMAND=&quot;$1&quot;

case &quot;$COMMAND&quot; in
    list)
        docker image list --format '{{.Repository}}\t{{.Tag}}' || exit 2
        ;;
    install)
        echo docker pull &quot;$2:$3&quot;
        ;;
    remove)
        echo docker rmi &quot;$2:$3&quot;
        ;;
    prepare)
        ;;
    finalize)
        ;;
    update-list)
        while IFS=$'\t' read -r ACTION MODULE VERSION FILE
        do
            bash -c &quot;$0 $ACTION $MODULE $VERSION&quot;
        done
        ;;
esac
exit 0
</code></pre>
<p>You can find that <code>install</code> and <code>remove</code> are replaced by <code>update-list</code>.
<code>update-list</code> should define the behaviour to read line by line for the case <code>install</code> and <code>remove</code>.</p>
<p>Also, <code>update-list</code> must be <strong>fail-fast</strong>.
That example exists immediately if one of the commands fails.</p>
<h2 id="project-references"><a class="header" href="#project-references">Project references</a></h2>
<p>You can also refer to:</p>
<ul>
<li>the specification of the <a href="https://github.com/thin-edge/thin-edge.io/blob/main/docs/src/references/plugin-api.md">Package Manager Plugin API</a>.</li>
<li><a href="https://github.com/thin-edge/thin-edge.io/tree/main/plugins/tedge_apt_plugin">the APT plugin</a> written in Rust. </li>
<li><a href="https://github.com/thin-edge/thin-edge.io/blob/main/sm/plugins/tedge_docker_plugin/tedge_docker_plugin.sh">the example Docker plugin</a> written in POSIX standard shell script.
This plugin can install/remove docker containers using docker image tags. This plugin is <strong>not</strong> to be used in production without necessary enhancements. It is to be used only as a reference to write your own plugin.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thin-edgeio-supported-operations"><a class="header" href="#thin-edgeio-supported-operations">thin-edge.io Supported Operations</a></h1>
<h2 id="supported-operations-concepts"><a class="header" href="#supported-operations-concepts">Supported Operations concepts</a></h2>
<h3 id="device-operations"><a class="header" href="#device-operations">Device operations</a></h3>
<p>IoT devices often do more than just send data to the cloud. They also do things like:</p>
<ul>
<li>receive triggers from the operator</li>
<li>reboot on demand</li>
<li>install or remove software</li>
</ul>
<p>These operations are supported by <a href="https://cumulocity.com/api/10.11.0/#section/Device-management-library">Cumulocity IoT</a> and other cloud providers.
On <code>thin-edge.io</code> the support for one such operation can be added using the <code>thin-edge.io</code> Supported Operations API.</p>
<h3 id="thin-edgeio-supported-operations-api"><a class="header" href="#thin-edgeio-supported-operations-api"><code>thin-edge.io</code> Supported Operations API</a></h3>
<p>The Supported Operations utilises the file system to add and remove operations. A special file placed in <code>/etc/tedge/operations</code> directory will indicate that an operation is supported.
The specification for the operation files is described in <code>thin-edge.io</code> specifications repository <a href="https://github.com/thin-edge/thin-edge.io-specs/blob/main/src/supported-operations/README.md">src/supported-operations/README.md</a></p>
<p>Supported operations are declared in the cloud specific subdirectory of <code>/etc/tedge/operations</code> directory.</p>
<h2 id="custom-supported-operations"><a class="header" href="#custom-supported-operations">Custom Supported Operations</a></h2>
<p><code>thin-edge.io</code> supports custom operations by using configuration files and plugin mechanism similar to what software management agent does.</p>
<p>The main difference between custom operations and native operations is that custom operations are have to be defined in configuration files and provide their own implementation in a callable <code>plugin</code> executable.
As per specification the configuration file needs to be a <code>toml</code> file which describes the operation.</p>
<p><code>thin-edge.io</code> stores the operations configuration files in the <code>/etc/tedge/operations/&lt;cloud-provider&gt;/</code> directory.</p>
<h2 id="supported-operations-for-child-devices"><a class="header" href="#supported-operations-for-child-devices">Supported Operations for Child Devices</a></h2>
<p>When a new child device is bootstrapped, it needs to create <code>/etc/tedge/operations/&lt;cloud-provider&gt;/&lt;child- device&gt;</code> directory to store the supported operations of that child device.
Every file placed in the <code>/etc/tedge/operations/&lt;cloud-provider&gt;/&lt;child-device&gt;</code> directory represents an operation supported by that child device.
The operation files can be dynamically added and removed.</p>
<h2 id="thin-edgeio-list-of-supported-operations"><a class="header" href="#thin-edgeio-list-of-supported-operations"><code>thin-edge.io</code> List of Supported Operations</a></h2>
<p><code>thin-edge.io</code> supports natively the following operations:</p>
<ul>
<li>Software Update</li>
<li>Software Update Log Upload</li>
<li>Restart</li>
</ul>
<p>The list is growing as we support more operations, but is not exhaustive and we encourage you to contribute to the list.</p>
<h2 id="how-to-use-supported-operations"><a class="header" href="#how-to-use-supported-operations">How to use Supported Operations</a></h2>
<h3 id="listing-current-operations"><a class="header" href="#listing-current-operations">Listing current operations</a></h3>
<p>You can obtain the current list of supported operations by listing the content of the <code>/etc/tedge/operations</code> directory.
This directory should have permissions set to <code>755</code> and the owner to <code>tedge</code>.
This directory will contain a set subdirectories based on cloud providers currently supported eg:</p>
<pre><code class="language-shell">ls -l /etc/tedge/operations

drwxr-xr-x 2 tedge tedge 4096 Jan 01 00:00 az
drwxr-xr-x 2 tedge tedge 4096 Jan 01 00:00 c8y
</code></pre>
<p>From the above you can see that there are three cloud providers supported by <code>thin-edge.io</code>.
The directories should be readable by <code>thin-edge.io</code> user - <code>tedge</code> - and should have permissions <code>755</code>.</p>
<p>To list all currently supported operations for a cloud provider, run:</p>
<pre><code class="language-shell">ls -l /etc/tedge/operations/c8y

-rw-r--r-- 1 tedge tedge 0 Jan 01 00:00 c8y_Restart
</code></pre>
<p>To list all currently supported operations, run:
The operations files should have permissions <code>644</code> and the owner <code>tedge</code>.</p>
<pre><code class="language-shell">sudo ls -lR /etc/tedge/operations
</code></pre>
<pre><code>/etc/tedge/operations:
drwxr-xr-x 2 tedge tedge 4096 Jan 01 00:00 az
drwxr-xr-x 2 tedge tedge 4096 Jan 01 00:00 c8y

/etc/tedge/operations/az:
-rw-r--r-- 1 tedge tedge 0 Jan 01 00:00 Restart

/etc/tedge/operations/c8y:
-rw-r--r-- 1 tedge tedge 0 Jan 01 00:00 c8y_Restart
</code></pre>
<p>One can list all the currently supported operations for a child device as below</p>
<pre><code class="language-shell">sudo ls -lR /etc/tedge/operations/c8y/&lt;child-device&gt;
</code></pre>
<pre><code>-rw-r--r-- 1 tedge tedge 0 Oct 26 11:24 c8y_LogfileRequest
</code></pre>
<h3 id="adding-new-operations"><a class="header" href="#adding-new-operations">Adding new operations</a></h3>
<p>To add new operation we need to create new file in <code>/etc/tedge/operations</code> directory.
Before we create that file we have to know which cloud provider we are going to support (it is possible to support multiple cloud providers, but we won't cover this here).</p>
<p>We will add operation <code>Restart</code> for our device which can be triggered from Cumulocity IoT called, in Cumulocity IoT this operations name is <code>c8y_Restart</code>.
This operation will do the reboot of our device when we receive trigger from the operator. <code>thin-edge.io</code> device will receive an MQTT message with certain payload and we already have a handler for that payload in the <code>tedge-mapper-c8y</code>.</p>
<p>To add new operation we will create a file in <code>/etc/tedge/operations/c8y</code> directory:</p>
<pre><code class="language-shell">sudo -u tedge touch /etc/tedge/operations/c8y/c8y_Restart
</code></pre>
<blockquote>
<p>Note: We are using <code>sudo -u</code> to create the file because we want to make sure that the file is owned by <code>tedge</code> user.</p>
</blockquote>
<p>Now the new operation will be automatically added to the list and the list will be sent to the cloud.</p>
<p>To add a new operation to a child device, create a new file in <code>/etc/tedge/operations/c8y/&lt;child-device&gt;</code> directory as below.</p>
<pre><code class="language-shell">sudo -u tedge touch /etc/tedge/operations/c8y/&lt;child-device&gt;/c8y_Restart
</code></pre>
<p>Now the new operation will be automatically added to the list of child supported operations and will be sent to the cloud.</p>
<h3 id="removing-supported-operations"><a class="header" href="#removing-supported-operations">Removing supported operations</a></h3>
<p>To remove a supported operation for a thin-edge device, the corresponding operation file must be removed from the <code>/etc/tedge/operations/c8y</code> directory. eg:</p>
<pre><code class="language-shell">sudo rm /etc/tedge/operations/c8y/c8y_Restart
</code></pre>
<p>Similarly, the supported operation for a child device can be removed by removing the corresponding operation file from the child device operations directory
at <code>/etc/tedge/operations/c8y/&lt;child-device&gt;</code>. Eg:</p>
<pre><code class="language-shell">sudo rm /etc/tedge/operations/c8y/&lt;child-device&gt;/c8y_Restart
</code></pre>
<p>Now the operation will be automatically removed from the list and the list will be sent to the cloud.</p>
<h2 id="working-with-custom-operations"><a class="header" href="#working-with-custom-operations">Working with custom operations</a></h2>
<p>We will use the <code>thin-edge.io</code> Supported Operations API to add custom operations. Our new operation is going to be capability to execute shell commands on the device.
Let's create the operation configuration file:</p>
<p>We need to tell <code>thin-edge.io</code> how to handle the operation and how to execute it.</p>
<h3 id="adding-new-custom-operation"><a class="header" href="#adding-new-custom-operation">Adding new custom operation</a></h3>
<p>In Cumulocity IoT we know that there is an operation call c8y_Command which allows us to send commands to the device and get the result back to the cloud, let's create the configuration file for our new operation:</p>
<p>First we create a file with the name of the operation:</p>
<pre><code class="language-shell">sudo -u tedge touch /etc/tedge/operations/c8y/c8y_Command
</code></pre>
<blockquote>
<p>Note: the needs to be readable by <code>thin-edge.io</code> user - <code>tedge</code> - and should have permissions <code>644</code>.</p>
</blockquote>
<p>In this example we want <code>thin-edge.io</code> to pick up a message on specific topic and execute the command on the device, our topic is <code>c8y/s/ds</code>.
We also know that the message we expect is going to use SmartRest template <code>511</code> and our plugin is located in <code>/etc/tedge/operations/command</code>.
Then we need to add the configuration to the file (<code>/etc/tedge/operations/c8y/c8y_Command</code>):</p>
<pre><code class="language-toml">[exec]
  topic = &quot;c8y/s/ds&quot;
  on_message = &quot;511&quot;
  command = &quot;/etc/tedge/operations/command&quot;
</code></pre>
<p>And now the content of our command plugin:</p>
<pre><code class="language-shell">#!/bin/bash
# Parse the smart rest message, ignore the first two field, and everything afterwards is the command
COMMAND=&quot;${1#*,*,}&quot;

# Check if command is wrapped with quotes, if so then remove them
if [[ &quot;$COMMAND&quot; == \&quot;*\&quot; ]]; then
    COMMAND=&quot;${COMMAND:1:-1}&quot;
fi

# Execute command
bash -c &quot;$COMMAND&quot;
EXIT_CODE=$?
if [ $EXIT_CODE -ne 0 ]; then
    echo &quot;Command returned a non-zero exit code. code=$EXIT_CODE&quot; &gt;&amp;2
fi

exit &quot;$EXIT_CODE&quot;
</code></pre>
<p>This simple example will parse the third field of the received SmartREST message and execute the command.
If it exits with the status code <code>0</code>, a successful message with the stdout content will be reported to Cumulocity.
If it exits with a non-zero code, a failure message with the stderr content will be sent out.</p>
<blockquote>
<p>Note: The command will be executed with tedge-mapper permission level so most of the system level commands will not work.</p>
</blockquote>
<h3 id="list-of-currently-supported-operations-parameters"><a class="header" href="#list-of-currently-supported-operations-parameters">List of currently supported operations parameters</a></h3>
<ul>
<li><code>topic</code> - The topic on which the operation will be executed.</li>
<li><code>on_message</code> - The SmartRest template on which the operation will be executed.</li>
<li><code>command</code> - The command to execute.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-thin-edge-for-a-yocto-linux-distribution"><a class="header" href="#build-thin-edge-for-a-yocto-linux-distribution">Build Thin Edge for a Yocto Linux distribution</a></h1>
<p>Yocto Project enables you to create a customised Linux distribution for your IoT devices. You can select the base image
and add layers, containing software that you need on your image. In this tutorial, we will add Thin Edge using the
<code>meta-tedge</code> layer. For more information, see the <a href="https://www.yoctoproject.org/software-overview/">getting started document on Yocto Project
website</a>.</p>
<p>The <code>meta-tedge</code> is supported for <strong>Yocto version 3.4 &quot;Honister&quot; and 4.0 &quot;Kirkstone&quot;</strong>. It depends on <code>meta-networking</code>, <code>meta-python</code> and <code>meta-oe</code> layers, which are part of <code>meta-openembedded</code> layer. Since version 0.9.0, the layer requires <code>meta-rust</code> to meet the requirements of the rust version of thin-edge. </p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>If you are not familiar with building Yocto distribution or you have not configured your build host yet, we strongly
recommend to look into <a href="https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html">official yocto documentation</a>
as the installation process will now skip all information that were mentioned there! For workspace organization or
raspberry pi distribution, we also recommend this <a href="https://github.com/jynik/ready-set-yocto">guide</a></p>
<blockquote>
<p>Most of the installation process is based on <a href="https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html">Yocto Project Quick Build
guide</a>.</p>
</blockquote>
<p>Before starting, be sure the host, where you plan to build a new Yocto image with thin-edge, meets the following
requirements:</p>
<ul>
<li>50 Gbytes of free disk space</li>
<li>a Linux distributions that supports the Yocto Project, see the <a href="https://docs.yoctoproject.org/4.0.4/ref-manual/system-requirements.html#supported-linux-distributions">Supported Linux
Distributions</a>
section in the Yocto Project Reference Manual. For detailed information on preparing your build host, see the <a href="https://docs.yoctoproject.org/4.0.4/dev-manual/start.html#preparing-the-build-host">Preparing
the Build Host</a> section in the Yocto
Project Development Tasks Manual.</li>
<li>Git 1.8.3.1 or greater</li>
<li>tar 1.28 or greater</li>
<li>Python 3.6.0 or greater.</li>
<li>gcc 5.0 or greater.</li>
</ul>
<blockquote>
<p>For the purposes of the tutorial, we assume <code>/home/yocto/</code> working directory. If using other directory, be sure to
change paths where needed.</p>
</blockquote>
<h3 id="build-host-packages"><a class="header" href="#build-host-packages">Build Host Packages</a></h3>
<p>Install essential packages:</p>
<pre><code class="language-bash">sudo apt install gawk wget git diffstat unzip texinfo gcc build-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping python3-git python3-jinja2 libegl1-mesa libsdl1.2-dev pylint3 xterm python3-subunit mesa-common-dev zstd liblz4-tool
</code></pre>
<h3 id="clone-poky-linux-repository"><a class="header" href="#clone-poky-linux-repository">Clone Poky Linux repository</a></h3>
<p>Clone the Poky Linux distribution sources. We'll be using version <code>kirkstone</code>. You can use <code>--depth=1</code> to speed up the
process. If using these options, to see previous commits or other branches see
<a href="https://stackoverflow.com/questions/29270058/how-to-fetch-all-git-history-after-i-clone-the-repo-with-depth-1">here</a>
and <a href="https://stackoverflow.com/questions/17714159/how-do-i-undo-a-single-branch-clone">here</a>.</p>
<blockquote>
<p>Alternatively, you could use <code>--branch=honister</code> for Yocto version 3.4 Honister. If doing so, remember to also use
<code>--branch=honister</code> for all additional layers that require it.</p>
</blockquote>
<pre><code class="language-bash">git clone git://git.yoctoproject.org/poky --branch=kirkstone --depth=1
</code></pre>
<p>Resulting directory structure should look like this:</p>
<pre><code>.
└── poky
    ├── bitbake
    ├── contrib
    ├── documentation
    ├── LICENSE
    ├── LICENSE.GPL-2.0-only
    ├── LICENSE.MIT
    ├── MAINTAINERS.md
    ├── Makefile
    ├── MEMORIAM
    ├── meta
    ├── meta-poky
    ├── meta-selftest
    ├── meta-skeleton
    ├── meta-yocto-bsp
    ├── oe-init-build-env
    ├── README.hardware.md -&gt; meta-yocto-bsp/README.hardware.md
    ├── README.md -&gt; README.poky.md
    ├── README.OE-Core.md
    ├── README.poky.md -&gt; meta-poky/README.poky.md
    ├── README.qemu.md
    └── scripts
</code></pre>
<h3 id="initialize-the-build-environment"><a class="header" href="#initialize-the-build-environment">Initialize the build environment</a></h3>
<p>To use the <code>bitbake</code>, <code>bitbake-layers</code>, <code>runqemu</code>, or other tools used in yocto to create or run our build, we need to
source the <code>poky/oe-init-build-env</code> script in our shell:</p>
<pre><code>cd poky
source oe-init-build-env
</code></pre>
<p>The script creates a <code>build</code> directory, which itself contains only a <code>conf</code> directory:</p>
<pre><code>.
└── poky
    ├── build
    │   └── conf
    │       ├── bblayers.conf
    │       ├── local.conf
    │       └── templateconf.cfg
    ...
</code></pre>
<p>The script prepares the environment such that we can run <code>bitbake</code> or <code>runqemu</code> in any directory, but <code>bitbake-layers</code>
command must be run from <code>build</code> directory.</p>
<p>Inside the <code>poky/build/conf</code> directory, there are 2 files of interest to us:</p>
<ul>
<li><code>bblayers.conf</code> contains all the layers used by build</li>
<li><code>local.conf</code> contains local build configuration, ie. configuration that applies only to the build</li>
</ul>
<p>In the following steps, we will edit these files to customize our image.</p>
<h3 id="add-layers"><a class="header" href="#add-layers">Add layers</a></h3>
<p><code>oe-init-build-env</code> moved us to the <code>build</code> directory. <code>cd</code> back to the working directory and clone the <code>meta-tedge</code>, <code>meta-rust</code> and
<code>meta-openembedded</code> repositories:</p>
<pre><code class="language-bash">cd ../../
git clone https://github.com/thin-edge/meta-tedge
git clone https://github.com/meta-rust/meta-rust.git
git clone --branch=kirkstone git://git.openembedded.org/meta-openembedded
</code></pre>
<blockquote>
<p>As with Poky itself, when cloning meta-openembedded either provide <code>--branch=kirkstone</code> for the clone command or
manually <code>git switch kirkstone</code> in <code>meta-openembedded</code> repository after cloning. Some Yocto layers support different
Yocto versions on different branches, in which case be sure to select correct branch. <code>meta-tedge</code> however supports 2
versions, Honister and Kirkstone on the main branch, so there's no need to change the default branch.</p>
</blockquote>
<p>Resulting in the following directory structure:</p>
<pre><code>.
├── meta-openembedded
├── meta-rust
├── meta-tedge
└── poky
</code></pre>
<blockquote>
<p>As these layers and <code>poky</code> are all different git repositories, we clone them next to the poky directory, but you can
put them inside <code>poky</code> if you prefer. The only thing that matters is to use a correct path in the
<code>poky/build/conf/bblayers.conf</code> file.</p>
</blockquote>
<p>Next, we add these layers to our build using <code>bitbake-layers</code> tool. Be aware that <code>meta-openembedded</code> is not itself a
layer, but a collection of many layers. We need to run it from the <code>build</code> directory:</p>
<pre><code class="language-bash">cd poky/build
bitbake-layers add-layer /home/yocto/meta-openembedded/meta-oe
bitbake-layers add-layer /home/yocto/meta-openembedded/meta-python
bitbake-layers add-layer /home/yocto/meta-openembedded/meta-networking
bitbake-layers add-layer /home/yocto/meta-rust
bitbake-layers add-layer /home/yocto/meta-tedge
</code></pre>
<p><code>bitbake-layers</code> tool adds the layer to our build by modyfying <code>poky/build/conf/bblayers.conf</code> file. You can verify the
file contains the above layers, or if something is wrong with the tool, you can edit the file manually, adding the
correct paths. The use of absolute paths is required.</p>
<p>In <code>poky/build/conf/bblayers.conf</code>:</p>
<pre><code># POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf
# changes incompatibly
POKY_BBLAYERS_CONF_VERSION = &quot;2&quot;

BBPATH = &quot;${TOPDIR}&quot;
BBFILES ?= &quot;&quot;

BBLAYERS ?= &quot; \
  /home/yocto/poky/meta \
  /home/yocto/poky/meta-poky \
  /home/yocto/poky/meta-yocto-bsp \
  /home/yocto/meta-openembedded/meta-oe \
  /home/yocto/meta-openembedded/meta-python \
  /home/yocto/meta-openembedded/meta-networking \
  /home/yocto/meta-rust \
  /home/yocto/meta-tedge \
  &quot;
</code></pre>
<h3 id="use-systemd-init-manager"><a class="header" href="#use-systemd-init-manager">Use systemd init manager</a></h3>
<p>For thin-edge to work, it has to run some setup scripts upon the first boot and interact with system services via the
init system. Right now, <code>meta-tedge</code> only supports systemd init manager. The default in yocto is initrd, thus we have to
change it.</p>
<blockquote>
<p>This, and any successive changes to the build configuration should happen only in your local configuration, ie.
<code>poky/build/conf/local.conf</code> or in configuration files of layers you create yourself. Changing any files in layers you
do not control - in our example <code>meta-tedge</code> or any of the layers in <code>meta-openembedded</code> - is discouraged, because any
changes you make to them may be lost when you update the layer.</p>
</blockquote>
<p>Activate <code>systemd</code> as default init manager by adding following line to <code>poky/build/conf/local.conf</code>:</p>
<pre><code>INIT_MANAGER=&quot;systemd&quot;
</code></pre>
<h3 id="use-apt-package-manager-optional"><a class="header" href="#use-apt-package-manager-optional">Use apt package manager (optional)</a></h3>
<p>In Yocto one can enable a package manager for installing or removing packages during runtime. To
include a package manager in our build, we need to add <code>package-management</code> feature:</p>
<p>In <code>poky/build/conf/local.conf</code>, add the following line:</p>
<pre><code>EXTRA_IMAGE_FEATURES += &quot;package-management&quot;
</code></pre>
<p>Additionally, we can choose between 3 available package formats, and their associated package managers.
Let us use <code>deb</code> package format and the apt package manager:</p>
<p>In <code>poky/build/conf/local.conf</code> find the following section and change <code>PACKAGE_CLASSES</code> from <code>package_rpm</code> to
<code>package_deb</code> as such:</p>
<pre><code>#
# Package Management configuration
#
# This variable lists which packaging formats to enable. Multiple package backends
# can be enabled at once and the first item listed in the variable will be used
# to generate the root filesystems.
# Options are:
#  - 'package_deb' for debian style deb files
#  - 'package_ipk' for ipk files are used by opkg (a debian style embedded package manager)
#  - 'package_rpm' for rpm style packages
# E.g.: PACKAGE_CLASSES ?= &quot;package_rpm package_deb package_ipk&quot;
# We default to rpm:
PACKAGE_CLASSES ?= &quot;package_deb&quot;
</code></pre>
<h3 id="build-and-run"><a class="header" href="#build-and-run">Build and run</a></h3>
<p>Finally, build the image and run it in the emulator.</p>
<p>Build <code>core-image-tedge</code> by running following command, from any directory:</p>
<pre><code class="language-bash">bitbake core-image-tedge
</code></pre>
<p>Bitbake tool will begin the building process, and all build artifacts will be put in <code>poky/build/tmp</code> directory.</p>
<p>When the build it complete, run it with qemu from any directory. It will automatically run the latest image built. We'll
use <code>nographic</code> option to run the emulator inside the current terminal, so that we may copy-paste from our system
clipboard, which wouldn't work in an external window. If this is not necessary, or if you run a graphical image, such as
<code>core-image-sato</code>, you can omit this option.</p>
<blockquote>
<p>For more information about runqemu tool, see <a href="https://docs.yoctoproject.org/4.0.5/dev-manual/qemu.html">Using the Quick EMUlator
(QEMU)</a> in Yocto Development Tasks manual.</p>
</blockquote>
<pre><code class="language-bash">runqemu nographic
</code></pre>
<p>After booting up, there will be a prompt to login. Login as <code>root</code>, password won't be required for the default
configuration.</p>
<h3 id="configure-and-run-the-layer-on-raspberry-pi-device"><a class="header" href="#configure-and-run-the-layer-on-raspberry-pi-device">Configure and run the layer on Raspberry Pi device</a></h3>
<p>After successful run in qemu, we can run it on raspberry pi by adjusting our build to a proper architecture.</p>
<p>To do that, we will use <code>meta-raspberrypi</code> layer that we need to fetch and <code>meta-openembedded</code> that we fetched
previously:</p>
<pre><code class="language-bash">git clone -b kirkstone https://github.com/agherzan/meta-raspberrypi.git
</code></pre>
<p>According to the <code>meta-raspberrypi/README.md</code>, we have all the dependencies added to the layer except <code>meta-multimedia</code>
that we need to add with <code>add-layer</code> subcommand. After that, we can add <code>meta-raspberrypi</code> itself:</p>
<pre><code class="language-bash">bitbake-layers add-layer /home/yocto/meta-openembedded/meta-multimedia
bitbake-layers add-layer /home/yocto/meta-raspberrypi
</code></pre>
<p>Next, we open up <code>poky/build/conf/local.conf</code> and find this line:</p>
<pre><code>MACHINE ??= &quot;qemux86-64&quot;
</code></pre>
<p>It denotes which platform we are targeting. Select the one that fits that platform you'd like to build an image for. All
available platforms can be found in <code>meta-raspberrypi/machine/</code> directory. In our case, we target Raspberry Pi 3 in
64-bit mode:</p>
<pre><code>MACHINE = &quot;raspberrypi3-64&quot;
</code></pre>
<p>We can also change the specific configuration of the Raspberry Pi machine. In
<code>meta-raspberrypi/docs/extra-build-config.md</code> we can find a variety of <code>local.conf</code> definitions that you can use to
enable/disable/modify functionality of a device, e.g to access a shell via the UART, add following line to
<code>poky/build/conf/local.conf</code> file:</p>
<pre><code>ENABLE_UART = &quot;1&quot;
</code></pre>
<p>After we finish the configuration, we can build an image using <code>core-image-tedge</code>:</p>
<pre><code class="language-bash">bitbake core-image-tedge
</code></pre>
<p>Once the build is complete, the image will be located in <code>/tmp/deploy/images/$MACHINE/</code> directory where <code>$MACHINE</code>
denotes your target platform. Copy the image to the SD card and run your device.</p>
<blockquote>
<p>To make Yocto run on another hardware, check other layers in the <a href="https://layers.openembedded.org/layerindex/branch/master/layers/">OpenEmbedded Layer
Index</a>.</p>
</blockquote>
<h2 id="further-recommendations"><a class="header" href="#further-recommendations">Further recommendations</a></h2>
<p>After building the reference distribution and image, you can explore creating your own layer and image, and then
integrating <code>tedge-*</code> recipes for it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-management-on-child-devices"><a class="header" href="#configuration-management-on-child-devices">Configuration management on child-devices</a></h1>
<p>After following this tutorial, you will know how to manage various configuration files on child-devices connected to a thin-edge device.
You will learn how to perform the following configuration management operations on child devices:</p>
<ul>
<li>Fetch and view the snapshot of a configuration on a child-device from Cumulocity IoT cloud</li>
<li>Update a configuration on the child-device from Cumulocity IoT cloud</li>
</ul>
<h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>Let's first start with the definition of child-devices.</p>
<p>Thin-edge.io facilitates remote management of the device it is running on, as well as to devices that are connected to that device.</p>
<ul>
<li>the device where thin-edge.io is running on, is referred to as the <strong>main device</strong> or <strong>thin-edge device</strong>.
<ul>
<li>thin-edge.io on the main-device establishes and manages all communication to the cloud.</li>
</ul>
</li>
<li>all devices connected to the main-device are referred to as <strong>external child-devices</strong>.</li>
<li>each external child-device can be represented in the cloud with its individual device twin.
<ul>
<li>a unique <code>child-id</code> makes the association between each external child-device and its <strong>device twin</strong>.</li>
</ul>
</li>
<li>all telemetry data and device management functionality can appear in the context of the
external child-device's device twin.</li>
<li>containers or processes running on the main-device can also act like child-devices and
they are referred to as <strong>logical child-devices</strong>.</li>
</ul>
<p>The figure below illustrates the child-device concept.</p>
<p><img src="tutorials/../architecture/images/device-concept.svg" alt="Device Concept" /></p>
<p>Configuration management can be enabled for child-devices using the same <code>c8y-configuration-plugin</code>,
used for configuration management of the thin-edge device itself.
You can read more about this plugin and its usage <a href="tutorials/../howto-guides/025_config_management_plugin.html">here</a>.</p>
<p>Another piece of software referred to as a <strong>child-device connector</strong> is also required to coordinate configuration management
on the child device from the thin-edge device over the protocol that is used to communicate with it.</p>
<p>The child-device connector would handle the following responsibilities:</p>
<ul>
<li>Declare the supported configuration list to thin-edge.io.</li>
<li>Handle configuration snapshot requests from thin-edge.io.</li>
<li>Handle configuration update requests from thin-edge.io.</li>
</ul>
<p>The <strong>supported configuration list</strong> is the list of configuration files on the child-device that needs to be managed from the cloud. Configuration management by thin-edge.io is enabled only for the files provided in this list.
These declared configuration files can be fetched from the child device with configuration snapshot requests and
can be updated with configuration update requests.</p>
<p>Handling the above-mentioned responsibilities involves multiple interactions with thin-edge.io:</p>
<ul>
<li>via MQTT to receive and respond to configuration management requests.</li>
<li>via HTTP to upload/download files while handling those requests.</li>
</ul>
<p>For example, during the bootstrapping/startup of the child-device, the child-device connector needs to upload the supported configuration list of the child-device to thin-edge.io by uploading a file using the HTTP file-transfer API of thin-edge.io,
followed by an MQTT message informing thin-edge.io that the upload is complete.
Similarly, handling a configuration snapshot or update request involves sending MQTT messages before and after the configuration file is uploaded/downloaded via HTTP to/from thin-edge.io.</p>
<div id="admonition-note" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/child-device-config-management.html#admonition-note"></a></p>
</div>
<div>
<p>The child-device connector is not part of the thin-edge.io installation and must be developed by the device developer.
It can be written in any language that the device developer chooses.
To ease this development, we have written a <a href="https://github.com/thin-edge/thin-edge.io_examples/blob/main/child-device-agent/child_device_agent.py">reference implementation</a> in Python which can easily be adapted directly or replicated in the language of your choice,
for your device type.
The key thing to focus on in the implementation is the interaction with the external device to fetch/update the configuration files over the protocol that the device supports.
The rest of the MQTT and HTTP interactions would remain the same.</p>
</div>
</div>
<p>Since child-device connectors typically run on thin-edge.io device itself, these APIs can be accessed via a local IP or even 127.0.0.1.
In cases where the child-device connector is deployed on the external child-device itself,
the MQTT and HTTP APIs of thin-edge.io need to be accessed over the network using its IP address, 
which is configured using the thin-edge.io configuration settings <code>mqtt.external.bind_address</code> or <code>mqtt.bind_address</code>.
The MQTT APIs are exposed via port 1883 and the HTTP APIs are exposed via port 8000.</p>
<p>In this tutorial 127.0.0.1. is used.</p>
<h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>To follow this tutorial, you only need the following:</p>
<ul>
<li>A <a href="https://www.softwareag.cloud/site/product/cumulocity-iot.html">Cumulocity IoT</a> tenant.</li>
<li>A device where thin-edge.io is installed.
Any device with a Debian-based OS (Raspbian, Ubuntu etc) can be used.
For example, a Raspberry Pi, your development machine or even a virtual machine can be used.</li>
<li>A child-device connector implementation.
You can either use the <a href="https://github.com/thin-edge/thin-edge.io_examples/blob/main/child-device-agent/child_device_agent.py">reference implementation</a> adapted for your child device or develop one on your own.
If you just want to understand the child device connector contract,
you may even manually execute the <code>curl</code> and <code>mosquitto</code> commands shown in the following sections.
To use the <code>mosquitto</code> commands, it must be installed with <code>sudo apt-get install mosquitto-clients</code>.</li>
<li>A device to run the child-device connector on.
It can be run either on the main device itself or on the external child-device.
If you're just running the <code>curl</code> and <code>mosquitto</code> commands directly, they even be run directly from the main device itself.</li>
</ul>
<h1 id="steps-1"><a class="header" href="#steps-1">Steps</a></h1>
<p>This tutorial is divided into 3 main steps:</p>
<p><a href="tutorials/child-device-config-management.html#step-1-bootstrap-the-child-device">Step 1: Bootstrap the child device</a></p>
<p>In this step, a child-device with its supported configuration list will be created in Cumulocity IoT, with the help of thin-edge.io,
during the startup/bootstrap phase of the child-device connector.</p>
<p><a href="tutorials/child-device-config-management.html#step-2-get-configuration-snapshot-from-the-child-device">Step 2: Get configuration snapshot from the child device</a></p>
<p>In this step, configuration files from a child-device will be requested to make them visible in Cumulocity IoT.</p>
<p><a href="tutorials/child-device-config-management.html#step-3-update-configuration-on-the-child-device">Step 3: Update configuration on the child device</a></p>
<p>In this step, configuration files from a child-device will be updated with the updated configuration file pushed from Cumulocity IoT to the child-device via thin-edge.</p>
<div id="admonition-note-1" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/child-device-config-management.html#admonition-note-1"></a></p>
</div>
<div>
<p>The examples in this document uses <code>curl</code> and <code>mosquitto</code> commands just for representational purposes.
In a realistic deployment, the child device connector will be running as a daemon,
performing configuration management operations with thin-edge over its MQTT and HTTP APIs.</p>
</div>
</div>
<h2 id="step-1-bootstrap-the-child-device"><a class="header" href="#step-1-bootstrap-the-child-device">Step 1: Bootstrap the child device</a></h2>
<p>In this step, a child-device with its supported configuration list will be created in Cumulocity using thin-edge.io.</p>
<p>Follow these steps to bootstrap the child device:</p>
<ol>
<li>
<p>Create a <code>c8y-configuration-plugin.toml</code> file that contains the supported configuration list of the child-device 
i.e. a list of configuration files in the same format as specified in the <a href="https://thin-edge.github.io/thin-edge.io/html/howto-guides/025_config_management_plugin.html">configuration management documentation</a> as follows:</p>
<pre><code>files = [
    { path = '/path/to/some/config', type = 'config1'},
]
</code></pre>
<ul>
<li><code>path</code> is the full path to the configuration file on the child-device file system.</li>
<li><code>type</code> is a unique alias for each file entry which will be used to represent that file in Cumulocity IoT.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-toml">files = [
    { path = '/home/pi/config/config1', type = 'config1'},
    { path = '/home/pi/config/config2', type = 'config2'},
]
</code></pre>
<p><em>Update these paths with some realistic paths on your device, or create these files with some dummy content.</em></p>
</li>
</ol>
<div id="admonition-note-2" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/child-device-config-management.html#admonition-note-2"></a></p>
</div>
<div>
<p>This is not the <code>c8y-configuration-plugin.toml</code> file which is used for configuration management of the thin-edge.io main device.
This is a separate file, in the same format, required for each child-device, with its supported configuration list.</p>
</div>
</div>
<ol start="2">
<li>
<p>Upload this file to thin-edge.io via HTTP</p>
<p>The child-device connector needs to upload this file to thin-edge.io with an HTTP PUT request to the URL:
<code>http://{tedge-ip}:8000/tedge/file-transfer/{child-id}/c8y-configuration-plugin</code></p>
<ul>
<li><code>{tedge-ip}</code> is the IP of the thin-edge.io device which is configured as <code>mqtt.external.bind_address</code> or <code>mqtt.bind_address</code> or
<code>127.0.0.1</code> if neither is configured.</li>
<li><code>{child-id}</code> is the child-device-id.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-console">curl -X PUT --data-binary @/home/pi/config/c8y-configuration-plugin.toml http://127.0.0.1:8000/tedge/file-transfer/child1/c8y-configuration-plugin
</code></pre>
</li>
<li>
<p>Notify thin-edge.io about the upload via MQTT.</p>
<p>Once the upload is complete, the connector should notify thin-edge.io about the upload by sending the following MQTT message:</p>
<p><strong>Topic:</strong></p>
<p><code>tedge/{child-d}/commands/res/config_snapshot</code></p>
<p><strong>Payload:</strong> </p>
<pre><code class="language-json">{ &quot;type&quot;: &quot;c8y-configuration-plugin”, &quot;path&quot;: ”/child/local/fs/path” }
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-console">mosquitto_pub -h 127.0.0.1 -t &quot;tedge/child1/commands/res/config_snapshot&quot; -m '{&quot;path&quot;: &quot;&quot;, &quot;type&quot;:&quot;c8y-configuration-plugin&quot;}'
</code></pre>
</li>
<li>
<p>Verify that the configuration list appears in Cumulocity under the child device's <code>Configuration</code> tab
under <code>DEVICE-SUPPORTED CONFIGURATIONS</code> as follows: </p>
<p><img src="tutorials/./images/get-config-snapshot-list.png" alt="get-config-snapshot-list" /></p>
</li>
</ol>
<h2 id="step-2-get-configuration-snapshot-from-the-child-device"><a class="header" href="#step-2-get-configuration-snapshot-from-the-child-device">Step 2: Get configuration snapshot from the child device</a></h2>
<p>Following these steps, a configuration file from the child-device will be requested to make them visible in Cumulocity IoT:</p>
<ol>
<li>
<p>Subscribe to, and receive config snapshot requests via MQTT:</p>
<pre><code class="language-console">mosquitto_sub -h 127.0.0.1 -t &quot;tedge/{child-id}/commands/req/config_snapshot&quot;
</code></pre>
<p>The <code>config_snapshot</code> requests will be received by this subscriber.</p>
</li>
<li>
<p>In Cumulocity IoT, navigate to <code>Device Management</code> -&gt; <code>Devices</code> -&gt; <code>All Devices</code> -&gt; select the thin-edge device -&gt; <code>Child devices</code> -&gt; select the child-device (<code>child1</code>) -&gt; <code>Configuration</code></p>
</li>
<li>
<p>Select the config file type (<code>config1</code>) from the list of configuration files under the <code>DEVICE-SUPPORTED CONFIGURATIONS</code>
and then click on the <code>Get snapshot from device</code> button.</p>
<p><img src="tutorials/./images/get-config-snapshot.png" alt="get-config-snapshot" /></p>
<p>This will trigger a <code>config_snapshot</code> request to the child-device via MQTT which will be received by the subscriber spawned in step. 1 as follows:</p>
<p><strong>Example:</strong></p>
<pre><code class="language-json">{
  &quot;url&quot;:&quot;http://127.0.0.1:8000/tedge/file-transfer/child1/config_snapshot/config1&quot;,
  &quot;path&quot;:&quot;/home/pi/config/config1&quot;,
  &quot;type&quot;:&quot;config1&quot;
}
</code></pre>
</li>
</ol>
<div id="admonition-note-3" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/child-device-config-management.html#admonition-note-3"></a></p>
</div>
<div>
<p>After receiving this request, the responses in the next three steps must be sent within 60 seconds,
else the operation will fail with a timeout.</p>
</div>
</div>
<ol start="4">
<li>
<p>After receiving the request, the child-device connector may <strong>optionally</strong> acknowledge the receipt of the request by sending an &quot;executing&quot; MQTT status message, as follows:</p>
<p><strong>Topic:</strong></p>
<p><code>tedge/{child-d}/commands/res/config_snapshot</code></p>
<p><strong>Payload:</strong></p>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;executing&quot;,
  &quot;type&quot;: &quot;{config-type}&quot;,
  &quot;path&quot;: &quot;/child/local/fs/path&quot;
}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-console">mosquitto_pub -h 127.0.0.1 -t &quot;tedge/child1/commands/res/config_snapshot&quot; -m '{&quot;status&quot;: &quot;executing&quot;, &quot;path&quot;: &quot;/home/pi/config/config1&quot;, &quot;type&quot;: &quot;config1&quot;}'
</code></pre>
</li>
</ol>
<div id="admonition-note-4" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/child-device-config-management.html#admonition-note-4"></a></p>
</div>
<div>
<p>Sending the <code>executing</code> status will reset the operation timeout window.
The timer can be reset any number of times by sending this response.</p>
</div>
</div>
<ol start="5">
<li>
<p>Upload the requested config file to the URL received in the request via HTTP.</p>
<p>After sending the 'executing' status message, the connector must upload the requested configuration file content
to the URL received in the request with an HTTP PUT request.</p>
<pre><code class="language-console">curl -X PUT --data-binary @/home/pi/config/config2 http://127.0.0.1:8000/tedge/file-transfer/child1/config_snapshot/config1
</code></pre>
</li>
<li>
<p>Once the upload is complete, send a &quot;successful&quot; status message via MQTT as follows:</p>
<p><strong>Topic:</strong></p>
<p><code>tedge/{child-d}/commands/res/config_snapshot</code></p>
<p><strong>Payload</strong>:</p>
<pre><code class="language-json">{
    &quot;status&quot;: &quot;successful&quot;,
    &quot;type&quot;: &quot;{config-type}&quot;,
    &quot;path&quot;: &quot;/child/local/fs/path&quot;
}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-console">mosquitto_pub -h localhost -t &quot;tedge/child1/commands/res/config_snapshot&quot; -m '{&quot;status&quot;: &quot;successful&quot;, &quot;path&quot;: &quot;/home/pi/config/config1&quot;, &quot;type&quot;: &quot;config1&quot;}'
</code></pre>
</li>
</ol>
<h2 id="step-3-update-configuration-on-the-child-device"><a class="header" href="#step-3-update-configuration-on-the-child-device">Step 3: Update configuration on the child device</a></h2>
<p>Performing config update is an 8-step process:</p>
<ol>
<li>
<p>Subscribe to, and receive config update requests via MQTT.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-console">mosquitto_sub -h 127.0.0.1 -t &quot;tedge/child1/commands/req/config_update&quot;
</code></pre>
</li>
<li>
<p>In Cumulocity IoT, go to <code>device management</code> -&gt;  <code>Management</code> -&gt; <code>Configuration repository</code> -&gt; <code>Add configuration snapshot</code> and fill in the fields in the pop-up. Uploading a simple text file will be sufficient as an example. Give it the <code>name</code> and <code>type</code> as <strong>config1</strong>.</p>
<p><img src="tutorials/./images/add-config-snapshot.png" alt="add configuration snapshot" /></p>
</li>
<li>
<p>Click on <code>Devices</code> -&gt; <code>All Devices</code>, then click on your device. Then click on  <code>child-devices</code> -&gt;  then click on the child-device (child1) defined in <em>Step 1 Bootstrap the child-device</em> and then click on <code>Configuration</code> and on your config file (config1).</p>
<p><img src="tutorials/./images/add-config-snapshot-configurations.png" alt="open configuration screen" /></p>
</li>
<li>
<p>In the column <em>AVAILABLE SUPPORTED CONFIGURATIONS</em> click on the previously added/uploaded configuration snapshot (config1) and click on <em>Send configuration to device</em>. This will trigger a config snapshot request to the child-device via MQTT.</p>
<p><img src="tutorials/./images/send-config-snapshot-configurations.png" alt="send-configuration-snapshot" /></p>
<p>The subscriber spawned in step 1 will receive the following request on <code>tedge/child1/commands/req/config_update</code> topic.</p>
<pre><code class="language-json">{
  &quot;url&quot;: &quot;http://127.0.0.1:8000/tedge/file-transfer/child1/config_update/config1&quot;,
  &quot;path&quot;: &quot;/home/pi/config/config1&quot;,
  &quot;type&quot;: &quot;config1&quot;
}
</code></pre>
</li>
</ol>
<div id="admonition-note-5" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/child-device-config-management.html#admonition-note-5"></a></p>
</div>
<div>
<p>After receiving this request, the responses in the next three steps must be sent within 60 seconds,
else the operation will fail with a timeout.</p>
</div>
</div>
<ol start="5">
<li>
<p>Optionally send an “executing” operation status update to acknowledge the receipt of the request via MQTT as follows:</p>
<p><strong>Topic:</strong></p>
<p><code>tedge/{child-d}/commands/res/config_update</code></p>
<p><strong>Payload</strong>:</p>
<pre><code class="language-json">{
    &quot;status&quot;: &quot;executing&quot;,
    &quot;type&quot;: &quot;{config-type}&quot;,
    &quot;path&quot;: &quot;/child/local/fs/path&quot;
}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-console">mosquitto_pub -h 127.0.0.1 -t &quot;tedge/child1/commands/res/config_update&quot; -m '{&quot;status&quot;: &quot;executing&quot;, &quot;path&quot;: &quot;/home/pi/config/config1&quot;,    &quot;type&quot;: &quot;config1&quot;}'
</code></pre>
</li>
</ol>
<div id="admonition-note-6" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="tutorials/child-device-config-management.html#admonition-note-6"></a></p>
</div>
<div>
<p>Sending the <code>executing</code> status will reset the operation timeout window.
The timer can be reset any number of times by sending this response.</p>
</div>
</div>
<ol start="6">
<li>
<p>Download the config file update from the URL received in the request via HTTP.</p>
<p>After sending the &quot;executing&quot; status message, the connector must download the configuration file update
from the <code>URL</code> received in the request with an <code>HTTP GET</code> request.
The connector can then apply the downloaded configuration file update on the device.</p>
<pre><code class="language-console">curl http://127.0.0.1:8000/tedge/file-transfer/child1/config_update/config1 --output config1
</code></pre>
</li>
<li>
<p>Apply the config file update on the child-device</p>
<p>The connector can then apply the downloaded configuration file update on the device.</p>
</li>
<li>
<p>Send a “successful” operation status update via MQTT</p>
<p>Once the update is applied, send a &quot;successful&quot; MQTT status message as follows:</p>
<p><strong>Topic:</strong></p>
<p><code>tedge/{child-d}/commands/res/config_update</code></p>
<p><strong>Payload</strong>:</p>
<pre><code class="language-json">{
    &quot;status&quot;: &quot;successful&quot;,
    &quot;type&quot;: &quot;{config-type}&quot;,
    &quot;path&quot;: &quot;/child/local/fs/path&quot;
}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-console">mosquitto_pub -h 127.0.0.1 -t &quot;tedge/child1/commands/res/config_update&quot; -m '{&quot;status&quot;: &quot;successful&quot;, &quot;path&quot;: &quot;/home/pi/config/config1&quot;, &quot;type&quot;: &quot;config1&quot;}'
</code></pre>
<p>If there are any failures while downloading and applying the update, fail the operation in Cumulocity IoT by sending a &quot;failed&quot; status   update with the <code>reason</code> to the same topic as follows:</p>
<pre><code class="language-json">{
    &quot;status&quot;: &quot;failed&quot;,
    &quot;type&quot;: &quot;{config-type}&quot;,
    &quot;path&quot;: &quot;/child/local/fs/path&quot;,
    &quot;reason&quot;: &quot;Download failed&quot;
}
</code></pre>
<p><strong>Example:</strong></p>
<pre><code class="language-console">mosquitto_pub -h 127.0.0.1 -t &quot;tedge/child1/commands/res/config_update&quot; -m '{&quot;status&quot;: &quot;failed&quot;, &quot;reason&quot;: &quot;Download failed&quot;, &quot;path&quot;: &quot;/home/pi/config/config1&quot;, &quot;type&quot;: &quot;config1&quot;}'
</code></pre>
</li>
</ol>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>Configuration Management <a href="https://thin-edge.github.io/thin-edge.io/html/howto-guides/child_device_config_management_agent.html">documentation</a></li>
<li>Reference implementation of a <a href="https://github.com/thin-edge/thin-edge.io_examples/tree/main/child-device-agent">child-device connector</a> written in Python to demonstrate the contract described in this document.</li>
<li>How to enable configuration <a href="https://github.com/thin-edge/thin-edge.io/blob/main/docs/src/howto-guides/child_device_config_management_agent.md">management on child-devices</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-guides"><a class="header" href="#how-to-guides">How-to Guides</a></h1>
<ol>
<li><a href="howto-guides/./002_installation.html">How to install thin-edge.io?</a></li>
<li><a href="howto-guides/./003_registration.html">How to create a test certificate?</a></li>
<li><a href="howto-guides/./004_connect.html">How to connect a cloud end-point?</a></li>
<li><a href="howto-guides/./005_pub_sub.html">How to use <code>tedge mqtt</code> module?</a></li>
<li><a href="howto-guides/./007_test_connection.html">How to test connection to cloud?</a></li>
<li><a href="howto-guides/./007_test_connection.html">How to test the cloud connection?</a></li>
<li><a href="howto-guides/./008_config_local_mqtt_bind_address_and_port.html">How to configure the local mqtt bind address and port?</a></li>
<li><a href="howto-guides/./009_trouble_shooting_monitoring.html">How to trouble shoot device monitoring?</a></li>
<li><a href="howto-guides/./010_add_self_signed_trusted.html">How to add self-signed certificate root to trusted certificates list?</a></li>
<li><a href="howto-guides/./011_retrieve_jwt_token_from_cumulocity.html">How to retrieve JWT token from Cumulocity?</a></li>
<li><a href="howto-guides/./012_install_and_enable_software_management.html">How to install and enable software management?</a></li>
<li><a href="howto-guides/./013_connect_external_device.html">How to connect an external device?</a></li>
<li><a href="howto-guides/./014_thin_edge_logs.html">How to access the logs on the device?</a></li>
<li><a href="howto-guides/./015_installation_without_deb_support.html">How to install thin-edge.io on any Linux OS (no deb support)?</a></li>
<li><a href="howto-guides/./016_restart_device_operation.html">How to restart your thin-edge.io device</a></li>
<li><a href="howto-guides/./017_apama_software_management_plugin.html">How to manage apama software artefatcs with apama plugin?</a></li>
<li><a href="howto-guides/./018_change_temp_path.html">How to change temp path</a></li>
<li><a href="howto-guides/./019_how_to_use_preferred_init_system.html">How to use thin-edge.io with your preferred init system</a></li>
<li><a href="howto-guides/./020_monitor_tedge_health.html">How to monitor health of tedge daemons</a></li>
<li><a href="howto-guides/./021_enable_tedge_watchdog_using_systemd.html">How to enable watchdog using systemd?</a></li>
<li><a href="howto-guides/./022_c8y_fragments.html">How to add custom fragments to Cumulocity</a></li>
<li><a href="howto-guides/./023_c8y_log_plugin.html">How to retrieve logs with the log plugin</a></li>
<li><a href="howto-guides/./024_smartrest_templates.html">How to add C8Y SmartRest Templates</a></li>
<li><a href="howto-guides/./025_config_management_plugin.html">How to manage configuration files with Cumulocity</a></li>
<li><a href="howto-guides/./026_how_to_install_thin_edge_manually.html">How to install thin-edge manually with openrc</a></li>
<li><a href="howto-guides/./child_device_config_management_agent.html">How to enable configuration management on child devices</a></li>
<li><a href="howto-guides/./027_remote_access_with_cumulocity.html">How to remotely connect to your thin-edge.io device via SSH/VNC/Telnet with Cumulocity remote access</a></li>
<li><a href="howto-guides/./028_c8y_service_monitoring.html">How to monitor a service from Cumulocity</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-install-thin-edgeio"><a class="header" href="#how-to-install-thin-edgeio">How to install <code>thin-edge.io</code>?</a></h1>
<h2 id="installation-with-get-thin-edge_iosh-script"><a class="header" href="#installation-with-get-thin-edge_iosh-script">Installation with get-thin-edge_io.sh script</a></h2>
<p>There are two possibilities to install thin-edge.io, the easiest way is to use the installation script with this command:</p>
<pre><code class="language-shell">curl -fsSL https://raw.githubusercontent.com/thin-edge/thin-edge.io/main/get-thin-edge_io.sh | sudo sh -s
</code></pre>
<p>You can execute that command on your device and it will do all required steps for an initial setup.</p>
<blockquote>
<p>Note: If you want to get a specific version, add <code>&lt;version&gt;</code> at the end like below.
<code>&lt;version&gt;</code> is consist of 3 digits, e.g. <code>0.7.3</code>.</p>
<pre><code class="language-shell">curl -fsSL https://raw.githubusercontent.com/thin-edge/thin-edge.io/main/get-thin-edge_io.sh | sudo sh -s &lt;version&gt;
</code></pre>
</blockquote>
<p>If you prefer to have a little more control over the installation or the script did not work for you,
please go on with the <a href="howto-guides/002_installation.html#manual-installation-steps">manual installation steps</a>.</p>
<h2 id="upgrade-thin-edgeio-with-get-thin-edge_iosh-script"><a class="header" href="#upgrade-thin-edgeio-with-get-thin-edge_iosh-script">Upgrade thin-edge.io with get-thin-edge_io.sh script</a></h2>
<p>If you already have <code>thin-edge.io</code> on your device, to upgrade <code>thin-edge.io</code>,
the easiest way is to use the same script as the installation. Follow the steps below.
There is no need to remove old version.</p>
<blockquote>
<p>Note for only <strong>0.7.7 or lower version</strong>: To upgrade <code>thin-edge.io</code> from these versions,
all thin-edge.io components <strong>must be stopped</strong> before upgrading.
The components are:
<code>tedge-mapper-c8y</code>, <code>tedge-mapper-az</code>, <code>tedge-mapper-collectd</code>, <code>tedge-agent</code>, <code>tedge-watchdog</code>, <code>c8y-log-plugin</code>, <code>c8y-configuration-plugin</code>.</p>
<p>To stop <code>tedge-mapper-c8y</code>, <code>tedge-agent</code>, <code>tedge-mapper-az</code>, <code>tedge-mapper-aws</code>, you can simply run the commands below.</p>
<pre><code class="language-shell">sudo tedge disconnect c8y
sudo tedge disconnect az
sudo tedge disconnect aws
</code></pre>
<p>To stop each component one by one, this is an example how to stop them with <code>systemctl</code>:</p>
<pre><code class="language-shell">systemctl stop tedge-mapper-c8y
systemctl stop tedge-agent
systemctl stop c8y-log-plugin
</code></pre>
</blockquote>
<p>Run <code>get-thin-edge_io.sh</code> script as below to upgrade to the latest version.</p>
<pre><code class="language-shell">curl -fsSL https://raw.githubusercontent.com/thin-edge/thin-edge.io/main/get-thin-edge_io.sh | sudo sh -s
</code></pre>
<blockquote>
<p>Note: If you want to upgrade to a specific version, add <code>&lt;version&gt;</code> at the end like below.
<code>&lt;version&gt;</code> is consist of 3 digits, e.g. <code>0.7.3</code>.</p>
<pre><code class="language-shell">curl -fsSL https://raw.githubusercontent.com/thin-edge/thin-edge.io/main/get-thin-edge_io.sh | sudo sh -s &lt;version&gt;
</code></pre>
</blockquote>
<h2 id="thin-edgeio-manual-installation"><a class="header" href="#thin-edgeio-manual-installation">thin-edge.io manual installation</a></h2>
<p>To install thin edge package it is required to use <code>curl</code> to download the package and <code>dpkg</code> to install it.</p>
<h3 id="dependency-installation"><a class="header" href="#dependency-installation">Dependency installation</a></h3>
<p>thin-edge.io has single dependency and it is <code>mosquitto</code> used for communication southbound and northbound e.g. southbound, devices can publish measurements; northbound, gateway may relay messages to cloud.
<code>mosquitto</code> can be installed with your package manager. For apt the command may look as following:</p>
<pre><code class="language-shell">apt install mosquitto
</code></pre>
<blockquote>
<p>Note: Some OSes may require you to use <code>sudo</code> to install packages.</p>
</blockquote>
<pre><code class="language-shell">sudo apt install mosquitto
</code></pre>
<h3 id="thin-edgeio-package-download"><a class="header" href="#thin-edgeio-package-download">thin-edge.io package download</a></h3>
<p>thin-edge.io package is in thin-edge.io repository on GitHub: <a href="https://github.com/thin-edge/thin-edge.io/releases">thin-edge.io</a>.</p>
<p>To download the package from github repository use following command (use desired version):</p>
<pre><code class="language-shell">curl -LJO https://github.com/thin-edge/thin-edge.io/releases/download/&lt;package&gt;_&lt;version&gt;_&lt;arch&gt;.deb
</code></pre>
<p>where:</p>
<blockquote>
<p><code>version</code> -&gt; thin-edge.io version in x.x.x format</p>
<p><code>arch</code> -&gt; architecture type (amd64, armhf, arm64)</p>
</blockquote>
<p>Eg:</p>
<pre><code class="language-shell">curl -LJO https://github.com/thin-edge/thin-edge.io/releases/download/0.9.0/tedge_0.9.0_armhf.deb
</code></pre>
<p>and for <code>mapper</code>:</p>
<pre><code class="language-shell">curl -LJO https://github.com/thin-edge/thin-edge.io/releases/download/0.9.0/tedge-mapper_0.9.0_armhf.deb
</code></pre>
<h3 id="thin-edgeio-package-installation"><a class="header" href="#thin-edgeio-package-installation">thin-edge.io package installation</a></h3>
<p>Now, we have downloaded the package we can proceed to installation. First we will install cli tool <code>tedge</code>.</p>
<blockquote>
<p>Note: Some OSes may require you to use <code>sudo</code> to install packages and therefore all following commands may need <code>sudo</code>.</p>
</blockquote>
<p>To install <code>tedge</code> use following command:</p>
<pre><code class="language-shell">dpkg -i tedge_&lt;version&gt;_&lt;arch&gt;.deb
</code></pre>
<p>Eg:</p>
<pre><code class="language-shell">dpkg -i tedge_0.5.0_armhf.deb
</code></pre>
<p>To install mapper for thin-edge.io do:</p>
<pre><code class="language-shell">dpkg -i tedge-mapper_&lt;version&gt;_&lt;arch&gt;.deb
</code></pre>
<p>Eg:</p>
<pre><code class="language-shell">dpkg -i tedge-mapper_0.9.0_armhf.deb
</code></pre>
<h2 id="uninstall-thin-edgeio"><a class="header" href="#uninstall-thin-edgeio">Uninstall <code>thin-edge.io</code></a></h2>
<p>The <code>thin-edge.io</code> can be uninstalled using a script, that can be downloaded
from below mentioned location.</p>
<p>Whether you are just removing the <code>thin-edge.io</code> packages or wanting to purge everything (removing the packages and configuration), there is a convenient one-liner provided under each section.</p>
<pre><code class="language-shell">wget https://raw.githubusercontent.com/thin-edge/thin-edge.io/main/uninstall-thin-edge_io.sh
chmod a+x uninstall-thin-edge_io.sh
</code></pre>
<p>The uninstall script provides options as shown below.</p>
<pre><code class="language-shell">USAGE: 
   ./uninstall-thin-edge_io.sh [COMMAND]
    
COMMANDS:
    remove     Uninstall thin-edge.io with keeping configuration files
    purge      Uninstall thin-edge.io and also remove configuration files
</code></pre>
<blockquote>
<p>Note: The uninstall script removes/purges the core thin-edge.io packages like <code>tedge, tedge-mapper, and tedge-agent</code> as well as thin-edge.io plugins like <code>tedge-apt-plugin, c8y-log-plugin, c8y-configuration-plugin</code> etc.</p>
</blockquote>
<h3 id="remove-thin-edgeio"><a class="header" href="#remove-thin-edgeio"><code>Remove</code> thin-edge.io</a></h3>
<p>Use uninstall script as shown below just to <code>remove</code> the <code>thin-edge.io</code> packages.</p>
<pre><code class="language-shell">./uninstall-thin-edge_io.sh remove
</code></pre>
<blockquote>
<p>Note: Removes just the thin-edge.io packages and does not remove the <code>configuration</code> files.</p>
</blockquote>
<p>The same thing can also be executed using a one-liner to download and run the script.</p>
<pre><code class="language-shell">curl -sSL https://raw.githubusercontent.com/thin-edge/thin-edge.io/main/uninstall-thin-edge_io.sh | sudo sh -s remove
</code></pre>
<h3 id="purge-thin-edgeio"><a class="header" href="#purge-thin-edgeio"><code>Purge</code> thin-edge.io</a></h3>
<p>Use uninstall script as shown below to remove the thin-edge.io as well as to remove the <code>configuration</code> files that are
associated with these thin-edge.io packages.</p>
<pre><code class="language-shell">./uninstall-thin-edge_io.sh purge
</code></pre>
<p>The same thing can also be executed using a one-liner to download and run the script.</p>
<pre><code class="language-shell">curl -sSL https://raw.githubusercontent.com/thin-edge/thin-edge.io/main/uninstall-thin-edge_io.sh | sudo sh -s purge
</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next steps</a></h2>
<ol>
<li><a href="howto-guides/../tutorials/connect-c8y.html">Connect your device to Cumulocity IoT</a></li>
<li><a href="howto-guides/../tutorials/connect-azure.html">Connect your device to Azure IoT</a></li>
<li><a href="howto-guides/../tutorials/connect-aws.html">Connect your device to AWS IoT</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-register"><a class="header" href="#how-to-register">How to register?</a></h1>
<h2 id="create-self-signed-certificate"><a class="header" href="#create-self-signed-certificate">Create self-signed certificate</a></h2>
<p>To create new certificate you can use <a href="howto-guides/../references/tedge-cert.html"><code>tedge cert create</code></a> thin-edge.io command:</p>
<pre><code class="language-shell">sudo tedge cert create --device-id alpha
</code></pre>
<pre><code>Certificate was successfully created
</code></pre>
<blockquote>
<p>Note: <code>tedge cert</code> requires <code>sudo</code> privilege. This command provides no output on success.</p>
</blockquote>
<p><a href="howto-guides/../references/tedge-cert.html"><code>sudo tedge cert create</code></a> will create certificate in a default location (<code>/etc/tedge/device-certs/</code>).
To use a custom location, refer to <a href="howto-guides/../references/tedge-config.html"><code>tedge config</code></a>.</p>
<p>Now you should have a certificate in the <code>/etc/tedge/device-certs/</code> directory.</p>
<pre><code class="language-shell">ls /etc/tedge/device-certs/
</code></pre>
<pre><code>/etc/tedge/device-certs/tedge-certificate.pem
</code></pre>
<h3 id="errors"><a class="header" href="#errors">Errors</a></h3>
<h4 id="certificate-creation-fails-due-to-invalid-device-id"><a class="header" href="#certificate-creation-fails-due-to-invalid-device-id">Certificate creation fails due to invalid device id</a></h4>
<p>If non-supported characters are used for the device id then the cert create will fail with below error:</p>
<pre><code class="language-plain">Error: failed to create a test certificate for the device +.

Caused by:
    0: DeviceID Error
    1: The string '&quot;+&quot;' contains characters which cannot be used in a name [use only A-Z, a-z, 0-9, ' = ( ) , - . ? % * _ ! @]
</code></pre>
<h4 id="certificate-already-exists-in-the-given-location"><a class="header" href="#certificate-already-exists-in-the-given-location">Certificate already exists in the given location</a></h4>
<p>If the certificate already exists you may see following error:</p>
<pre><code class="language-plain">Error: failed to create a test certificate for the device alpha.

Caused by:
    A certificate already exists and would be overwritten.
            Existing file: &quot;/etc/tedge/device-certs/tedge-certificate.pem&quot;
            Run `tedge cert remove` first to generate a new certificate.
</code></pre>
<blockquote>
<p>Warning! Removing a certificate can break the bridge and more seriously delete a certificate that was a CA-signed certificate.</p>
</blockquote>
<p>Follow the instruction to remove the existing certificate and issue <a href="howto-guides/../references/tedge-cert.html"><code>tedge cert remove</code></a>:</p>
<pre><code class="language-shell">sudo tedge cert remove
</code></pre>
<pre><code>Certificate was successfully removed
</code></pre>
<p>and try <a href="howto-guides/../references/tedge-cert.html"><code>tedge cert create</code></a> once again.</p>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next steps</a></h2>
<ol>
<li><a href="howto-guides/./004_connect.html">How to connect?</a></li>
<li><a href="howto-guides/./005_pub_sub.html">How to use mqtt pub/sub?</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-connect"><a class="header" href="#how-to-connect">How to connect?</a></h1>
<h2 id="connect-to-cumulocity-iot"><a class="header" href="#connect-to-cumulocity-iot">Connect to Cumulocity IoT</a></h2>
<p>To create northbound connection a local bridge shall be established and this can be achieved with <code>tedge</code> cli and following commands:</p>
<blockquote>
<p>Note: <code>tedge connect</code> requires <code>sudo</code> privilege.</p>
</blockquote>
<hr />
<p>Configure required parameters for thin-edge.io with <a href="howto-guides/../references/tedge-config.html"><code>tedge config set</code></a>:</p>
<pre><code class="language-shell">sudo tedge config set c8y.url example.cumulocity.com
</code></pre>
<blockquote>
<p>Tip: If you you are unsure which parameters are required for the command to work run the command and it will tell you which parameters are missing.
For example, if we issue <a href="howto-guides/../references/tedge-connect.html"><code>tedge connect c8y</code></a> without any configuration following advice will be given:</p>
<pre><code class="language-shell">$ tedge connect c8y`
...
Error: failed to execute `tedge connect`.

Caused by:
    Required configuration item is not provided 'c8y.url', run 'tedge config set c8y.url &lt;value&gt;' to add it to config.
</code></pre>
<p>This message explains which configuration parameter is missing and how to add it to configuration, in this case we are told to run <code>tedge config set c8y.url &lt;value&gt;</code>.</p>
</blockquote>
<hr />
<p>The next step is to have the device certificate trusted by Cumulocity. This is done by uploading the certificate of the signee.
You can upload root certificate via <a href="https://cumulocity.com/guides/users-guide/device-management/#trusted-certificates">Cumulocity UI</a> or with <a href="howto-guides/../references/tedge-cert.html"><code>tedge cert upload</code></a> as described below.</p>
<blockquote>
<p>Note: This command takes parameter <code>user</code>, this is due to upload mechanism to Cumulocity cloud which uses username and password for authentication.</p>
<p>After issuing this command you are going to be prompted for a password. Users usernames and passwords are not stored in configuration due to security.</p>
</blockquote>
<pre><code class="language-shell">sudo tedge cert upload c8y --user &lt;username&gt;
</code></pre>
<p>where:</p>
<blockquote>
<p><code>username</code> -&gt; user in Cumulocity with permissions to upload new certificates</p>
</blockquote>
<hr />
<p>To create bridge use <a href="howto-guides/../references/tedge-connect.html"><code>tedge connect</code></a>:</p>
<pre><code class="language-shell">sudo tedge connect c8y
</code></pre>
<pre><code>Checking if systemd is available.

Checking if configuration for requested bridge already exists.

Validating the bridge certificates.

Creating the device in Cumulocity cloud.

Saving configuration for requested bridge.

Restarting mosquitto service.

Awaiting mosquitto to start. This may take up to 5 seconds.

Enabling mosquitto service on reboots.

Successfully created bridge connection!

Sending packets to check connection. This may take up to 2 seconds.

Connection check is successful.

Checking if tedge-mapper is installed.

Starting tedge-mapper-c8y service.

Persisting tedge-mapper-c8y on reboot.

tedge-mapper-c8y service successfully started and enabled!

Enabling software management.

Checking if tedge-agent is installed.

Starting tedge-agent service.

Persisting tedge-agent on reboot.

tedge-agent service successfully started and enabled!
</code></pre>
<h3 id="errors-1"><a class="header" href="#errors-1">Errors</a></h3>
<h4 id="connection-already-established"><a class="header" href="#connection-already-established">Connection already established</a></h4>
<p>If connection has already been established following error may appear:</p>
<pre><code class="language-shell">sudo tedge connect c8y
</code></pre>
<pre><code>Checking if systemd is available.

Checking if configuration for requested bridge already exists.

Error: failed to create bridge to connect Cumulocity cloud.

Caused by:
    Connection is already established. To remove existing connection use 'tedge disconnect c8y' and try again.
</code></pre>
<p>To remove existing connection and create new one follow the advice and issue <a href="howto-guides/../references/tedge-disconnect.html"><code>tedge disconnect c8y</code></a>:</p>
<pre><code class="language-shell">sudo tedge disconnect c8y
</code></pre>
<pre><code>Removing Cumulocity bridge.

Applying changes to mosquitto.

Cumulocity Bridge successfully disconnected!

Stopping tedge-mapper-c8y service.

Disabling tedge-mapper-c8y service.

tedge-mapper-c8y service successfully stopped and disabled!

Stopping tedge-agent service.

Disabling tedge-agent service.

tedge-agent service successfully stopped and disabled!
</code></pre>
<blockquote>
<p>Note: <code>tedge disconnect c8y</code> also stops and disable <strong>tedge-mapper</strong> service if it is installed on the device.</p>
</blockquote>
<p>And now you can issue <a href="howto-guides/../references/tedge-connect.html"><code>tedge connect c8y</code></a> to create new bridge.</p>
<h4 id="connection-check-warning"><a class="header" href="#connection-check-warning">Connection check warning</a></h4>
<p>Sample output of tedge connect when this warning occurs:</p>
<pre><code class="language-shell">sudo tedge connect c8y
</code></pre>
<pre><code>Checking if systemd is available.

Checking if configuration for requested bridge already exists.

Validating the bridge certificates.

Creating the device in Cumulocity cloud.

Saving configuration for requested bridge.

Restarting mosquitto service.

Awaiting mosquitto to start. This may take up to 5 seconds.

Enabling mosquitto service on reboots.

Successfully created bridge connection!

Sending packets to check connection. This may take up to 2 seconds.

ERROR: Local MQTT publish has timed out.
Warning: Bridge has been configured, but Cumulocity connection check failed.

Checking if tedge-mapper is installed.

Starting tedge-mapper-c8y service.

Persisting tedge-mapper-c8y on reboot.

tedge-mapper-c8y service successfully started and enabled!

Enabling software management.

Checking if tedge-agent is installed.

Starting tedge-agent service.

Persisting tedge-agent on reboot.

tedge-agent service successfully started and enabled!
</code></pre>
<p>This warning may be caused by some of the following reasons:</p>
<ul>
<li>No access to Internet connection</li>
</ul>
<p>Local bridge has been configured and is running but the connection check has failed due to no access to the northbound endpoint.</p>
<ul>
<li>Cumulocity tenant not available</li>
</ul>
<p>Tenant couldn't be reached and therefore connection check has failed.</p>
<ul>
<li>Check bridge</li>
</ul>
<p>Bridge configuration is correct but the connection couldn't be established to unknown reason.</p>
<p>To retry start with <a href="howto-guides/../references/tedge-disconnect.html"><code>tedge disconnect c8y</code></a> removing this bridge:</p>
<pre><code class="language-shell">sudo tedge disconnect c8y
</code></pre>
<p>When this is done, issue <a href="howto-guides/../references/tedge-connect.html"><code>tedge connect c8y</code></a> again.</p>
<h4 id="file-permissions"><a class="header" href="#file-permissions">File permissions</a></h4>
<p>Sample output:</p>
<pre><code class="language-shell">tedge connect c8y
</code></pre>
<pre><code>Checking if systemd is available.

Checking if configuration for requested bridge already exists.

Validating the bridge certificates.

Saving configuration for requested bridge.

Error: failed to create bridge to connect Cumulocity cloud.

Caused by:
    0: File Error. Check permissions for /etc/tedge/mosquitto-conf/tedge-mosquitto.conf.
    1: failed to persist temporary file: Permission denied (os error 13)
    2: Permission denied (os error 13)
</code></pre>
<p>tedge connect cannot access location to create the bridge configuration (<code>/etc/tedge/mosquitto-conf</code>), check permissions for the directory and adjust it to allow the tedge connect to access it.</p>
<p>Example of incorrect permissions:</p>
<pre><code class="language-shell">ls -l /etc/tedge
</code></pre>
<pre><code>dr--r--r-- 2 tedge     tedge     4096 Mar 30 15:40 mosquitto-conf
</code></pre>
<p>You should give it the permission 755.</p>
<pre><code class="language-shell">ls -l /etc/tedge
</code></pre>
<pre><code>drwxr-xr-x 2 tedge     tedge     4096 Mar 30 15:40 mosquitto-conf
</code></pre>
<h4 id="mosquitto-and-systemd-check-fails"><a class="header" href="#mosquitto-and-systemd-check-fails">mosquitto and systemd check fails</a></h4>
<p>Sample output:</p>
<pre><code class="language-shell">sudo tedge connect c8y
</code></pre>
<pre><code>Checking if systemd is available.

Checking if configuration for requested bridge already exists.

Validating the bridge certificates.

Saving configuration for requested bridge.

Restarting mosquitto service.

Error: failed to create bridge to connect Cumulocity cloud.

Caused by:
    Service mosquitto not found. Install mosquitto to use this command.
</code></pre>
<p>mosquitto server has not been installed on the system and it is required to run this command, refer to <a href="howto-guides/./002_installation.html">How to install thin-edge.io?</a> to install mosquitto and try again.</p>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next steps</a></h2>
<ol>
<li><a href="howto-guides/./005_pub_sub.html">How to use mqtt pub/sub?</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-tedge-mqtt-pub-and-sub"><a class="header" href="#how-to-use-tedge-mqtt-pub-and-sub">How to use <a href="howto-guides/../references/tedge-mqtt.html"><code>tedge mqtt</code></a> pub and sub?</a></h1>
<p>thin-edge.io cli provides a convenient way to debug and aid development process.</p>
<h2 id="publish"><a class="header" href="#publish">Publish</a></h2>
<p>Command <a href="howto-guides/../references/tedge-mqtt.html"><code>tedge mqtt pub</code></a> can be used to publish MQTT messages on a topic to the local mosquitto server.</p>
<p>Example:</p>
<pre><code class="language-shell">tedge mqtt pub 'tedge/measurements' '{ &quot;temperature&quot;: 21.3 }'
</code></pre>
<p><code>tedge mqtt pub</code> supports setting of QoS for MQTT messages:</p>
<pre><code class="language-shell">tedge mqtt pub 'tedge/measurements' '{ &quot;temperature&quot;: 21.3 }' --qos 2
</code></pre>
<p><code>tedge mqtt pub</code> supports publishing a MQTT message with retain flag:</p>
<pre><code class="language-shell">tedge mqtt pub --retain --qos 1 tedge/alarms/critical/high_temperature '{&quot;message&quot;: &quot;Temperature is critical&quot;}'
</code></pre>
<p>Note: By default the mqtt message will be published with retain flag set to false.</p>
<h2 id="subscribe"><a class="header" href="#subscribe">Subscribe</a></h2>
<p>Command <a href="howto-guides/../references/tedge-mqtt.html"><code>tedge mqtt sub</code></a> can be used to ease debugging of of MQTT communication on local bridge. You can subscribe to topic of your choosing:</p>
<pre><code class="language-shell">tedge mqtt sub tedge/errors
</code></pre>
<p>Or you can subscribe to any topic on the server using wildcard (<code>#</code>) topic:</p>
<pre><code class="language-shell">tedge mqtt sub '#'
</code></pre>
<p>Now use <code>tedge mqtt pub 'tedge/measurements' '{ &quot;temperature&quot;: 21.3 }'</code> to publish message on <code>tedge/measurements</code> topic with payload <code>{ &quot;temperature&quot;: 21.3 }</code>.</p>
<p>All messages from sub command are printed to <code>stdout</code> and can be captured to a file if you need to:</p>
<pre><code class="language-shell">tedge mqtt sub '#' &gt; filename.mqtt
</code></pre>
<p>Wildcard (<code>#</code>) topic is used by <a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901242">MQTT protocol</a> as a wildcard and will listen on all topics</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-test-the-connection-to-cloud"><a class="header" href="#how-to-test-the-connection-to-cloud">How to test the connection to cloud?</a></h1>
<p>We provide a way to test the connection from your device to a cloud provider.
You can call this connection check function by</p>
<pre><code class="language-shell">sudo tedge connect &lt;cloud&gt; --test
</code></pre>
<p>It returns exit code 0 if the connection check is successful, otherwise, 1.</p>
<p>This test is already performed as part of the <code>tedge connect &lt;cloud&gt;</code> command.</p>
<h2 id="what-does-the-test-do"><a class="header" href="#what-does-the-test-do">What does the test do?</a></h2>
<p>The connection test sends a message to the cloud and waits for a response.
The subsequent sections explain the cloud-specific behaviour.</p>
<h3 id="for-cumulocity-iot"><a class="header" href="#for-cumulocity-iot">For Cumulocity IoT</a></h3>
<p>The test publishes <a href="https://cumulocity.com/guides/device-sdk/mqtt/#a-nameinventory-templatesinventory-templates-1xxa">a SmartREST2.0 static template message for device creation <code>100</code></a> to the topic <code>c8y/s/us</code>.
If the device-twin is already created in your Cumulocity,
the device is supposed to receive <code>41,100,Device already existing</code> on the error topic <code>c8y/s/e</code>.</p>
<p>So, the test subscribes to <code>c8y/s/e</code> topic and if it receives the expected message on the topic, the test is marked successful.</p>
<p>The connection test sends maximum two of SmartREST2.0 <code>100</code> requests.
This is because the first <code>100</code> request can be considered a successful device creation request if the device-twin does not exist in Cumulocity yet.</p>
<h3 id="for-azure-iot-hub"><a class="header" href="#for-azure-iot-hub">For Azure IoT Hub</a></h3>
<p>The test subscribes to the topic <code>az/twin/res/</code>.
Then, it publishes an empty string to the topic <code>az/twin/GET/?$rid=1</code>. </p>
<p>If the connection check receives a message containing <code>200</code> (status success), the test is marked successful.</p>
<p>The connection test sends the empty string only once.</p>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next steps</a></h2>
<ol>
<li><a href="howto-guides/./005_pub_sub.html">How to use mqtt pub/sub?</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-configure-the-local-port-and-bind-address-in-mosquitto"><a class="header" href="#how-to-configure-the-local-port-and-bind-address-in-mosquitto">How to configure the local port and bind address in mosquitto?</a></h1>
<p>Configuring a mosquitto port and bind address in thin-edge.io is a three-step process.</p>
<blockquote>
<p>Note: The mqtt.port and the mqtt.bind_address can be set/unset independently.</p>
</blockquote>
<h2 id="step-1-disconnect-thin-edgeio-edge-device"><a class="header" href="#step-1-disconnect-thin-edgeio-edge-device">Step 1: Disconnect thin-edge.io edge device</a></h2>
<p>The thin edge device has to be disconnected from the cloud using the <code>tedge</code> command</p>
<pre><code class="language-shell">tedge disconnect c8y/az
</code></pre>
<h2 id="step-2-set-and-verify-the-new-mqtt-port-and-bind-address"><a class="header" href="#step-2-set-and-verify-the-new-mqtt-port-and-bind-address">Step 2: Set and verify the new mqtt port and bind address</a></h2>
<p>Use the <code>tedge</code> command to set the mqtt.port and mqtt.bind_address with a desired port and bind address as below.</p>
<pre><code class="language-shell">tedge config set mqtt.port 1024
</code></pre>
<pre><code class="language-shell">tedge config set mqtt.bind_address 127.0.0.1
</code></pre>
<blockquote>
<p>Note: The bind_address is the address of the one of the device interface.
For example this can be get as <code>ifconfig | grep inet</code> or set it to <code>0.0.0.0</code></p>
</blockquote>
<p>This will make sure that all the mqtt clients use the newer port and the bind address that
has been set once the device is connected to the cloud as in step 3.</p>
<h2 id="verify-the-port-and-the-bind-address-configuredset"><a class="header" href="#verify-the-port-and-the-bind-address-configuredset">Verify the port and the bind address configured/set</a></h2>
<p>Use the <code>tedge</code> command to print the mqtt port and bind address that has been set as below.</p>
<pre><code class="language-shell">tedge config get mqtt.port
</code></pre>
<pre><code class="language-shell">tedge config get mqtt.bind_address
</code></pre>
<h2 id="step-3-connect-the-thin-edge-device-to-cloud"><a class="header" href="#step-3-connect-the-thin-edge-device-to-cloud">Step 3: Connect the thin edge device to cloud</a></h2>
<p>Use the <code>tedge</code> command to connect to the desired cloud as below.</p>
<pre><code class="language-shell">tedge connect c8y

#or

tedge connect az

#or

tedge connect aws
</code></pre>
<p>This will configure all the services (mosquitto, tedge-mapper-c8y.service, tedge-mapper-az.service,
tedge-mapper-aws.service, tedge-agent.service) to use the newly set port and the bind address.</p>
<p>Note: The step 1 and 2 can be followed in any order.</p>
<h2 id="update-to-use-default-port-and-bind-address"><a class="header" href="#update-to-use-default-port-and-bind-address">Update to use default port and bind address</a></h2>
<p>Use the <code>tedge</code> command to set the default port (1883) and default bind address (localhost) as below.</p>
<pre><code class="language-shell">tedge config unset mqtt.port
</code></pre>
<pre><code class="language-shell">tedge config unset mqtt.bind_address
</code></pre>
<p>Once the port or the bind address is reverted to default, the <a href="howto-guides/008_config_local_mqtt_bind_address_and_port.html#Step-3:-Connect-the-thin-edge-device-to-cloud">step 1</a>
and 3 has to be followed to use the default port or the default bind address.</p>
<h2 id="error-case"><a class="header" href="#error-case">Error case</a></h2>
<p>The below example shows that we cannot set a string value for the port number.</p>
<pre><code class="language-shell">tedge config set mqtt.port '&quot;1234&quot;'

Error: failed to set the configuration key: mqtt.port with value: &quot;1234&quot;.

Caused by:
    Conversion from String failed
</code></pre>
<h2 id="updating-the-mqtt-port-and-bind-address-host-in-collectd--for-collectd-mapper"><a class="header" href="#updating-the-mqtt-port-and-bind-address-host-in-collectd--for-collectd-mapper">Updating the mqtt port and bind address (host) in collectd &amp; for collectd-mapper</a></h2>
<p>Update the <code>collectd.conf</code> with the new port and host in <code>&lt;Plugin mqtt&gt;</code>.</p>
<p>Then, restart the collectd service.</p>
<pre><code class="language-shell">sudo systemctl restart collectd.service
</code></pre>
<p>After changing the mqtt port and host, then connect to the cloud using <code>tedge connect c8y/az</code>.
Then (Steps 1-3) the collectd-mapper has to be restarted to use the newly set port and bind address (host).</p>
<p>Restart the tedge-mapper-collectd service.</p>
<pre><code class="language-shell">sudo systemctl restart tedge-mapper-collectd.service
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-trouble-shoot-device-monitoring"><a class="header" href="#how-to-trouble-shoot-device-monitoring">How to trouble shoot device monitoring</a></h1>
<p>To install and configure monitoring on your device,
see the tutorial <a href="howto-guides/../tutorials/device-monitoring.html">Monitor your device with collectd</a>.</p>
<h2 id="is-collectd-running"><a class="header" href="#is-collectd-running">Is collectd running?</a></h2>
<pre><code>sudo systemctl status collectd
</code></pre>
<p>If not, launch collected</p>
<pre><code>sudo systemctl start collectd
</code></pre>
<h2 id="is-collectd-publishing-mqtt-messages"><a class="header" href="#is-collectd-publishing-mqtt-messages">Is collectd publishing MQTT messages?</a></h2>
<pre><code>tedge mqtt sub 'collectd/#'
</code></pre>
<p>If no metrics are collected, please check the <a href="howto-guides/../tutorials/device-monitoring.html#collectdconf">MQTT configuration</a></p>
<h2 id="is-the-tedge-mapper-collectdservice-running"><a class="header" href="#is-the-tedge-mapper-collectdservice-running">Is the <code>tedge-mapper-collectd.service</code> running?</a></h2>
<pre><code>sudo systemctl status tedge-mapper-collectd.service
</code></pre>
<p>If not, launch tedge-mapper-collectd.service as below</p>
<pre><code>sudo systemctl start tedge-mapper-collectd.service
</code></pre>
<h2 id="are-the-collectd-metrics-published-in-thin-edge-json-format"><a class="header" href="#are-the-collectd-metrics-published-in-thin-edge-json-format">Are the collectd metrics published in Thin Edge JSON format?</a></h2>
<pre><code>tedge mqtt sub 'tedge/measurements'
</code></pre>
<h2 id="are-the-collectd-metrics-published-to-cumulocity-iot"><a class="header" href="#are-the-collectd-metrics-published-to-cumulocity-iot">Are the collectd metrics published to Cumulocity IoT?</a></h2>
<pre><code>tedge mqtt sub 'c8y/#'
</code></pre>
<p>If not see how to <a href="howto-guides/../tutorials/connect-c8y.html">connect a device to Cumulocity IoT</a></p>
<h2 id="are-the-collectd-metrics-published-to-azure-iot"><a class="header" href="#are-the-collectd-metrics-published-to-azure-iot">Are the collectd metrics published to Azure IoT?</a></h2>
<pre><code>tedge mqtt sub 'az/#'
</code></pre>
<p>If not see how to <a href="howto-guides/../tutorials/connect-azure.html">connect a device to Azure IoT</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-add-self-signed-certificate-to-trusted-certificates-list"><a class="header" href="#how-to-add-self-signed-certificate-to-trusted-certificates-list">How to add self-signed certificate to trusted certificates list</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>If the server you are trying to connect <code>thin-edge.io</code> to is presenting a certificate with a root that is not currently trusted, then you can add the server's root certificate to the list of trusted root certificates.
For the most part the store will be filled with certificates from your TLS/SSL provider, but when you want to use self-signed certificates you may need to update your local certificate store.
Below are instructions on how to add new CA certificate and update the certificate store.</p>
<blockquote>
<p>Please note: Provided instructions are for supported OSes and may not apply to the flavour you are running, if you need help with other OS please consult appropriate documentation.</p>
</blockquote>
<h2 id="ubuntu-and-raspberry-pi-os"><a class="header" href="#ubuntu-and-raspberry-pi-os">Ubuntu and Raspberry Pi OS</a></h2>
<blockquote>
<p>If you do not have the <code>ca-certificates</code> package installed on your system, install it with your package manager.</p>
<pre><code class="language-shell">sudo apt install ca-certificates
</code></pre>
</blockquote>
<p>To add a self-signed certificate to the trusted certificate repository on thin-edge.io system:</p>
<p>Create a <code>/usr/local/share/ca-certificates/</code> directory if it does not exist on your computer:</p>
<pre><code class="language-shell">sudo mkdir /usr/local/share/ca-certificates/
</code></pre>
<p>The directory should be owned by <code>root:root</code> and have <code>755</code> permissions set for it. The certificates files should be <code>644</code>.</p>
<p>Copy your root certificate (in <code>PEM</code> format with <code>.crt</code> extension) to the created directory:</p>
<pre><code class="language-shell">sudo cp &lt;full_path_to_the_certificate&gt; /usr/local/share/ca-certificates/
</code></pre>
<p>Install the certificates:</p>
<pre><code class="language-shell">sudo update-ca-certificates
</code></pre>
<pre><code>Updating certificates in /etc/ssl/certs...
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d...
done.
</code></pre>
<p>To check the certificate was correctly installed:</p>
<pre><code class="language-shell">sudo ls /etc/ssl/certs | grep &lt;certificate_name&gt;
</code></pre>
<p>Additionally you can check correctness of the installed certificate:</p>
<pre><code class="language-shell">sudo cat /etc/ssl/certs/ca-certificates.crt | grep -f &lt;full_path_to_the_certificate&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-to-retrieve-a-jwt-token-to-authenticate-on-cumulocity"><a class="header" href="#how-to-retrieve-a-jwt-token-to-authenticate-on-cumulocity">How to retrieve a JWT Token to authenticate on Cumulocity</a></h2>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>In order to <a href="https://cumulocity.com/guides/10.5.0/reference/rest-implementation/#authentication">authenticate HTTP requests on Cumulocity</a>,
a device can retrieve a JWT token using MQTT.</p>
<h2 id="retrieving-the-token"><a class="header" href="#retrieving-the-token">Retrieving the token</a></h2>
<p>Follow the below steps in order to retrieve the token from the Cumulocity cloud using MQTT.</p>
<p>Subscribe to <code>c8y/s/dat</code> topic</p>
<pre><code>tedge mqtt sub c8y/s/dat --no-topic
</code></pre>
<p>Publish an empty message on <code>c8y/s/uat</code> topic</p>
<pre><code>tedge mqtt pub c8y/s/uat ''
</code></pre>
<p>After a while the token will be published on the subscribed topic <code>c8y/s/dat</code> in the below format</p>
<p>71,[Base64 encoded JWT token]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-and-enable-the-software-management-feature"><a class="header" href="#install-and-enable-the-software-management-feature">Install and enable the software management feature</a></h1>
<blockquote>
<p>Note: As of now, this feature is supported only on devices with <strong>debian</strong> based
distributions, which use the <strong>apt</strong> package manager(Ex: RaspberryPi OS , Ubuntu, Debian), from Cumulocity cloud.</p>
</blockquote>
<p>Below steps show how to download, install and enable thin-edge software management feature.</p>
<h2 id="download-and-install-software-management-packages-on-the-device"><a class="header" href="#download-and-install-software-management-packages-on-the-device">Download and install software management packages on the device</a></h2>
<p>As a prerequisite, install <a href="howto-guides/../howto-guides/002_installation.html">tedge and tedge-mapper</a> if not installed already.</p>
<p>The thin-edge software management packages are in repository on GitHub: <a href="https://github.com/thin-edge/thin-edge.io/releases">thin-edge.io</a>.</p>
<p>To download the package from github repository use the following command (use desired version):</p>
<pre><code class="language-shell">curl -LJO https://github.com/thin-edge/thin-edge.io/releases/download/&lt;package&gt;_&lt;version&gt;_&lt;arch&gt;.deb
</code></pre>
<p>where:</p>
<blockquote>
<p><code>version</code> -&gt; thin-edge.io software management components version in x.x.x format</p>
<p><code>arch</code> -&gt; architecture type (amd64, armhf)</p>
</blockquote>
<p>Download <code>tedge-apt-plugin</code> and <code>tedge-agent</code></p>
<pre><code class="language-shell">curl -LJO https://github.com/thin-edge/thin-edge.io/releases/download/0.9.0/tedge-apt-plugin_0.9.0_armhf.deb
curl -LJO https://github.com/thin-edge/thin-edge.io/releases/download/0.9.0/tedge-agent_0.9.0_armhf.deb
</code></pre>
<p>Once the packages are downloaded, proceed to installation.</p>
<p>To install <code>tedge-apt-plugin</code> and <code>tedge-agent</code> on thin-edge device do:</p>
<pre><code class="language-shell">sudo dpkg -i tedge-apt-plugin_&lt;version&gt;_&lt;arch&gt;.deb
sudo dpkg -i tedge-agent_&lt;version&gt;_&lt;arch&gt;.deb
</code></pre>
<blockquote>
<p>Note: Software management feature will be enabled after installation if the device
is connected to the Cumulocity cloud using <code>tedge connect c8y</code>.</p>
</blockquote>
<h2 id="start-and-enable-the-software-management-feature"><a class="header" href="#start-and-enable-the-software-management-feature">Start and enable the software management feature</a></h2>
<h3 id="using-tedge-connect-c8y"><a class="header" href="#using-tedge-connect-c8y">Using <code>tedge connect c8y</code></a></h3>
<p>The <code>tedge connect c8y</code> will automatically start and enable the software management feature.
Find more about <a href="howto-guides/../howto-guides/004_connect.html">how to connect thin-edge device to cloud</a></p>
<p>Once the thin-edge device is successfully connected to Cumulocity cloud, the <strong>Software</strong> option will be enabled and
the list of software that are installed on the device will be visible as shown in the figure below.</p>
<p><img src="howto-guides/./images/start-software-management.png" alt="Add new software" /></p>
<blockquote>
<p>Note: Disconnecting thin-edge device from cloud with <code>tedge disconnect c8y</code> command will stop and disable the software management feature.</p>
</blockquote>
<h3 id="manually-enabling-and-disabling-software-management-feature"><a class="header" href="#manually-enabling-and-disabling-software-management-feature">Manually enabling and disabling software management feature</a></h3>
<p>For debugging purpose or to disable/enable the software management services, one can start/stop manually as shown below.</p>
<h3 id="starting-the-services"><a class="header" href="#starting-the-services">Starting the services</a></h3>
<pre><code class="language-shell">sudo systemctl start tedge-agent.service
sudo systemctl start tedge-mapper-c8y.service
</code></pre>
<h3 id="stopping-the-services"><a class="header" href="#stopping-the-services">Stopping the services</a></h3>
<pre><code class="language-shell">sudo systemctl stop tedge-agent.service
sudo systemctl stop tedge-mapper-c8y.service
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connecting-an-external-device-to-thin-edgeio"><a class="header" href="#connecting-an-external-device-to-thin-edgeio">Connecting an external device to <code>thin-edge.io</code></a></h1>
<p>With <code>thin-edge.io</code> you can enable connection for external devices to your <code>thin-edge.io</code> enabled device with the use of a few commands.</p>
<blockquote>
<p>Note: Currently, only one additional listener can be defined.</p>
</blockquote>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>External devices connection can be setup by using the <code>tedge</code> cli tool making some changes to the configuration.</p>
<p>The following configurations option are available for you if you want to add an external listener to thin-edge.io:</p>
<p><code>mqtt.external.port</code>             Mqtt broker port, which is used by the external mqtt clients to publish or subscribe. Example: 8883
<code>mqtt.external.bind_address</code>     IP address / hostname, which the mqtt broker limits incoming connections on. Example: 0.0.0.0
<code>mqtt.external.bind_interface</code>   Name of network interface, which the mqtt broker limits incoming connections on. Example: wlan0</p>
<p><code>mqtt.external.capath</code>           Path to a file containing the PEM encoded CA certificates that are trusted when checking incoming client certificates. Example: /etc/ssl/certs
<code>mqtt.external.certfile</code>         Path to the certificate file, which is used by external MQTT listener. Example: /etc/tedge/server-certs/tedge-certificate.pem
<code>mqtt.external.keyfile</code>          Path to the private key file, which is used by external MQTT listener. Example: /etc/tedge/server-certs/tedge-private-key.pem</p>
<blockquote>
<p>If none of these options is set, then no external listener is set.
If one of these options is set, then default values are inferred by the MQTT server (Mosquitto). For instance, the port defaults to 1883 for a non-TLS listener, and to 8883 for a TLS listener.</p>
</blockquote>
<p>These settings can be considered in 2 groups, listener configuration and TLS configuration.</p>
<h3 id="configure-basic-listener"><a class="header" href="#configure-basic-listener">Configure basic listener</a></h3>
<p>To configure basic listener you should provide port and/or bind address which will use default interface.
To change the default interface you can use mqtt.external.bind_interface configuration option.</p>
<p>To set them you can use <code>tedge config</code> as so:</p>
<pre><code class="language-shell">tedge config set mqtt.external.port 8883
</code></pre>
<p>To allow connections from all IP addresses on the interface:</p>
<pre><code class="language-shell">tedge config set mqtt.external.bind_address 0.0.0.0
</code></pre>
<h3 id="configure-tls-on-the-listener"><a class="header" href="#configure-tls-on-the-listener">Configure TLS on the listener</a></h3>
<p>To configure the external listener with TLS additional settings are available: <code>mqtt.external.capath</code> <code>mqtt.external.certfile</code> <code>mqtt.external.keyfile</code></p>
<p>To enable MQTT over TLS, a server side certificate must be configured using the 2 following settings:</p>
<pre><code class="language-shell">tedge config set mqtt.external.certfile /etc/tedge/server-certs/tedge-certificate.pem
tedge config set mqtt.external.keyfile /etc/tedge/server-certs/tedge-private-key.pem
</code></pre>
<p>To fully enable TLS authentication clients, client side certificate validation can be enabled:</p>
<pre><code class="language-shell">tedge config set mqtt.external.capath /etc/ssl/certs
</code></pre>
<blockquote>
<p>Note: Providing all 3 configuration will trigger thin-edge.io to require client certificates.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-thin-edge-logs"><a class="header" href="#the-thin-edge-logs">The thin-edge logs</a></h1>
<p>The logs that are useful for debugging thin-edge.io break down into logs that are created by thin-edge itself and by third party components.</p>
<h2 id="thin-edge-logs"><a class="header" href="#thin-edge-logs">Thin-edge logs</a></h2>
<p>On a thin-edge device different components like mappers, agent, and plugins run. The log messages of these components can be accessed as below.
The logs here capture INFO, WARNING, and ERROR messages.</p>
<h3 id="cloud-mapper-logs"><a class="header" href="#cloud-mapper-logs">Cloud mapper logs</a></h3>
<p>The thin-edge cloud mapper component that sends the measurement data to the cloud can be accessed as below.</p>
<h4 id="tedge-cumulocity-mapper"><a class="header" href="#tedge-cumulocity-mapper">Tedge Cumulocity mapper</a></h4>
<p>The log messages of the Cumulocity mapper component that sends the measurement data from the thin-edge device to the Cumulocity
cloud can be accessed as below</p>
<p><code>journalctl -u tedge-mapper-c8y.service</code></p>
<blockquote>
<p>Note: Run <code>tedge-mapper --debug c8y</code> to log more debug messages</p>
</blockquote>
<h4 id="tedge-azure-mapper"><a class="header" href="#tedge-azure-mapper">Tedge Azure mapper</a></h4>
<p>The log messages of the Azure mapper component that sends the measurement data from the thin-edge device to the Azure
cloud can be accessed as below.</p>
<p><code>journalctl -u tedge-mapper-az.service</code></p>
<blockquote>
<p>Note: Run <code>tedge-mapper --debug az</code> to log more debug messages</p>
</blockquote>
<h4 id="tedge-aws-mapper"><a class="header" href="#tedge-aws-mapper">Tedge AWS mapper</a></h4>
<p>The log messages of the AWS mapper component that sends the measurement data from the thin-edge device to the AWS
cloud can be accessed as below.</p>
<p><code>journalctl -u tedge-mapper-aws.service</code></p>
<blockquote>
<p>Note: Run <code>tedge_mapper --debug aws</code> to log more debug messages</p>
</blockquote>
<h3 id="device-monitoring-logs"><a class="header" href="#device-monitoring-logs">Device monitoring logs</a></h3>
<p>The thin-edge device monitoring component logs can be found as below</p>
<h4 id="collectd-mapper-logs"><a class="header" href="#collectd-mapper-logs">Collectd mapper logs</a></h4>
<p>The log messages of the collectd mapper that sends the monitoring data to the cloud can be accessed as below</p>
<p><code>journalctl -u tedge-mapper-collectd.service</code></p>
<blockquote>
<p>Note: Run <code>tedge-mapper --debug collectd</code> to log more debug messages</p>
</blockquote>
<h3 id="software-management-logs"><a class="header" href="#software-management-logs">Software Management logs</a></h3>
<p>This section describes how to access the software management component logs</p>
<h4 id="software-update-operation-log"><a class="header" href="#software-update-operation-log">Software update operation log</a></h4>
<p>For every new software operation (list/update), a new log file will be created at <code>/var/log/tedge/agent</code>.
For each <code>plugin command</code> like prepare, update-list (install, remove), finalize, and list,
the log file captures <code>exit status, stdout, and stderr</code> messages.</p>
<h4 id="tedge-agent-logs"><a class="header" href="#tedge-agent-logs">Tedge Agent logs</a></h4>
<p>The agent service logs can be accessed as below</p>
<p><code>journalctl -u tedge-agent.service</code></p>
<p>For example: tedge-agent logs plugin calls finalize and list.</p>
<p>tedge-agent : TTY=unknown ; PWD=/tmp ; USER=root ; COMMAND=/etc/tedge/sm-plugins/apt finalize</p>
<p>tedge-agent : TTY=unknown ; PWD=/tmp ; USER=root ; COMMAND=/etc/tedge/sm-plugins/apt list</p>
<blockquote>
<p>Note: Run <code>tedge-agent --debug</code> to log more debug messages</p>
</blockquote>
<h2 id="thirdparty-component-logs"><a class="header" href="#thirdparty-component-logs">Thirdparty component logs</a></h2>
<p>Thin-edge uses the third-party components <code>Mosquitto</code> as the mqtt broker and <code>Collectd</code> for monitoring purpose.
The logs that are created by these components can be accessed on a thin-edge device as below.</p>
<h3 id="mosquitto-logs"><a class="header" href="#mosquitto-logs">Mosquitto logs</a></h3>
<p>Thin-edge uses <code>Mosquitto</code> as the <code>mqtt broker</code> for local communication as well as to communicate with the cloud.
The <code>Mosquitto</code> logs can be found in <code>/var/log/mosquitto/mosquitto.log</code>.
<code>Mosquitto</code> captures error, warning, notice, information, subscribe, and unsubscribe messages.</p>
<blockquote>
<p>Note: Set <code>log_type debug</code> or <code>log_type all</code> on /etc/mosquitto/mosquitto.conf, to capture more debug information.</p>
</blockquote>
<h3 id="collectd-logs"><a class="header" href="#collectd-logs">Collectd logs</a></h3>
<p><code>Collectd</code> is used for monitoring the resource status of a thin-edge device.
Collectd logs all the messages at <code>/var/log/syslog</code>.
So, the collectd specific logs can be accessed using the <code>journalctl</code> as below</p>
<p><code>journalctl -u collectd.service</code></p>
<h2 id="configuring-log-levels-in-thin-edgeio"><a class="header" href="#configuring-log-levels-in-thin-edgeio">Configuring log levels in <code>thin-edge.io</code></a></h2>
<p>The log levels can be configured for <code>thin-edge.io</code> services using either by command line or setting the required log
level in <code>system.toml</code></p>
<h3 id="setting-the-log-level-through-cli"><a class="header" href="#setting-the-log-level-through-cli">Setting the log level through Cli</a></h3>
<p>The log level can be enabled for a <code>thin-edge.io</code> service as below</p>
<p>For example for tedge-mapper:</p>
<pre><code class="language-shell">
sudo -u tedge -- tedge-mapper  --debug c8y

</code></pre>
<blockquote>
<p>Note: In a similar way it can be set for all the <code>thin-edge.io</code> services.
Only <code>debug</code> level can be set through cli. Also, it enables <code>trace</code> level.</p>
</blockquote>
<h3 id="setting-log-level-through-systemtoml"><a class="header" href="#setting-log-level-through-systemtoml">Setting <code>log level</code> through <code>system.toml</code></a></h3>
<p>The log levels can also be configured through the <code>system.toml</code> file.
The supported log levels are <code>info, warn, error, trace, debug</code>.</p>
<pre><code class="language-shell">[log]
tedge-mapper = &quot;trace&quot;
tedge-agent = &quot;info&quot;
tedge-watchdog = &quot;debug&quot;
c8y-log-plugin = &quot;warn&quot;
c8y-configuration-plugin = &quot;error&quot;
</code></pre>
<blockquote>
<p>Note: The log level strings are case insensitive</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-install-thin-edgeio-on-any-linux-os-no-deb-support"><a class="header" href="#how-to-install-thin-edgeio-on-any-linux-os-no-deb-support">How to install <code>thin-edge.io</code> on any Linux OS (no deb support)?</a></h1>
<h2 id="thin-edgeio-on-supported-platforms"><a class="header" href="#thin-edgeio-on-supported-platforms"><code>thin-edge.io</code> on supported platforms</a></h2>
<p><code>thin-edge.io</code> can be installed on a range of platforms, a platform is defined as a set of hardware architecture and OS, more details can be found in <a href="howto-guides/../supported-platforms.html">Supported Platforms</a> document.</p>
<p>Out of the box <code>thin-edge.io</code> uses deb packages for an automated installation (<a href="howto-guides/./002_installation.html">Installation Guide</a>), you can install it yourself on any Linux system as long as you follow the guidelines below.</p>
<h2 id="installation-on-unsupported-platforms"><a class="header" href="#installation-on-unsupported-platforms">Installation on 'unsupported platforms'</a></h2>
<h3 id="obtaining-binaries"><a class="header" href="#obtaining-binaries">Obtaining binaries</a></h3>
<p>The prebuilt binaries can be obtained from <code>thin-edge.io</code> <a href="https://github.com/thin-edge/thin-edge.io/releases">repository releases</a>.</p>
<p>By default <code>thin-edge.io</code> is built with 3 architectures in mind: <code>amd64 (x86_64)</code>, <code>arm64 (aarch64)</code> and <code>armhf</code> with gnulibc bindings, so if you are looking to install <code>thin-edge.io</code> on a different platform you have to build your own binaries from source which you can do easily if you follow the <a href="howto-guides/./../BUILDING.html">Building <code>thin-edge.io</code></a> guide.</p>
<blockquote>
<p>Note: By default <code>thin-edge.io</code> is built with <code>GNU libc</code>, but it is possible to use <code>musl</code> instead.</p>
</blockquote>
<p>Full installation of <code>thin-edge.io</code> requires the following components:</p>
<ul>
<li>tedge</li>
<li>tedge-mapper</li>
<li>tedge-agent</li>
</ul>
<h4 id="extracting-binaries-from-deb-packages"><a class="header" href="#extracting-binaries-from-deb-packages">Extracting binaries from deb packages</a></h4>
<blockquote>
<p>Required packages:</p>
<ul>
<li>ar</li>
<li>tar</li>
</ul>
</blockquote>
<p>Currently all binaries provided with releases are packaged into <code>deb</code> packages.
<code>deb</code> packages can be extracted to get the binaries for installation (example):</p>
<pre><code class="language-shell">ar -x tedge_&lt;version&gt;_amd64.deb | tar -xf data.tar.xz
ar -x tedge-agent_&lt;version&gt;_amd64.deb | tar -xf data.tar.xz
ar -x tedge-mapper_&lt;version&gt;_amd64.deb | tar -xf data.tar.xz
</code></pre>
<p>Which should give you <code>usr</code> and/or <code>lib</code> directory where you can find binaries.
After extracting all packages, you should now adjust permissions on those files:</p>
<pre><code class="language-shell">chown root:root /usr/bin/tedge
chown root:root /usr/bin/tedge-agent
chown root:root /usr/bin/tedge-mapper
</code></pre>
<p>and then move your binaries to the appropriate directory, eg:</p>
<pre><code class="language-shell">mv ./lib/ ./bin/ /
</code></pre>
<h4 id="if-building-from-source"><a class="header" href="#if-building-from-source">If building from source</a></h4>
<p>If you have built the binaries from source you should install them on the target in: <code>/usr/bin/</code>.</p>
<p><code>systemd</code> unit files for <code>tedge-mapper</code> and <code>tedge-agent</code> can be found in the repository at <code>configuration/init/systemd/tedge-*</code> and should be installed on the target in: <code>lib/systemd/system/tedge-*</code>.</p>
<h3 id="configuring-the-system-and-systemd-units"><a class="header" href="#configuring-the-system-and-systemd-units">Configuring the system and systemd-units</a></h3>
<p><code>thin-edge.io</code> relies on certain system configuration and systemd process management, when installing from deb package all of that is setup automatically but with manual installation a set of steps has to be performed.</p>
<p>On most Linux distribution it should suffice to execute them as <code>root</code> to do the setup, but in some cases (eg, your system uses <code>useradd</code> instead of <code>adduser</code> package) more detailed instructions are documented:</p>
<ul>
<li><a href="https://github.com/thin-edge/thin-edge.io/blob/main/configuration/debian/tedge/postinst">tedge</a></li>
<li><a href="https://github.com/thin-edge/thin-edge.io/blob/main/configuration/debian/tedge-agent/postinst">tedge-agent</a></li>
<li><a href="https://github.com/thin-edge/thin-edge.io/blob/main/configuration/debian/tedge-mapper/postinst">tedge-mapper</a></li>
</ul>
<p>After following steps for all the components installed <code>thin-edge.io</code> should be operational.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-restart-your-thin-edgeio-device"><a class="header" href="#how-to-restart-your-thin-edgeio-device">How to restart your thin-edge.io device</a></h1>
<p>If your device is running thin-edge.io, you can restart it from the cloud. This guide shows how to trigger a restart operation from different cloud providers.</p>
<h3 id="cumulocity"><a class="header" href="#cumulocity">Cumulocity</a></h3>
<p>Go to your device's homepage on c8y, and find the &quot;Control&quot; button. </p>
<p><img src="howto-guides/./images/control-button-red-highlight.png" alt="Control button" /></p>
<p>In the top right corner, you will find the &quot;More&quot; button, click it and select, &quot;Restart device&quot;.</p>
<p><img src="howto-guides/./images/restart-button-red-highlight.png" alt="Restart device button" /></p>
<h3 id="azure"><a class="header" href="#azure">Azure</a></h3>
<p>TBD</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apama-software-management-plugin"><a class="header" href="#apama-software-management-plugin">Apama Software Management Plugin</a></h1>
<p>The Apama plugin, part of the Apama thin-edge support package, can be used to install Apama projects using the Cumulocity software management feature.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>The Apama thin-edge support package must be installed before you can install Apama projects on thin-edge.
The recommended way of installing Apama support on Debian based distributions is with the apt package manager.
Further details about this can be found in the thin-edge.io documentation at <a href="https://thin-edge.github.io/thin-edge.io/html/tutorials/software-management.html">Manage the software on your devices from Cumulocity cloud</a>.</p>
<h4 id="set-up-the-debian-repository-from-which-the-apama-packages-will-be-installed"><a class="header" href="#set-up-the-debian-repository-from-which-the-apama-packages-will-be-installed">Set up the Debian repository from which the Apama packages will be installed</a></h4>
<ol>
<li>In the Cumulocity IoT tenant, open the <strong>Device Management</strong> app, go to the <strong>Management</strong> menu option and select the <strong>Software repository</strong>.</li>
<li>Click <strong>Add software</strong> at the right of the top menu bar. </li>
<li>In the <strong>ADD SOFTWARE</strong> dialog enter the following details:</li>
</ol>
<ul>
<li><strong>Software</strong>: apama-repo</li>
<li><strong>Description</strong>: apama-repo (or something else if you choose)</li>
<li><strong>Device Filter Type</strong>: (leave empty)</li>
<li><strong>Software Type</strong>: apt</li>
<li><strong>Version</strong>: 2022::apt</li>
<li><strong>SOFTWARE FILE</strong>: check the <em>Provide a file path</em> option and enter the URL:	https://downloads.apamacommunity.com/debian/apama-repo_2022_all.deb</li>
</ul>
<ol start="4">
<li>Click the <strong>Add Software</strong> button.</li>
<li>Now select the <strong>Devices</strong> menu option and then select <strong>All devices</strong>.</li>
<li>In the list of devices, select the thin-edge device installed previously.</li>
<li>In the sub-menu for the device, select the <strong>Software</strong> option.</li>
<li>Click the <strong>Install software</strong> button in the bottom left; the apama-repo should be listed.</li>
<li>Click the drop-down arrow on the right and check the 2022::apt radio button, then click <strong>Install</strong>.</li>
<li>Finally, click the <strong>Apply changes</strong> button in the lower right of the panel.</li>
</ol>
<h4 id="add-the-apama-thin-edge-support-package-to-the-tenant-software-repository-and-deploy-it-to-thin-edge"><a class="header" href="#add-the-apama-thin-edge-support-package-to-the-tenant-software-repository-and-deploy-it-to-thin-edge">Add the Apama thin-edge support package to the tenant software repository and deploy it to thin-edge</a></h4>
<ol>
<li>Return to the <strong>Device Management</strong> app and go to the <strong>Management</strong> menu option and select the <strong>Software repository</strong>.</li>
<li>Click <strong>Add software</strong> at the right of the top menu bar.</li>
<li>In the <strong>ADD SOFTWARE</strong> dialog enter the following details:
<ul>
<li><strong>Software</strong>: apama-thin-edge-support</li>
<li><strong>Description</strong>: apama-thin-edge-support (or something else if you choose)</li>
<li><strong>Device Filter Type</strong>: (leave empty)</li>
<li><strong>Software Type</strong>: apt</li>
<li><strong>Version</strong>: latest::apt</li>
<li><strong>SOFTWARE FILE</strong>: select the <strong>Provide a file path</strong> option and give an <strong>empty space</strong> (' ').</li>
</ul>
</li>
<li>Click the <strong>Add Software</strong> button.</li>
<li>Now return to the <strong>Devices</strong> menu option and then select <strong>All devices</strong>.</li>
<li>In the list of devices, select the thin-edge device installed previously.</li>
<li>In the sub-menu for the device, select the <strong>Software</strong> option.</li>
<li>Click the <strong>Install software</strong> button in the bottom left; the apama-thin-edge-support should be listed.</li>
<li>Click the drop-down arrow on the right and check the <code>latest::apt</code> radio button, then click <strong>Install</strong>.</li>
<li>Finally, click the <strong>Apply changes</strong> button in the lower right of the panel.</li>
</ol>
<p>After installation of the support for Apama onto the thin-edge device, the correlator will attempt to start, but will fail initially because there is not yet an Apama project installed. Instructions are given below for installing an Apama project on the device.</p>
<h2 id="install-apama-projects-from-cumulocity"><a class="header" href="#install-apama-projects-from-cumulocity">Install Apama projects from Cumulocity</a></h2>
<p>Before an Apama project can be installed on the device using the software management feature in Cumulocity, the project files need to be added to the Cumulocity software repository.</p>
<p>There is a naming convention that you need to follow while creating software entries for Apama artifacts in the software repository.</p>
<p>For Apama projects:</p>
<ol>
<li>The version must be suffixed with <code>::apama</code> as in <code>1.0::apama</code> or just <code>::apama</code> if no  version number is necessary.</li>
<li>The uploaded binary must be a <code>zip</code> file that contains the <code>project</code> directory. If a directory named <code>project</code> is not found by the plugin at the root level in the zip, it is considered invalid.</li>
</ol>
<p><img src="howto-guides/./images/apama-plugin/apama-project-c8y-software-repository.png" alt="Add new apama project in Software Repository" /></p>
<p>Once the software modules have been added to the software repository, these can be installed on the device just like any other software from the <code>Software</code> tab of the device in the Cumulocity device UI.</p>
<h3 id="testing-apama-plugin"><a class="header" href="#testing-apama-plugin">Testing Apama Plugin</a></h3>
<p>Here is an Apama project that you can use to test this plugin.</p>
<p><a href="https://github.com/thin-edge/thin-edge.io/raw/main/tests/PySys/plugin_apama/Input/quickstart.zip">project zip</a></p>
<p>Add this project as a software package in the Cumulocity software repository by following the instructions in the previous section.
Once added, this Apama project can be installed on any target device.
You can test if the project was successfully installed by running the following Apama command:</p>
<pre><code class="language-shell">/opt/softwareag/Apama/bin/apama_env engine_inspect -m
</code></pre>
<p>You can expect an output like this:</p>
<pre><code class="language-console">Monitors
========
Name                                               Num Sub Monitors
----                                               ----------------
TedgeDemoMonitor                                             1
</code></pre>
<p>You can find more information on this test Apama project <a href="https://github.com/thin-edge/thin-edge.io_examples/tree/main/StreamingAnalytics#testing-a-project">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-change-temp-path"><a class="header" href="#how-to-change-temp-path">How to change temp path</a></h1>
<p>The <code>tedge</code> command can be used to change the temp path. By default the directory used is <code>/tmp</code>. </p>
<p>To change the temp path, run:</p>
<pre><code class="language-shell">sudo tedge config set tmp.path /path/to/directory
</code></pre>
<p>Note that the directory must be available to <code>tedge-agent</code> user and <code>tedge-agent</code> group.</p>
<p>For example:</p>
<pre><code class="language-shell"># create a directory (with/without sudo)

mkdir ~/tedge_tmp_dir

# give ownership to tedge-agent

sudo chown tedge-agent:tedge-agent ~/tedge_tmp_dir 

# reconnect to cloud.
</code></pre>
<p>To revert the path back to its default value:</p>
<pre><code class="language-shell">sudo tedge config unset tmp.path
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-thin-edgeio-with-your-preferred-init-system"><a class="header" href="#how-to-use-thin-edgeio-with-your-preferred-init-system">How to use thin-edge.io with your preferred init system</a></h1>
<p>thin-edge.io works seamlessly with <code>systemd</code> on the CLI commands <code>tedge connect</code> and <code>tedge disconnect</code>.
However, not all OS support <code>systemd</code>.
You might want to use another init system like <code>OpenRC</code>, <code>BSD</code>, <code>init.d</code> with thin-edge.io.
This guide explains how to configure thin-edge.io to use another init system.</p>
<h2 id="how-to-set-a-custom-init-system-configuration"><a class="header" href="#how-to-set-a-custom-init-system-configuration">How to set a custom init system configuration</a></h2>
<p>Create a file <code>system.toml</code> owned by <code>root:root</code> in <code>/etc/tedge</code> directory.</p>
<pre><code class="language-shell">sudo touch /etc/tedge/system.toml
</code></pre>
<p>Open your editor and copy and paste the following toml contents.
This is an example how to configure OpenRC as the init system for thin-edge.io.
We have example configurations for BSD, OpenRC, and systemd under <a href="https://github.com/thin-edge/thin-edge.io/tree/main/configuration/contrib/system">thin-edge.io/configuration/contrib/system</a>.</p>
<pre><code class="language-toml">[init]
name = &quot;OpenRC&quot;
is_available = [&quot;/sbin/rc-service&quot;, &quot;-l&quot;]
restart = [&quot;/sbin/rc-service&quot;, &quot;{}&quot;, &quot;restart&quot;]
stop =  [&quot;/sbin/rc-service&quot;, &quot;{}&quot;, &quot;stop&quot;]
enable =  [&quot;/sbin/rc-update&quot;, &quot;add&quot;, &quot;{}&quot;]
disable =  [&quot;/sbin/rc-update&quot;, &quot;delete&quot;, &quot;{}&quot;]
is_active = [&quot;/sbin/rc-service&quot;, &quot;{}&quot;, &quot;status&quot;]
</code></pre>
<p>Then, adjust the values with your preferred init system.
To get to know the rules of the configuration file, please refer to <a href="howto-guides/./../references/init-system-config.html">Init System Configuration File</a>.</p>
<p>After you finish creating your own configuration file, it's good to limit the file permission to read-only.</p>
<pre><code class="language-shell">sudo chmod 444 /etc/tedge/system.toml
</code></pre>
<p>Now <code>tedge connect</code> and <code>tedge disconnect</code> will use the init system that you specified!</p>
<h2 id="default-settings"><a class="header" href="#default-settings">Default settings</a></h2>
<p>If the custom configuration file <code>/etc/tedge/system.toml</code> is not in place,
<code>tedge connect</code> and <code>tedge disconnect</code> will use <code>/bin/systemctl</code> as the init system.</p>
<h2 id="reference-document"><a class="header" href="#reference-document">Reference document</a></h2>
<ul>
<li><a href="howto-guides/./../references/init-system-config.html">Init System Configuration File</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-monitor-health-of-tedge-daemons"><a class="header" href="#how-to-monitor-health-of-tedge-daemons">How to monitor health of tedge daemons</a></h1>
<p>The health of tedge daemons like <code>tedge-mapper</code>, <code>tedge-agent</code> etc can be monitored via MQTT.
These daemons expose MQTT health endpoints which you can query to check if the process is still active or not.</p>
<p>To get the last known health status of a daemon you can subscribe to the following topic</p>
<pre><code>tedge/health/&lt;tedge-daemon-name&gt;
</code></pre>
<p>To refresh the health status of the daemon, publish an empty message on the topic below.</p>
<pre><code>tedge/health-check/&lt;tedge-daemon-name&gt;
</code></pre>
<blockquote>
<p>Note: if the response is not received then most likely the daemon is down, or not responding</p>
</blockquote>
<p>For example, <code>tedge-mapper-c8y</code> publishes below message on topic <code>tedge/health/tedge-mapper-c8y</code> when it starts</p>
<pre><code class="language-json">{&quot;pid&quot;:290854,&quot;status&quot;:&quot;up&quot;,&quot;time&quot;:1674739912}
</code></pre>
<table><thead><tr><th>Property</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pid</code></td><td>Process ID of the daemon</td></tr>
<tr><td><code>status</code></td><td>Daemon status. Possible values are <code>up</code> or <code>down</code></td></tr>
<tr><td><code>time</code></td><td>Unix timestamp in seconds</td></tr>
</tbody></table>
<p>If the tedge daemon gets stopped or crashed or get killed then a <code>down</code> message will be published on health status topic
and this will be retained till the tedge daemon is re-launched.</p>
<p>E.g the mapper being killed:</p>
<pre><code>tedge mqtt sub 'tedge/health/#'

INFO: Connected
[tedge/health/mosquitto-c8y-bridge] 1
[tedge/health/tedge-mapper-c8y] {&quot;pid&quot;:51367,&quot;status&quot;:&quot;down&quot;}
[tedge/health/tedge-agent] {&quot;pid&quot;:13280,&quot;status&quot;:&quot;up&quot;,&quot;time&quot;:1675330667}

</code></pre>
<h2 id="supported-mqtt-health-endpoint-topics"><a class="header" href="#supported-mqtt-health-endpoint-topics">Supported MQTT health endpoint topics</a></h2>
<p>The following endpoints are currently supported:</p>
<ul>
<li><code>tedge/health/tedge-agent</code></li>
<li><code>tedge/health/tedge-mapper-c8y</code></li>
<li><code>tedge/health/tedge-mapper-az</code></li>
<li><code>tedge/health/tedge-mapper-aws</code></li>
<li><code>tedge/health/tedge-mapper-collectd</code></li>
<li><code>tedge/health/c8y-log-plugin</code></li>
<li><code>tedge/health/c8y-configuration-plugin</code></li>
</ul>
<p>All future tedge daemons will also follow the same topic naming scheme convention.</p>
<h1 id="mosquitto-bridge-health-endpoints"><a class="header" href="#mosquitto-bridge-health-endpoints">Mosquitto bridge health endpoints</a></h1>
<p>The mosquitto bridge clients connecting thin-edge devices to the respective cloud platforms also report their health status as retained messages to <code>tedge/health/&lt;mosquitto-cloud-bridge&gt;</code> topics.
The health check messages published by these clients are just numeric values <code>1</code> or <code>0</code>, indicating active and dead bridge clients respectively.</p>
<p>Here are the health endpoints of currently supported clouds, bridged with mosquitto:</p>
<table><thead><tr><th>Cloud</th><th>Health topic</th></tr></thead><tbody>
<tr><td>Cumulocity</td><td><code>tedge/health/mosquitto-c8y-bridge</code></td></tr>
<tr><td>Azure</td><td><code>tedge/health/mosquitto-az-bridge</code></td></tr>
<tr><td>AWS</td><td><code>tedge/health/mosquitto-aws-bridge</code></td></tr>
</tbody></table>
<p>Explicit health check requests via <code>tedge/health-check</code> topics is not supported by these bridge clients.
Since the health status messages are sent as retained messages, just subscribing to these health topics is sufficient to get the latest status.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enabling-systemd-watchdog-for-thin-edge-services"><a class="header" href="#enabling-systemd-watchdog-for-thin-edge-services">Enabling systemd watchdog for thin-edge services</a></h1>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>The systemd watchdog feature enables systemd to detect when a service is unhealthy or unresponsive and 
attempt to fix it by restarting that service.
To detect if a service is healthy or not, systemd relies on periodic health notifications from that service at regular intervals.
If the service fails to send that notification within a time threshold,
then systemd will assume that service to be unhealthy and restart it.</p>
<p>This document describes how the systemd watchdog mechanism can be enabled for thin-edge services.</p>
<h2 id="enabling-the-systemd-watchdog-feature-for-a-tedge-service"><a class="header" href="#enabling-the-systemd-watchdog-feature-for-a-tedge-service">Enabling the systemd watchdog feature for a tedge service</a></h2>
<p>Enabling systemd watchdog for a <code>thin-edge.io</code> service (tedge-agent, tedge-mapper-c8y/az/collectd) is a two-step process.</p>
<h3 id="step-1-enable-the-watchdog-feature-in-the-systemd-service-file"><a class="header" href="#step-1-enable-the-watchdog-feature-in-the-systemd-service-file">Step 1: Enable the watchdog feature in the systemd service file</a></h3>
<p>For example, to enable the watchdog feature for <code>tedge-mapper-c8y</code> service,
update the systemd service file as shown below:</p>
<blockquote>
<p>Note: The systemd service file for tedge services are usually present in <code>/lib/systemd/system</code> directory, 
like <code>/lib/systemd/system/tedge-mapper-c8y.service</code>.</p>
</blockquote>
<p>Add <code>tedge-watchdog.service</code> as an <code>After</code> service dependency under <code>[Unit]</code> section.
Add the watchdog interval as <code>WatchdogSec=30</code> under <code>[Service]</code> section.
Update the restart condition as <code>Restart=always</code> under <code>[Service]</code> section.</p>
<p>Here is the updated service file for <code>tedge-mapper-c8y</code> service:</p>
<pre><code class="language-shell">[Unit]
Description=tedge-mapper-c8y converts Thin Edge JSON measurements to Cumulocity JSON format.
After=syslog.target network.target mosquitto.service tedge-watchdog.service

[Service]
User=tedge-mapper
ExecStart=/usr/bin/tedge-mapper c8y
Restart=always
RestartPreventExitStatus=255
WatchdogSec=30
</code></pre>
<h3 id="step-2-start-the-tedge-watchdog-service"><a class="header" href="#step-2-start-the-tedge-watchdog-service">Step 2: Start the <code>tedge-watchdog</code> service</a></h3>
<p>The <code>tedge-watchdog</code> service is responsible for periodically checking the health of
all tedge services for which the watchdog feature is enabled,
and send systemd watchdog notifications on their behalf to systemd.</p>
<p>Start and enable the <code>tedge-watchdog</code> service as follows:</p>
<pre><code class="language-shell">systemctl start tedge-watchdog.service
systemctl enable tedge-watchdog.service
</code></pre>
<p>Once started, the <code>tedge-watchdog</code> service will keep checking the health of the monitored tedge services
by periodically sending health check messages to them within their configured <code>WatchdogSec</code> interval.</p>
<p>The health check request for service is published to <code>tedge/health-check/&lt;service-name&gt;</code> topic and
the health status response from that service is expected on <code>tedge/health/&lt;service-name&gt;</code> topic.</p>
<p>Once the health status response is received from a particular service,
the <code>tedge-watchdog</code> service will send the <a href="https://www.freedesktop.org/software/systemd/man/sd_notify.html#">systemd notification</a> to systemd on behalf of that monitored service.</p>
<blockquote>
<p>Note: If none of the <code>thin-edge</code> services are enabled with the watchdog feature, then the <code>tedge-watchdog</code> service will stop with an <code>inactive</code> state.
To monitor any of the <code>thin-edge</code> services, one has to update the corresponding <code>systemd</code> service file with <code>WatchdogSec</code> and then restart the <code>tedge-watchdog</code> service.</p>
</blockquote>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<p>One can observe the message exchange between the <code>service</code> and the <code>watchdog</code>
by subscribing to <code>tedge/health/#</code> and <code>tedge/health-check/#</code> topics.
For more info check <a href="howto-guides/./020_monitor_tedge_health.html">here</a></p>
<blockquote>
<p>Note: If the watchdog service does not send the notification to the systemd within <code>WatchdogSec</code> interval for a service,
then systemd restarts that service by killing the old process and spawning a new one to replace it.</p>
</blockquote>
<blockquote>
<p>Note: <a href="https://www.medo64.com/2019/01/systemd-watchdog-for-any-service/">Here</a> is an example about using <code>systemd watchdog</code> feature.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-add-custom-fragments-to-cumulocity"><a class="header" href="#how-to-add-custom-fragments-to-cumulocity">How to add custom fragments to Cumulocity</a></h1>
<h2 id="default-fragments"><a class="header" href="#default-fragments">Default fragments</a></h2>
<p>By default your device will send the following information to Cumulocity:</p>
<pre><code class="language-json">&quot;c8y_Agent&quot;: {
    &quot;name&quot;: &quot;thin-edge.io&quot;,
    &quot;version&quot;: &quot;x.x.x&quot;
}
</code></pre>
<p>You can change the <code>name</code> value using the <code>tedge</code> command as follows:</p>
<pre><code class="language-shell">sudo tedge config set device.type VALUE
</code></pre>
<h2 id="custom-fragments"><a class="header" href="#custom-fragments">Custom fragments</a></h2>
<p>If you wish to add more fragments to Cumulocity, you can do so by populating <code>{base_config_dir}/device/inventory.json</code>.
The default <code>base_config_dir</code> is <code>/etc/tedge</code>.
See the link for more information about setting a custom <a href="howto-guides/../references/thin-edge-config-files.html">base_config_dir.</a></p>
<p>An example <code>inventory.json</code> looks something like this:</p>
<pre><code class="language-json">{
  &quot;c8y_RequiredAvailability&quot;: {
      &quot;responseInterval&quot;: 5
  },
  &quot;c8y_Firmware&quot;: {
      &quot;name&quot;: &quot;raspberrypi-bootloader&quot;,
      &quot;version&quot;: &quot;1.20140107-1&quot;,
      &quot;url&quot;: &quot;31aab9856861b1a587e2094690c2f6e272712cb1&quot;
  },
  &quot;c8y_Hardware&quot;: {
      &quot;model&quot;: &quot;BCM2708&quot;,
      &quot;revision&quot;: &quot;000e&quot;,
      &quot;serialNumber&quot;: &quot;00000000e2f5ad4d&quot;
  }
}
</code></pre>
<p>To see the changes you need to restart the tedge-mapper.
If you're using systemctl you can do: </p>
<pre><code class="language-shell">sudo systemctl restart tedge-mapper-c8y.service
</code></pre>
<p>In the Cumulocity UI this will looks something like this:
<img src="howto-guides/../howto-guides/images/c8y_custom_fragments.png" alt="c8y_custom_fragments" /></p>
<p>For information on which fragments Cumulocity supports please see the
<a href="https://cumulocity.com/guides/10.6.6/reference/device-management/">Cumulocity API docs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-retrieve-logs-with-the-log-plugin"><a class="header" href="#how-to-retrieve-logs-with-the-log-plugin">How to retrieve logs with the log plugin</a></h1>
<p>You can now access any type of logs directly from your Cumulocity UI, using the
<code>c8y-log-plugin</code> daemon. To get started install the <code>c8y-log-plugin</code> via the
debian package.</p>
<p>If you have not installed via the debian package, make sure you have the following:</p>
<ul>
<li>run <code>sudo c8y-log-plugin --init</code></li>
<li>a <code>c8y-log-plugin.service</code> file in <code>/lib/systemd/system/c8y-log-plugin.service</code></li>
<li>a <code>c8y-log-plugin</code> binary in <code>/usr/bin/c8y-log-plugin</code></li>
<li>check if <code>/etc/tedge/c8y/c8y-log-plugin.toml</code> was created</li>
</ul>
<p>After the device is connected to Cumulocity, this plugin needs to be started and
enabled as follows:</p>
<pre><code class="language-shell">sudo systemctl start c8y-log-plugin
</code></pre>
<pre><code class="language-shell">sudo systemctl enable c8y-log-plugin
</code></pre>
<p>If you go to Cumulocity, you should see that you are able to see the logs tab
and you can request &quot;software-management&quot; logs.
However, you are not limited to only thin-edge logs.
To add a new log type, you need to edit the <code>c8y-log-plugin.toml</code> in <code>/etc/tedge/c8y/c8y-log-plugin.toml</code></p>
<pre><code class="language-shell">sudo nano /etc/tedge/c8y/c8y-log-plugin.toml
</code></pre>
<p>In this toml file you specify the log type and log path of the logs wished to
be retrieved from Cumulocity UI.
For example, if you wish to request thin-edge software logs and mosquitto logs
an example toml file would be:</p>
<pre><code class="language-toml">files = [
  { type = &quot;software-management&quot;, path = &quot;/var/log/tedge/agent/software-*&quot; },
  { type = &quot;mosquitto&quot;, path = &quot;/var/log/mosquitto/mosquitto.log&quot; }
]
</code></pre>
<p>Note that <code>path</code> need not be a complete path. It can be a full path to a log
file or a <a href="https://en.wikipedia.org/wiki/Glob_(programming)">glob pattern</a>.
For example the &quot;software-management&quot; type is a glob pattern that groups
any file inside &quot;/var/log/tedge/agent/&quot; that starts with &quot;software-&quot;.</p>
<p>The <code>type</code> key in the toml is the name of the log with you will see in the
Cumulocity UI:</p>
<p><img src="howto-guides/images/c8y-log-plugin_log-types.png" alt="Log request dropdown" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-cumulocity-custom-smartrest-20-templates"><a class="header" href="#how-to-use-cumulocity-custom-smartrest-20-templates">How to use Cumulocity Custom SmartREST 2.0 Templates</a></h1>
<p><a href="https://cumulocity.com/guides/reference/smartrest-two">Custom SmartRest Templates</a> can be used to extend the functionality of a device to support more operations than what the <a href="https://cumulocity.com/guides/reference/smartrest-two/#mqtt-static-templates">static SmartREST templates</a> offer.</p>
<p><code>thin-edge.io</code> supports subscription to custom templates as documented <a href="https://cumulocity.com/guides/users-guide/device-management/#smartrest-templates">here</a>.</p>
<p>For every template that the device uses, it must publish all data to <code>s/uc/&lt;template-name&gt;</code> topic and subscribe to <code>s/dc/&lt;template-name&gt;</code> to receive data from the cloud, based on that template.
When these templates are configured with <code>thin-edge.io</code>, subscriptions to all these relevant topics on Cumulocity cloud will be done by <code>thin-edge.io</code> internally.
Local processes on the device can access these templates on the local MQTT broker by simply publishing to <code>c8y/s/uc/&lt;template-name&gt;</code> and subscribing to <code>c8y/s/dc/&lt;template-name&gt;</code> topics (note the <code>c8y/</code> prefix in topics).</p>
<p>A template named <code>$TEMPLATE_NAME</code> requires the following subscriptions to be added when connecting to Cumulocity:</p>
<pre><code class="language-plain">s/dc/$TEMPLATE_NAME
s/uc/$TEMPLATE_NAME
</code></pre>
<p><strong>This is not done automatically and the custom templates have to be declared using the <code>tedge</code> command.</strong></p>
<h2 id="checking-existing-templates"><a class="header" href="#checking-existing-templates">Checking existing templates</a></h2>
<pre><code class="language-shell">tedge config get c8y.smartrest.templates
</code></pre>
<h2 id="add-new-template-to-thin-edge-configuration"><a class="header" href="#add-new-template-to-thin-edge-configuration">Add new template to thin-edge configuration</a></h2>
<p>To add new template to <code>thin-edge.io</code> the <code>tedge config</code> cli tool can be used as following:</p>
<pre><code class="language-shell">tedge config set c8y.smartrest.templates template-1,template-2
</code></pre>
<blockquote>
<p>Note: To add/append a new template to a device that's already configured with some, all the existing templates should also be declared along with the new one in the <code>tedge config set</code> command.
For example, if <code>template-1</code> is already configured on the device, as following:</p>
<pre><code class="language-shell">$ tedge config get c8y.smartrest.templates
[&quot;template-1&quot;]
</code></pre>
<p>To add new template to the set it is required to include current template, so the command would look like this:</p>
<pre><code class="language-shell">tedge config set c8y.smartrest.templates template-1,template-2
</code></pre>
<p>Now when we get the configuration the both templates will be there:</p>
<pre><code class="language-shell">$ tedge config get c8y.smartrest.templates
[&quot;template-1&quot;, &quot;template-2&quot;]
</code></pre>
</blockquote>
<h2 id="removing-templates-from-configuration"><a class="header" href="#removing-templates-from-configuration">Removing templates from configuration</a></h2>
<p>To remove all the templates, the <code>unset</code> subcommand can used as follows:</p>
<pre><code class="language-shell">tedge config unset c8y.smartrest.templates
</code></pre>
<p>To remove one of existing templates you can overwrite the existing <code>c8y.smartrest.templates</code> with the new set which doesn't contain the unwanted template.</p>
<pre><code class="language-shell">tedge config get c8y.smartrest.templates
</code></pre>
<pre><code class="language-toml">[&quot;template-1&quot;, &quot;template-2&quot;]
</code></pre>
<pre><code class="language-shell">tedge config set c8y.smartrest.templates template-1
</code></pre>
<pre><code class="language-shell">tedge config get c8y.smartrest.templates
</code></pre>
<pre><code class="language-toml">[&quot;template-1&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-manage-configuration-files-with-cumulocity"><a class="header" href="#how-to-manage-configuration-files-with-cumulocity">How to manage configuration files with Cumulocity</a></h1>
<p>With <code>thin-edge.io</code>, you can manage config files on a device by using the <a href="https://cumulocity.com/guides/users-guide/device-management/#managing-configurations">Cumulocity configuration management feature</a> as a part of Device Management.</p>
<p>If you are new to the Cumulocity <strong>Configuration Management</strong> feature,
we recommend you to read <a href="https://cumulocity.com/guides/users-guide/device-management/#managing-configurations">the Cumulocity user guide</a> along with this how-to guide.</p>
<h2 id="installation-of-c8y-configuration-plugin"><a class="header" href="#installation-of-c8y-configuration-plugin">Installation of <code>c8y-configuration-plugin</code></a></h2>
<p>To enable the feature, first you need to install the <code>c8y-configuration-plugin</code> binary on your device.</p>
<h3 id="using-the-get-thin-edge_iosh-script-on-debian-based-distributions-recommended"><a class="header" href="#using-the-get-thin-edge_iosh-script-on-debian-based-distributions-recommended">Using the <code>get-thin-edge_io.sh</code> script on Debian based distributions (Recommended)</a></h3>
<p>If your device supports <code>apt</code> as a package manager,
you can install all <code>thin-edge.io</code> packages including the <code>c8y-configuration-plugin</code> by the <code>get-thin-edge_io.sh</code> script.
If you have already used the <code>get-thin-edge_io.sh</code> script,
this package is installed, by default.</p>
<pre><code class="language-shell">curl -fsSL https://raw.githubusercontent.com/thin-edge/thin-edge.io/main/get-thin-edge_io.sh | sudo sh -s
</code></pre>
<h3 id="using-the-c8y-configuration-plugin-debian-package-on-debian-based-distributions"><a class="header" href="#using-the-c8y-configuration-plugin-debian-package-on-debian-based-distributions">Using the <code>c8y-configuration-plugin</code> Debian package on Debian based distributions</a></h3>
<p>For Debian based distributions, we provide the <code>c8y-configuration-plugin_&lt;version&gt;_&lt;arch&gt;.deb</code> package as a release asset <a href="https://github.com/thin-edge/thin-edge.io/releases">here</a>.</p>
<p>In case that you didn't use the <code>get-thin-edge_io.sh</code> script, you can download the <code>c8y-configuration-plugin_&lt;version&gt;_&lt;arch&gt;.deb</code>  package on our <a href="https://github.com/thin-edge/thin-edge.io/releases">Releases</a> and install it.</p>
<pre><code class="language-shell">sudo apt install ./path/to/package/c8y-configuration-plugin_&lt;version&gt;_&lt;arch&gt;.deb
</code></pre>
<h3 id="extracting-from-debian-package-on-non-debian-based-distributions"><a class="header" href="#extracting-from-debian-package-on-non-debian-based-distributions">Extracting from debian package on non-Debian based distributions</a></h3>
<p>Get the <code>c8y-configuration-plugin_&lt;version&gt;_&lt;arch&gt;.deb</code> from our <a href="https://github.com/thin-edge/thin-edge.io/releases">Releases</a>.
Then, run this command in the directory where the package is stored.</p>
<pre><code class="language-shell">ar -x ./c8y-configuration-plugin_&lt;version&gt;_&lt;arch&gt;.deb | tar -xf ./data.tar.xz
</code></pre>
<p>The binary is extracted in <code>&lt;current directory&gt;/usr/bin</code>.
For more details, refer to our guide <a href="howto-guides/./015_installation_without_deb_support.html#extracting-binaries-from-deb-packages">Extracting from debian package</a>.</p>
<h3 id="building-from-sources"><a class="header" href="#building-from-sources">Building from sources</a></h3>
<p>Follow our guide <a href="howto-guides/./../BUILDING.html">Building thin-edge.io</a> and <a href="howto-guides/./015_installation_without_deb_support.html#if-building-from-source">Building from source</a>.</p>
<pre><code class="language-shell">cargo build --release -p c8y-configuration-plugin
</code></pre>
<p>A <code>systemd</code> unit file for <code>c8y-configuration-plugin</code> can be found in the repository at <code>configuration/init/systemd/c8y-configuration-plugin.service</code>
and should be installed on the target in: <code>/lib/systemd/system/c8y-configuration-plugin.service</code>.</p>
<pre><code class="language-shell">sudo cp &lt;repository_root&gt;/configuration/init/systemd/c8y-configuration-plugin.service /lib/systemd/system/c8y-configuration-plugin.service
</code></pre>
<h2 id="get-started"><a class="header" href="#get-started">Get started</a></h2>
<p>Before starting anything, make sure <a href="howto-guides/./../tutorials/connect-c8y.html">your device is connected to Cumulocity</a>.</p>
<p><strong>Step 0</strong>
Unless you installed <code>c8y-configuration-plugin</code> using the debian package,
you need one additional step to initialize the plugin. Run this command.</p>
<pre><code class="language-shell">sudo c8y-configuration-plugin --init
</code></pre>
<p><strong>Step 1</strong>
Open the file <code>/etc/tedge/c8y/c8y-configuration-plugin.toml</code> and add entries for the configuration files that you'd like to manage from Cumulocity cloud in the following format:</p>
<pre><code class="language-toml">files = [
    { path = '/etc/tedge/tedge.toml', type = 'tedge.toml'},
    { path = '/etc/tedge/mosquitto-conf/c8y-bridge.conf', type = 'c8y-bridge.conf' },
    { path = '/etc/tedge/mosquitto-conf/tedge-mosquitto.conf', type = 'tedge-mosquitto.conf' },
    { path = '/etc/mosquitto/mosquitto.conf', type = 'mosquitto.conf' },
    { path = '/etc/tedge/c8y/example.txt', type = 'example', user = 'tedge', group = 'tedge', mode = 0o444 }
]
</code></pre>
<ul>
<li><code>path</code> is the full path to the configuration file.</li>
<li><code>type</code> is a unique alias for each file entry which will be used to represent that file in Cumulocity UI.</li>
<li><code>user</code>, <code>group</code> and <code>mode</code> are UNIX file permission settings to be used to create a configuration file. If not provided, the files will be created with <code>root</code> user. If the file exists already, its ownership will be retained.</li>
</ul>
<p>For more details on this configuration file format, refer to the <a href="howto-guides/./../references/c8y-configuration-management.html#configuration">reference guide</a>.</p>
<blockquote>
<p>Note: You can also configure the <code>c8y-configuration-plugin.toml</code> from the cloud later.</p>
</blockquote>
<p><strong>Step 2</strong>
Start the configuration plugin process and enable it on boot by <code>systemctl</code> (recommended).</p>
<pre><code class="language-shell">sudo systemctl start c8y-configuration-plugin.service
sudo systemctl enable c8y-configuration-plugin.service
</code></pre>
<p>Alternatively, you can run the process directly.</p>
<pre><code>sudo c8y-configuration-plugin
</code></pre>
<p><strong>Step 3</strong>
Navigate to your Cumulocity Device Management and the desired device. Open its <strong>Configuration</strong> tab.
You can find <code>c8y-configuration-plugin</code> and more are listed as supported configuration types, as declared in the plugin configuration file in step 1.</p>
<p><img src="howto-guides/./images/c8y-config-plugin-upload.png" alt="Cumulocity Configuration Management Upload" /></p>
<p>This is the configuration file of <code>c8y-configuration-plugin</code>, where you can add file entries that you want to manage with Cumulocity.</p>
<h2 id="update-c8y-configuration-plugin-from-cumulocity"><a class="header" href="#update-c8y-configuration-plugin-from-cumulocity">Update <code>c8y-configuration-plugin</code> from Cumulocity</a></h2>
<p>To update any configuration file, create a local copy of that config file and then upload that file to the <a href="https://cumulocity.com/guides/users-guide/device-management/#to-add-a-configuration-snapshot">Cumulocity configuration repository</a> with the appropriate configuration type.</p>
<p>The <code>c8y-configuration-plugin.toml</code> file can also be updated from the cloud in a similar manner to add/remove further configuration file entries. The updated TOML file has to be uploaded with the configuration type:  <strong>c8y-configuration-plugin</strong>.</p>
<p>Then, go back to the <strong>Configuration</strong> tab of your desired device in Cumulocity.</p>
<p><img src="howto-guides/./images/c8y-config-plugin-download.png" alt="Cumulocity Configuration Management Download" /></p>
<p>Click on the config file entry from the <strong>DEVICE SUPPORTED CONFIGURATIONS</strong> files list.
You can choose the file that you uploaded from the <strong>AVAILABLE SUPPORTED CONFIGURATIONS</strong> section, and then apply that file to your device by clicking on the <strong>Send configuration to device</strong> button.</p>
<p>After the operation created gets marked SUCCESSFUL, reload the page.
Then you can find new supported configuration types as you defined.</p>
<blockquote>
<p>Note: All configuration updates are notified over <code>tedge/configuration_change/&lt;config-type&gt;</code> MQTT topic, giving the opportunity to software components installed on the device or a child device to react to these updates.
For more details, refer to the <a href="howto-guides/./../references/c8y-configuration-management.html#notifications">Notifications section of the specification</a>.</p>
</blockquote>
<p>To get to know more about the <code>c8y-configuration-plugin</code>, refer to <a href="howto-guides/./../references/c8y-configuration-management.html">Specifications of Device Configuration Management using Cumulocity</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-install-thin-edgeio-manually-with-openrc"><a class="header" href="#how-to-install-thin-edgeio-manually-with-openrc">How to install thin-edge.io manually with OpenRC</a></h1>
<p>This tutorial will demo how to install thin-edge.io manually for a non-debian linux distribution that uses OpenRC as its init system.
The aim of this tutorial is to show how to get started with Cumulocity IoT even if your current system is not supported by the default installation of thin-edge.io.
For reference, this tutorial is done with the following system specs:</p>
<ul>
<li>Operating System: Linux gentoo</li>
<li>Linux kernel version: 5.15.41-gentoo-x86_64</li>
<li>Architecture: x86_64</li>
<li>Init system: OpenRC</li>
</ul>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>If you wish to <a href="howto-guides/026_how_to_install_thin_edge_manually.html#building-from-source">build binaries from source</a>, you will to install rust from https://www.rust-lang.org/tools/install.</p>
<p>You will also need to have mosquitto installed. Check your package manager for an available version, or you can <a href="https://github.com/eclipse/mosquitto">building from source</a>. (If you build from source, add <code>WITH_TLS=yes</code> flag to make).</p>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from source</a></h2>
<p>To build from source, download the <strong>Source code (zip)</strong> from the <a href="https://github.com/thin-edge/thin-edge.io/releases/latest">latest releases page</a>.</p>
<p align="center">
  <img src="howto-guides/./images/manual_installation-download_source_code.png" alt="Sublime's custom image"/>
</p>
<p>Once downloaded, unzip it and enter the thin-edge.io directory and build the project with the <code>--release</code> flag:</p>
<pre><code class="language-shell">unzip thin-edge*.zip
cd thin-edge*/
cargo build --release
</code></pre>
<p>This will build the thin-edge.io binaries in the target/release directory. You will then need to move each binary to <code>/usr/bin</code> or an equivalent location in $PATH.
A minimal thin-edge.io installation requires three components:</p>
<ul>
<li>tedge CLI</li>
<li>tedge agent</li>
<li>tedge mapper</li>
</ul>
<pre><code class="language-shell">sudo mv target/release/tedge /usr/bin
sudo mv target/release/tedge-agent /usr/bin
sudo mv target/release/tedge-mapper /usr/bin
</code></pre>
<p>You should now have access to the <code>tedge</code>, <code>tedge-agent</code> and <code>tedge-mapper</code> binaries.</p>
<p align="center">
  <img src="howto-guides/./images/manual_installation-tedge_binary_dry_run.png" alt="Sublime's custom image"/>
</p>
<h2 id="extracting-binaries-from-debian-files"><a class="header" href="#extracting-binaries-from-debian-files">Extracting binaries from debian files</a></h2>
<p>Download the debian files from the <a href="https://github.com/thin-edge/thin-edge.io/releases/latest">latest releases page</a>.
For a minimal configuration of thin-edge.io with Cumulocity IoT, you will need to download:</p>
<ul>
<li>tedge_{VERSION}_amd64.deb</li>
<li>tedge_agent_{VERSION}_amd64.deb</li>
<li>tedge_mapper_{VERSION}_amd64.deb</li>
</ul>
<p align="center">
  <img src="howto-guides/./images/manual_installation-minimum_deb_packages.png" alt="Sublime's custom image"/>
</p>
<p>Next, unpack each deb file and copy the binary to <code>/usr/bin</code>.
For <code>tedge</code> debian package do:</p>
<pre><code class="language-shell">ar -x tedge_*_amd64.deb | tar -xf data.tar.xz
</code></pre>
<p>This unpacks two directories <code>usr/bin/</code>, move its contents to <code>/usr/bin</code></p>
<pre><code class="language-shell">sudo mv usr/bin/tedge /usr/bin
</code></pre>
<blockquote>
<p>Note: Do the same for tedge_agent and tedge_mapper debian packages.</p>
</blockquote>
<h2 id="step-1-creating-the-tedge-user"><a class="header" href="#step-1-creating-the-tedge-user">Step 1: Creating the tedge user</a></h2>
<p>The next step is to create the tedge user. This is normally taken care by the debian package for the <code>tedge</code> CLI tool.</p>
<p>To do this in Gentoo, for example, you can:</p>
<pre><code class="language-shell">sudo groupadd --system tedge

sudo useradd --system --no-create-home -c &quot;&quot; -s /sbin/nologin -g tedge tedge
</code></pre>
<p>Now that we have created the tedge user, we need to allow the tedge user to call commands with <code>sudo</code> without requiring a password:</p>
<pre><code class="language-shell">sudo echo &quot;tedge  ALL = (ALL) NOPASSWD: /usr/bin/tedge, /etc/tedge/sm-plugins/[a-zA-Z0-9]*, /bin/sync, /sbin/init&quot; &gt;/etc/sudoers.d/tedge
</code></pre>
<p>Next, create the files and directories required by thin-edge.io and restart mosquitto too.</p>
<pre><code class="language-shell">sudo rc-service mosquitto stop
sudo tedge --init
sudo rc-service mosquitto start
sudo tedge-agent --init
sudo tedge-mapper --init c8y
</code></pre>
<p>This should show the following output:</p>
<p align="center">
  <img src="howto-guides/./images/manual_installation-binaries_init.png" alt="Sublime's custom image"/>
</p>
<blockquote>
<p>Note: if you do not restart mosquitto you will see a Connection refused error. Do not worry, this error can be ignored.</p>
</blockquote>
<p>Ensure that running the init has created the following files and directories in <code>/etc/tedge</code>:</p>
<p align="center">
  <img src="howto-guides/./images/manual_installation-tedge_directories.png" alt="Sublime's custom image"/>
</p>
<h2 id="step-3-creating-mosquitto-bridge"><a class="header" href="#step-3-creating-mosquitto-bridge">Step 3: Creating mosquitto bridge</a></h2>
<p>To create the mosquitto bridge simply run:</p>
<pre><code class="language-shell">sudo echo &quot;include_dir /etc/tedge/mosquitto-conf&quot; &gt;&gt; /etc/mosquitto/mosquitto.conf
</code></pre>
<p>You can test that <code>mosquitto</code> works by running: </p>
<pre><code class="language-shell">sudo mosquitto --config-file /etc/mosquitto/mosquitto.conf
</code></pre>
<h2 id="step-4-creating-openrc-service-files"><a class="header" href="#step-4-creating-openrc-service-files">Step 4: Creating OpenRC service files</a></h2>
<p>You will need service files for tedge_agent and tedge_mapper. For example:</p>
<blockquote>
<p>Note that, for Cumulocity IoT, the <code>tedge connect</code> command expects three service files called: mosquitto, tedge-agent and tedge-mapper-c8y</p>
</blockquote>
<p>For the <code>tedge-agent</code> service an example file is the following:</p>
<blockquote>
<p>FILE: /etc/init.d/tedge-agent</p>
</blockquote>
<pre><code class="language-sh">#!/sbin/runscript

start() {
   ebegin &quot;Starting tedge-agent&quot;
   start-stop-daemon --user tedge --start --background --exec tedge-agent
   eend $?
}

stop() {
    ebegin &quot;Stopping tedge-agent&quot;
    start-stop-daemon --stop --exec tedge-agent
    eend $?
}
</code></pre>
<p>For the <code>tedge-mapper-c8y</code> service an example file is the following:</p>
<blockquote>
<p>FILE: /etc/init.d/tedge-mapper-c8y</p>
</blockquote>
<pre><code class="language-sh">#!/sbin/runscript

start() {
   ebegin &quot;Starting tedge-mapper-c8y&quot;
   start-stop-daemon --user tedge --start --background --exec tedge-mapper c8y
   eend $?
}

stop() {
   ebegin &quot;Stopping tedge-mapper-c8y&quot;
   start-stop-daemon --stop --exec tedge-mapper
   eend $?
}
</code></pre>
<pre><code class="language-sh">sudo chmod +x /etc/init.d/tedge-agent
sudo chmod +x /etc/init.d/tedge-mapper-c8y
</code></pre>
<p>Next, we need to add a <code>system.toml</code> to <code>/etc/tedge/</code>, telling it to use OpenRC. To do this create the following file:</p>
<blockquote>
<p>FILE: /etc/tedge/system.toml</p>
</blockquote>
<pre><code class="language-sh">[init]
name = &quot;OpenRC&quot;
is_available = [&quot;/sbin/rc-service&quot;, &quot;-l&quot;]
restart = [&quot;/sbin/rc-service&quot;, &quot;{}&quot;, &quot;restart&quot;]
stop =  [&quot;/sbin/rc-service&quot;, &quot;{}&quot;, &quot;stop&quot;]
enable =  [&quot;/sbin/rc-update&quot;, &quot;add&quot;, &quot;{}&quot;]
disable =  [&quot;/sbin/rc-update&quot;, &quot;delete&quot;, &quot;{}&quot;]
is_active = [&quot;/sbin/rc-service&quot;, &quot;{}&quot;, &quot;status&quot;]
</code></pre>
<p>Limit the file's permission to read only:</p>
<pre><code class="language-sh">sudo chmod 444 /etc/tedge/system.toml
</code></pre>
<p>Finally, add the thin-edge.io services to start after boot: </p>
<pre><code>sudo rc-update add tedge-agent default
sudo rc-update add tedge-mapper-c8y default
</code></pre>
<p>We are finally ready to <a href="howto-guides/../tutorials/connect-c8y.html">connect to Cumulocity</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enable-configuration-management-on-child-devices"><a class="header" href="#enable-configuration-management-on-child-devices">Enable configuration management on child devices</a></h1>
<p>Configuration management can be enabled for child devices using the same <code>c8y-configuration-plugin</code>,
used for configuration management on thin-edge devices.
But, an additional piece of software must be developed by the child device owner,
to coordinate configuration management operations on it with the <code>c8y-configuration-plugin</code> running on thin-edge.
This software is referred to as &quot;child device agent&quot; in the rest of this document.</p>
<p>The child device agent needs to handle the following responsibilities:</p>
<ul>
<li>Declare the supported configuration list to thin-edge</li>
<li>Handle configuration snapshot requests from thin-edge</li>
<li>Handle configuration update requests from thin-edge</li>
</ul>
<p>The <em>supported configuration list</em> is the list of configuration files on the child device
that needs to be managed from the cloud.
Configuration management by thin-edge is enabled <em>only</em> for the files provided in this list.
These declared configuration files can be fetched from thin-edge with config snapshot requests
and can be updated with config update requests.</p>
<p>Handling the above mentioned responsibilities involve multiple interactions with thin-edge
over MQTT to receive and respond to configuration management requests,
and HTTP to upload/download files while handling those requests.</p>
<p>For example, during the bootstrapping/startup of the child device,
the agent needs to upload the supported configuration list of the child device to thin-edge
by uploading a file using the HTTP <code>file-transfer</code> API of thin-edge,
followed by an MQTT message informing thin-edge that the upload completed.
Similarly, handling of a configuration snapshot or update request involves sending
MQTT messages before and after the configuration file is uploaded/downloaded via HTTP to/from thin-edge.</p>
<p>Since child device agents typically run on an external device and not on the thin-edge device itself,
the MQTT and HTTP APIs of thin-edge need to be accessed over the network using its IP address,
which is configured using the tedge configuration settings <code>mqtt.external.bind_address</code> or <code>mqtt.bind_address</code>.
The MQTT APIs are exposed via port 1883 and the HTTP APIs are exposed via port 8000.
In rare cases, where the child device agent is installed alongside thin-edge on the same device,
these APIs can be accessed via a local IP or even <code>127.0.0.1</code>.</p>
<p>The following sections explain the child device agent responsibilities in detail.</p>
<h2 id="declare-supported-configuration-list-to-thin-edge"><a class="header" href="#declare-supported-configuration-list-to-thin-edge">Declare supported configuration list to thin-edge</a></h2>
<p>The supported configuration list should be sent to thin-edge during the startup/bootstrap phase of the child device agent.
This bootstrapping is a 3 step process:</p>
<ol>
<li>Prepare a <code>c8y-configuration-plugin.toml</code> file with the supported configuration list</li>
<li>Upload this file to thin-edge via HTTP</li>
<li>Notify thin-edge about the upload via MQTT</li>
</ol>
<p>The child device agent needs to capture the list of configuration files that needs be managed from the cloud
in a <code>c8y-configuration-plugin.toml</code> file in the same format as specified in the <a href="howto-guides/./025_config_management_plugin.html">configuration management documentation</a> as follows:</p>
<pre><code class="language-toml">files = [
    { path = '/path/to/some/config', type = 'config1'},
    { path = '/path/to/another/config', type = 'config2'},
]
</code></pre>
<ul>
<li><code>path</code> is the full path to the configuration file on the child device file system.</li>
<li><code>type</code> is a unique alias for each file entry which will be used to represent that file in Cumulocity UI</li>
</ul>
<p>The child device agent needs to upload this file to thin-edge with an HTTP PUT request
to the URL: <code>http://{tedge-ip}:8000/tedge/file-transfer/{child-id}/c8y-configuration-plugin</code></p>
<ul>
<li><code>{tedge-ip}</code> is the IP of the thin-edge device which is configured as 
<code>mqtt.external.bind_address</code> or <code>mqtt.bind_address</code> or <code>127.0.0.1</code> if neither is configured.</li>
<li><code>{child-id}</code> is the child-device-id</li>
</ul>
<p>Once the upload is complete, the agent should notify thin-edge about the upload by sending the following MQTT message:</p>
<p><strong>Topic:</strong></p>
<p><code>tedge/{child-d}/commands/res/config_snapshot</code></p>
<p><strong>Payload</strong>:</p>
<pre><code class="language-json">{ &quot;type&quot;: &quot;c8y-configuration-plugin”, &quot;path&quot;: ”/child/local/fs/path” }
</code></pre>
<h1 id="handle-config-snapshot-requests-from-thin-edge"><a class="header" href="#handle-config-snapshot-requests-from-thin-edge">Handle config snapshot requests from thin-edge</a></h1>
<p>Handling config snapshot requests from thin-edge is a 4-step process:</p>
<ol>
<li>Subscribe to, and receive config snapshot requests via MQTT</li>
<li>Send an “executing” operation status update to acknowledge the receipt of the request via MQTT</li>
<li>Upload the requested config file to the URL received in the request via HTTP</li>
<li>Send a “successful” operation status update via MQTT</li>
</ol>
<p>These steps are explained in detail below:</p>
<p>The child device agent must subscribe to the <code>tedge/{child-d}/commands/req/config_snapshot</code> MQTT topic
to receive the config snapshot requests from thin-edge.
These requests arrive in the following JSON format:</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;{config-type}&quot;,
    &quot;path&quot;: &quot;/child/local/fs/path&quot;,
    &quot;url&quot;: &quot;http://{tedge-ip}:8000/tedge/file-transfer/{child-d}/config_snapshot/{config-type}&quot;
}
</code></pre>
<p>The <code>type</code> and <code>path</code> fields are the same values that the child device sent to thin-edge in its <code>c8y-configuration-plugin.toml</code> file.
The <code>url</code> value is what the child device agent must use to upload the requested config file.</p>
<p>On receipt of the request, the agent must send an &quot;executing&quot; MQTT status message as follows:</p>
<p><strong>Topic:</strong></p>
<p><code>tedge/{child-d}/commands/res/config_snapshot</code></p>
<p><strong>Payload</strong>:</p>
<pre><code class="language-json">{
    &quot;status&quot;: &quot;executing&quot;,
    &quot;type&quot;: &quot;{config-type}&quot;,
    &quot;path&quot;: &quot;/child/local/fs/path&quot; 
}
</code></pre>
<p>After sending this status message, the agent must upload the requested configuration file content to
the <code>url</code> received in the request with an HTTP PUT request.</p>
<p>Once the upload is complete, send a &quot;successful&quot; MQTT status message as follows:</p>
<p><strong>Topic:</strong></p>
<p><code>tedge/{child-d}/commands/res/config_snapshot</code></p>
<p><strong>Payload</strong>:</p>
<pre><code class="language-json">{
    &quot;status&quot;: &quot;successful&quot;,
    &quot;type&quot;: &quot;{config-type}&quot;,
    &quot;path&quot;: &quot;/child/local/fs/path&quot; 
}
</code></pre>
<p>If there are any failures while reading or uploading the requested config file,
a &quot;failed&quot; status update must be sent instead, to the same topic as follows:</p>
<pre><code class="language-json">{
    &quot;status&quot;: &quot;failed&quot;,
    &quot;type&quot;: &quot;{config-type}&quot;,
    &quot;path&quot;: &quot;/child/local/fs/path&quot; 
}
</code></pre>
<h1 id="handle-config-update-requests-from-thin-edge"><a class="header" href="#handle-config-update-requests-from-thin-edge">Handle config update requests from thin-edge</a></h1>
<p>Handling config update requests from thin-edge is a 5-step process:</p>
<ol>
<li>Subscribe to, and receive config update requests via MQTT</li>
<li>Send an “executing” operation status update to acknowledge the receipt of the request via MQTT</li>
<li>Download the config file update from the URL received in the request via HTTP</li>
<li>Apply the config file update on the child device</li>
<li>Send a “successful” operation status update via MQTT</li>
</ol>
<p>The child device agent must subscribe to the <code>tedge/{child-d}/commands/req/config_update</code> MQTT topic
to receive the config update requests from thin-edge.
These requests arrive in the following JSON format:</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;{config-type}&quot;,
    &quot;path&quot;: &quot;/child/local/fs/path&quot;,
    &quot;url&quot;: &quot;http://{tedge-ip}:8000/tedge/file-transfer/{child-d}/config_update/{config-type}&quot;
}
</code></pre>
<p>The child device agent must download the config file update for the given <code>type</code> from thin-edge using the <code>url</code>.</p>
<p>On receipt of the request, the agent must send an &quot;executing&quot; MQTT status message as follows:</p>
<p><strong>Topic:</strong></p>
<p><code>tedge/{child-d}/commands/res/config_update</code></p>
<p><strong>Payload</strong>:</p>
<pre><code class="language-json">{
    &quot;status&quot;: &quot;executing&quot;,
    &quot;type&quot;: &quot;{config-type}&quot;,
    &quot;path&quot;: &quot;/child/local/fs/path&quot; 
}
</code></pre>
<p>After sending this status message, the agent must download the configuration file update
from the <code>url</code> received in the request with an HTTP GET request.
The agent can then apply the downloaded configuration file update on the device.</p>
<p>Once the update is applied, send a &quot;successful&quot; MQTT status message as follows:</p>
<p><strong>Topic:</strong></p>
<p><code>tedge/{child-d}/commands/res/config_update</code></p>
<p><strong>Payload</strong>:</p>
<pre><code class="language-json">{
    &quot;status&quot;: &quot;successful&quot;,
    &quot;type&quot;: &quot;{config-type}&quot;,
    &quot;path&quot;: &quot;/child/local/fs/path&quot; 
}
</code></pre>
<p>If there are any failures while downloading and applying the update,
a &quot;failed&quot; status update must be sent instead, to the same topic as follows:</p>
<pre><code class="language-json">{
    &quot;status&quot;: &quot;failed&quot;,
    &quot;type&quot;: &quot;{config-type}&quot;,
    &quot;path&quot;: &quot;/child/local/fs/path&quot; 
}
</code></pre>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li>Configuration Management <a href="howto-guides/./025_config_management_plugin.html">documentation</a></li>
<li>Reference implementation of a <a href="https://github.com/thin-edge/thin-edge.io_examples/tree/main/child-device-agent">child device agent</a> written in Python to demonstrate the contract described in this document.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cumulocity-remoteaccessconnect-plugin"><a class="header" href="#cumulocity-remoteaccessconnect-plugin">Cumulocity RemoteAccessConnect plugin</a></h1>
<p>To access a device remotely that runs thin-edge.io, a plugin of the operation plugin concept is used. The tedge-mapper is checking for cloud remote access operation and is triggering the particular plugin. You can use the remote access tab in device management to access the device via SSH or VNC.</p>
<p><a href="https://cumulocity.com/guides/cloud-remote-access/using-cloud-remote-access/">View the Cumulocity documentation for the Remote Access feature</a></p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>
<p>Working thin-edge.io installation</p>
</li>
<li>
<p>The Cloud Remote Access Feature is assigned to your Tenant. If not ask your Administrator to get it assigned to your Tenant. Please note that the Version must be at least 1007.2.0+</p>
</li>
<li>
<p>The Cloud Remote Access Role must be assigned to the user who wants to use that Feature: <em>Administration → Role → &lt;any Role&gt; → check &quot;Remote Access&quot;</em>. Assign the role to the user used for the next steps.</p>
</li>
<li>
<p>A VNC or SSH server running on the device you wish to connect to.</p>
</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Make sure thin-edge.io is connected to Cumulocity.</p>
<p>You device within Cumulocity should look similar to this (the &quot;Remote access&quot; tab should be visible in the menu on the left):</p>
<img class="cover-pin-left" src="howto-guides/images/c8y-remote-access_dm.png">
<p>You can configure now within the Remote access tab to which e.g. VNC or SSH server you want to jump to. Please keep in mind that the Host is from the thin-edge.io point of view.</p>
<img src="howto-guides/images/c8y-remote-access_endpoint.png">
<p>If you click on connect after the proper configuration an websocket window opens and thin-edge.io triggers the <code>c8y-remote-access-connect</code> plugin to reach that websocket.</p>
<img src="howto-guides/images/c8y-remote-access_websocket.png">
<style>
    img {
        margin: 2em auto;
        display: block;
    }

    img.cover-pin-left {
        object-fit: cover;
        height: 500px;
        object-position: left;
    }
</style><div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-monitor-health-of-service-from-cumulocity-iot"><a class="header" href="#how-to-monitor-health-of-service-from-cumulocity-iot">How to monitor health of service from Cumulocity IoT</a></h1>
<p>The health of a <code>thin-edge.io</code> service or any other <code>service</code> that is running on the <code>thin-edge.io</code> device
or on the <code>child</code> device can be monitored from the <strong>Cumulocity IoT</strong> by sending the <code>health-status</code> message to <strong>Cumulocity IoT</strong>.</p>
<h2 id="send-the-health-status-of-a-service-to-tedgehealth-topic"><a class="header" href="#send-the-health-status-of-a-service-to-tedgehealth-topic">Send the health status of a service to <code>tedge/health</code> topic.</a></h2>
<p>The table below lists the MQTT topics to which the health status message should be sent, and the
health status message format for both the <code>thin-edge</code> and for the <code>child</code> device.</p>
<table><thead><tr><th>Device-type</th><th>Thin-edge-Health-status-mqtt-topic</th><th>Health-status-message</th></tr></thead><tbody>
<tr><td>Thin-edge-device</td><td><code>tedge/health/&lt;service-name&gt;</code></td><td><code>{&quot;status&quot;:&quot;status of the service&quot;,&quot;type&quot;:&quot;type of service&quot;}</code></td></tr>
<tr><td>Child-device</td><td><code>tedge/health/&lt;child-device-id&gt;/&lt;service-name&gt;</code></td><td><code>{&quot;status&quot;:&quot;status of the service&quot;,&quot;type&quot;:&quot;type of service&quot;}</code></td></tr>
</tbody></table>
<blockquote>
<p>Note: The <code>status</code> here can be <code>up or down</code> or any other string. For example, <code>unknown</code>.</p>
</blockquote>
<p>For example, to monitor the health status of a <code>tedge-mapper-c8y service</code> that is running on a <code>thin-edge.io</code> device
one has to send the below message.</p>
<pre><code>tedge mqtt pub tedge/health/tedge-mapper-c8y `{&quot;status&quot;:&quot;up&quot;,&quot;type&quot;:&quot;thin-edge.io&quot;}` -q 2 -r
</code></pre>
<p>The above message says that the <code>tedge-mapper-c8y</code> is <code>up</code> and the <code>type</code> of the service is <code>thin-edge.io</code>.</p>
<p>To monitor the health of a <code>docker</code> service that is running on an <code>external-sensor</code> child device,</p>
<pre><code>tedge mqtt pub tedge/health/external-sensor/docker `{&quot;status&quot;:&quot;up&quot;,&quot;type&quot;:&quot;systemd&quot;}` -q 2 -r
</code></pre>
<blockquote>
<p>Note: The health status message has to be sent as a <code>retain</code> message.</p>
</blockquote>
<p>When an <code>empty health status,i.e('{}' or '')</code> message sent, the <code>status</code> will be replaced with <code>unknown</code> and the <code>type</code> will be replaced with default value <code>service</code>.</p>
<h2 id="conversion-of-the-health-status-message-to-cumulocity-iot-service-monitor-message"><a class="header" href="#conversion-of-the-health-status-message-to-cumulocity-iot-service-monitor-message">Conversion of the <code>health status</code> message to <code>Cumulocity IoT service monitor</code> message.</a></h2>
<p>The <code>tedge-mapper-c8y</code> will translate the <code>health status</code> message that is received on <code>tedge/health/#</code>
topic to <code>Cumulocity</code> specific <code>service monitor</code> message and sends it to <code>Cumulocity</code> cloud.</p>
<p>The table below gives more information about the <strong>Cumulocity IoT</strong> topic and the translated service monitor message for both <code>thin-edge</code> as well as for <code>child</code> device.</p>
<table><thead><tr><th>Device-type</th><th>Cumulocity topic</th><th>Cumulocity smartrest message</th></tr></thead><tbody>
<tr><td>Thin-edge-device</td><td><code>c8y/s/us</code></td><td><code>102,&lt;unique-service-id&gt;,type,service-name,status</code></td></tr>
<tr><td>Child-device</td><td><code>c8y/s/us/&lt;child-id&gt;</code></td><td><code>102,&lt;unique-service-id&gt;,type,service-name,status</code></td></tr>
</tbody></table>
<blockquote>
<p>Note: The <code>unique-service-id</code> for thin-edge device will be  <code>&lt;device-name&gt;_&lt;service-name&gt;</code>.
In case of child device <code>&lt;device-name&gt;_&lt;child-id&gt;_&lt;service-name&gt;</code>.</p>
</blockquote>
<blockquote>
<p>Note: <code>102</code> is the <code>smartrest</code> template number for the service monitoring message.</p>
</blockquote>
<h2 id="configuring-the-default-service-type"><a class="header" href="#configuring-the-default-service-type">Configuring the default service type</a></h2>
<p>The <code>default service type</code> can be configured using the <code>tedge</code> cli.</p>
<p>The example below shows how one can set the default service type to <code>systemd</code>.</p>
<pre><code>tedge config set service.type systemd

</code></pre>
<blockquote>
<p>Note: When the <code>service type</code> was not sent with the <code>health status</code> message, then the configured default value will be used by
the mapper while translating the <code>health status</code> message to <code>service status</code> message.</p>
</blockquote>
<p>To clear the configured default service type one can use the command below.
This will set the <code>service.type</code> to <code>service</code>.</p>
<pre><code>tedge config unset service.type

</code></pre>
<h1 id="references-2"><a class="header" href="#references-2">References</a></h1>
<p>More info about the service monitoring can be found in the below link</p>
<p><a href="https://cumulocity.com/guides/reference/smartrest-two/#service-creation-102">Service monitoring Cumulocity IoT</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developer-documentation"><a class="header" href="#developer-documentation">Developer Documentation</a></h1>
<p>The Developer Documentation for everybody who is interested in extending thin-edge.io. For more deeper interested users this also might be interesting, even if not required to operate thin-edge.io.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>Thin-edge.io is an open-source framework to develop lightweight, smart and secure connected devices.</p>
<p>Cloud agnostic, thin-edge.io provides the foundations for cloud connectivity and device management,
a set of pre-packaged  modules, plug &amp; play connectors to cloud platforms,
device certificate management, monitoring as well as built-in software and firmware management.</p>
<p>On top of these foundations, telemetry applications can be built using a combination of components provided by various IoT actors.
The features provided by these components can be as diverse as low-level connectivity to IoT protocols,
event-stream analytics, machine-learning-powered systems, or application specific processors.</p>
<p>Built around an extensible architecture,
thin-edge.io can be extended in various programming languages.
Here are the key aspects of the thin-edge.io architecture:</p>
<ol>
<li>
<p>The components are processes exchanging messages over an MQTT bus.</p>
</li>
<li>
<p>The MQTT bus is connected to the cloud, forwarding the messages published on cloud specific topics. </p>
</li>
<li>
<p>A <a href="architecture/thin-edge-json.html">canonical data format</a> let the components exchange telemetry data independently of the connected cloud.
This is an optional feature, and the components are free to also use cloud specific data formats.</p>
</li>
<li>
<p>The mapper processes are responsible for translating the canonical data format into cloud specific messages and vice versa.</p>
</li>
</ol>
<p><img src="architecture/./images/thin-edge-overview.png" alt="Overview" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thin-edge-domain-model"><a class="header" href="#thin-edge-domain-model">thin-edge Domain Model</a></h1>
<p>The following section introduces the <strong>thin-edge</strong> domain model.</p>
<p><strong>thin-edge</strong> is the glue between the <strong>cloud</strong> and <strong>devices</strong>. I.e. it interfaces on the one hand <strong>devices</strong> (especially resource constrained industrial <strong>devices</strong>), and connects on the other hand the <strong>cloud</strong>.
The <strong>cloud</strong> could be some IoT Cloud Platform, such as <a href="https://www.softwareag.cloud/site/product/cumulocity-iot.html">Cumulocity</a>, <a href="https://azure.microsoft.com">Azure</a> or <a href="https://aws.amazon.com">AWS</a>; or an on-premise &quot;IoT system&quot;.</p>
<p><strong>thin-edge</strong> has been designed with the assumption that the <strong>device</strong> is represented in the <strong>IoT cloud</strong> as <strong>device twin</strong>.
The <strong>device twin</strong> in the IoT cloud is a logical representation of the <strong>device</strong>. As such, it carries or references <strong>Telemetry Data</strong>, and stores the <em>state</em> of the <strong>device</strong>.
Here <em>state</em> refers to e.g. <strong>Device Management</strong> details as <em>installed software versions</em> or <em>configurations</em>.</p>
<h2 id="telemetry-data"><a class="header" href="#telemetry-data">Telemetry Data</a></h2>
<p><strong>Telemetry data</strong> are <em>measurements</em>, <em>events</em> and <em>alarms</em>.</p>
<ul>
<li><strong>Measurement</strong>:
<ul>
<li>has a <em>type name</em></li>
<li>carries a <em>time-series</em> of <strong>samples</strong>
<ul>
<li>a <strong>sample</strong> is a single value or set of values, all taken at a single point in time
<ul>
<li>could be a mix of values coming from physical <strong>Sensors</strong><sup class="footnote-reference"><a href="#1">1</a></sup> and the device's <strong>Domain Application</strong><sup class="footnote-reference"><a href="#1">1</a></sup>;
e.g. <em>voltage</em> and <em>current</em> of an electricity meter, and current state of the manufacturing control process</li>
<li>all <strong>sample's</strong> values could be a mix of numbers, strings or booleans</li>
<li>a <strong>sample</strong> has <em>one</em> timestamp</li>
</ul>
</li>
<li>a <em>sequence</em> of <strong>samples</strong> is a set of <strong>samples</strong> over a period of time;
e.g. <em>voltage</em> and <em>current</em> captured in a fixed interval</li>
</ul>
</li>
<li>a measurement optionally holds individual <em>units</em> for the values of the <strong>samples</strong></li>
<li>a measurement relates to a source, i.e. a device or a process</li>
</ul>
</li>
<li><strong>Setpoint</strong>, is a single value or set of values
<ul>
<li>the values are process variables, used by the <strong>Domain Application</strong><sup class="footnote-reference"><a href="#1">1</a></sup>;<br/>
e.g. the <em>lower limit</em> and the <em>upper limit</em> of a climate control process</li>
<li>the values are visible in the cloud, similar to measurements</li>
<li>the values can be manipulated from cloud-site or the device-site
<ul>
<li>each manipulation is processed asynchronously;
i.e. once new values were set, those are used by the <strong>Domain Application</strong><sup class="footnote-reference"><a href="#1">1</a></sup> from next control-cycle on</li>
</ul>
</li>
<li>the values could be a mix of numbers, strings or booleans</li>
</ul>
</li>
<li><strong>Event</strong>, is a notification that something happened on the device's environment or software system
<ul>
<li>has one timestamp</li>
<li>common triggers for an <strong>event</strong> can be
<ul>
<li>a <em>sensor's<sup class="footnote-reference"><a href="#1">1</a></sup> value</em> that detects something like a door has been closed</li>
<li>a signal from the device's <em>domain application</em><sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>a device's <em>system notification</em> that e.g. a user has started an ssh session</li>
</ul>
</li>
<li>the interpretation of a <em>sensor's value</em>, a <em>domain application's</em> signal or a <em>system's notification</em>
that shall represent an <strong>event</strong> trigger falls to some custom specific software piece
<ul>
<li>whenever that software piece interprets an <strong>event</strong> trigger, it uses the <strong>thin-edge</strong> API to send an event notification to <strong>thin-edge</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>Alarm</strong>, similar to <strong>events</strong>; but in addition: 
<ul>
<li>the <em>End User</em> (an operator of the system) has to take action to resolve the <strong>alarm</strong></li>
<li>also the <em>custom specific sw component</em> can send a notification to <strong>thin-edge</strong> to clear an <strong>alarm</strong></li>
</ul>
</li>
</ul>
<h2 id="device-management"><a class="header" href="#device-management">Device Management</a></h2>
<p><strong>Device Management</strong> allows managing and monitoring devices in the field from the cloud.
That includes:</p>
<ul>
<li><strong>Software Management</strong>:
<ul>
<li>allows managing the installed software packages on the device, as
<ul>
<li>retrieve list and versions of installed packages</li>
<li>install new or update existing software packages</li>
<li>remove installed software packages</li>
</ul>
</li>
<li>software packages are installable units on the device, as e.g.
<ul>
<li>packages for a Linux Packages Managers (e.g. for Debian, ...)</li>
<li>container images (e.g. for Docker)</li>
<li>simple ZIP files</li>
<li>custom specific files/packages</li>
</ul>
</li>
<li>software packages can carry:
<ul>
<li>the <strong>domain application</strong><sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>parts from <strong>OS / Libs / Runtime</strong><sup class="footnote-reference"><a href="#1">1</a></sup>, or the whole thing as one</li>
<li><strong>thin-edge</strong> itself</li>
</ul>
</li>
</ul>
</li>
<li><strong>Firmware Management</strong>:
<ul>
<li>allows to update the <em>OS base-image</em> of the device as one (e.g. the Linux distribution)</li>
<li>a firmware update might dictate a new software list and new configurations
<ul>
<li>i.e. <em>software modules</em> previously installed with <strong>Software Management</strong> might be gone after a firmware update;
e.g. when those <em>software modules</em> were installed into the area of the <em>OS base-image</em></li>
<li>the actual behaviour of <strong>Software Management</strong> together with <strong>Firmware Management</strong> depends on details of the
specific deployment and package management of the custom device</li>
<li>same also applies for <strong>Configuration Management</strong> together with <strong>Firmware Management</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>Configuration Management</strong>:
<ul>
<li>allows viewing and changing configurations on the device, as
<ul>
<li>list available configurations</li>
<li>transfer individual configurations from device to cloud, and vice versa</li>
</ul>
</li>
<li>a configuration is a text file or a binary file, as e.g.
<ul>
<li>configuration file(s) of the <strong>domain application</strong><sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>configuration file(s) of <strong>OS / Libs / Runtime</strong><sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>configuration file(s) of <strong>thin-edge</strong> it-self</li>
</ul>
</li>
</ul>
</li>
<li><strong>Log Management</strong>:
<ul>
<li>allows viewing logs from the device
<ul>
<li>lists available logs</li>
<li>transfer individual logs from device to cloud</li>
</ul>
</li>
<li>a log is a text file, as e.g.
<ul>
<li>log file(s) of the <strong>domain application</strong><sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>log file(s) of <strong>OS / Libs / Runtime</strong><sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li>log file(s) of <strong>thin-edge</strong> it-self</li>
</ul>
</li>
</ul>
</li>
<li><strong>Device Monitoring</strong>:
<ul>
<li>collects metrics (e.g. cpu, memory and disk metrics) from the device and forward these to the IoT cloud</li>
<li>allows monitoring the health of devices</li>
<li>helps troubleshooting when problems with the device are reported</li>
</ul>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>more details see appendix <a href="architecture/domain-model.html#device-domain">Device Domain</a></p>
</div>
<h2 id="child-devices"><a class="header" href="#child-devices">Child-Devices</a></h2>
<p><strong>thin-edge</strong> facilitates IoT functionality to the device it is running on, as well as to devices that are connected to that device.</p>
<ul>
<li>the device <strong>thin-edge</strong> is running on is referred as the <strong>main-device</strong>
<ul>
<li><strong>thin-edge</strong> on the <strong>main-device</strong> establishes and manages all communication to the cloud</li>
</ul>
</li>
<li>all devices connected to the <strong>main-device</strong> are referred as <strong>external child-devices</strong> </li>
<li>each <strong>external child-device</strong> can be represented in the cloud with its individual <strong>device twin</strong>
<ul>
<li>a unique <strong>child-id</strong> makes the association between each <strong>external child-device</strong> and it's <strong>device twin</strong></li>
</ul>
</li>
<li>all <strong>telemetry data</strong> and <strong>device management</strong> functionality can appear in the context of the 
<strong>external child-device's</strong> individual <strong>device twin</strong>, or the <strong>main-device's</strong> <strong>device twin</strong></li>
<li>also <em>containers</em> or <em>processes</em> running on the <strong>main-devices</strong> can be handled like <strong>external child-device</strong>;
those are referered then as <strong>logical child-devices</strong></li>
</ul>
<p>The figure below illustrates the child-device concept.</p>
<p><img src="architecture/images/device-concept.svg" alt="Device Concept" /></p>
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<p><strong>thin-edge</strong> realizes <strong>Device Management</strong> based on <strong>plugins</strong>.</p>
<ul>
<li>a <strong>plugin</strong> can be an (external) executable (e.g. as the <code>c8y-configuration-plugin</code> for <em>configuration management</em>)
or part of a thin-edge built-in software component (e.g. <em>software management</em> in <code>tedge-agent</code>)</li>
<li>to realize <strong>Device Management</strong> functionality, a <strong>plugin</strong> accesses <em>resources</em> and <em>services</em> of the device, as e.g.
<ul>
<li><em>software management</em> uses the device's <em>package manager</em></li>
<li><em>configuration management</em> reads/writes device's <em>configuration files</em></li>
</ul>
</li>
<li>a <strong>plugin</strong> can facilitate <strong>Device Management</strong> functionality for the <strong>main-device</strong> and <strong>external child-devices</strong>, or even containers on the <strong>main-device</strong> (e.g. docker containers)
<ul>
<li>a <strong>plugin</strong> runs usually on the <strong>main-device</strong></li>
<li><em>resources</em> and <em>services</em> (e.g. file system, package manager, ...) of <strong>external child-devices</strong> or other containers can not accessed directly by the <strong>plugin</strong></li>
<li>the access to those <em>resources</em> and <em>services</em> is established by another software component, referred as <strong>plugin adapter</strong>
<ul>
<li>a <strong>plugin adapter</strong> can run on the <strong>external child-device</strong> or inside the container, and provides access via network to the <strong>plugin</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The figure below illustrates the concept of <strong>plugins</strong> and <strong>plugin adapters</strong>.</p>
<p><img src="architecture/images/plugin-concept.svg" alt="Plugin Concept" /></p>
<h3 id="plugin-adapter"><a class="header" href="#plugin-adapter">Plugin Adapter</a></h3>
<p>A <strong>plugin adapter</strong> is the counterpart of a <strong>plugin</strong>, that takes the responsibility to access the <strong>external child-device's</strong> or container's <em>resources</em> and <em>services</em>.</p>
<ul>
<li>a <strong>plugin adapter</strong> can serve one or more <strong>plugins</strong></li>
<li>for access to an <strong>external child-device</strong>, the <strong>plugin adapter</strong> can be installed and executed on that <strong>external child-device</strong>, or on the <strong>main-device</strong>
<ul>
<li>if it runs on the <strong>external child-device</strong> it can access the <em>resources</em> and <em>services</em> directly</li>
<li>if it runs on the <strong>main-device</strong> it can use any (low-level) interfaces the <strong>external child-device</strong> provides to access those <em>resources</em>
<ul>
<li>One main reason to install the <strong>plugin adapter</strong> on the <strong>main-device</strong> is, when the <strong>external child-device</strong> cannot or shall not be altered.</li>
</ul>
</li>
</ul>
</li>
<li>for access to another container, the <strong>plugin adapter</strong> can be installed and executed inside that container, where it can access the <em>resources</em> and <em>services</em> directly</li>
</ul>
<h3 id="plugin-identifier-and-contract"><a class="header" href="#plugin-identifier-and-contract">Plugin-Identifier and Contract</a></h3>
<p>A <strong>plugin</strong> defines and implements a specific <strong>contract</strong> for all interactions with a <strong>plugin adapter</strong></p>
<ul>
<li>part of the <strong>contract</strong> could be e.g.:
<ul>
<li>the <strong>plugin adapter</strong> must listen and react to certain requests of the <strong>plugin</strong>, e.g. on MQTT</li>
<li>the <strong>plugin adapter</strong> must provide/consume files to/from the <strong>plugin</strong> on purpose, e.g. via HTTP</li>
<li>...and more...</li>
</ul>
</li>
<li>a <strong>plugin</strong> can be flagged with a unique <em>plugin-identifier</em> (e.g. <code>tedge_config</code>, <code>tedge_software</code> or any other unique string for a custom specific plugin)
<ul>
<li>based on that <em>plugin-identifier</em> a <strong>plugin adapter</strong> can report and find <strong>plugins</strong> the child-device intends to contact (e.g. during provisioning phase)</li>
<li>a <strong>plugin</strong> and a <strong>plugin adapter</strong> using the same <em>plugin-identifier</em> can assume to implement the same <strong>contract</strong>, and to be compatible with each other</li>
</ul>
</li>
</ul>
<h2 id="inventory"><a class="header" href="#inventory">Inventory</a></h2>
<p><strong>thin-edge</strong> holds and manages an <strong>inventory</strong> on the <strong>main-device</strong>, that stores and provides information about the <strong>main-device</strong> and known <strong>child-devices</strong></p>
<ul>
<li>information stored per <strong>device</strong> are
<ul>
<li>supported kinds of <strong>Device Management</strong> capabilities/operations</li>
<li>supported kinds of <strong>Telemetry Data</strong></li>
<li>optionally any custom-specific meta-information per <strong>device</strong></li>
</ul>
</li>
<li>the <strong>inventory</strong> is the communication backbone for <strong>plugins</strong>, <strong>external child-devices</strong>, the <strong>domain application</strong><sup class="footnote-reference"><a href="#1">1</a></sup> and <strong>thin-edge</strong> it-self
<ul>
<li>one can add information to announce capabilities a <strong>device</strong> supports</li>
<li>another one can retrieve those information to identify capabililties a <strong>device</strong> supports</li>
</ul>
</li>
</ul>
<h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<h2 id="device-overview"><a class="header" href="#device-overview">Device Overview</a></h2>
<p><strong>thin-edge</strong> is designed to facilitate IoT functionality to resource constrained <strong>devices</strong>. The focus is on industrial OT <strong>devices</strong> or any other kind of embedded <strong>devices</strong>. It is not reduced to <strong>devices</strong> that are capable to install and run thin-edge, but includes also <strong>devices</strong> that need another <em>(gateway) device</em> aside, that executes <strong>thin-edge</strong>.</p>
<p>Usual <strong>devices</strong> are <strong>PLCs</strong> (<strong>P</strong>rogrammable <strong>L</strong>ogic <strong>C</strong>ontrollers), <strong>IPCs</strong> (<strong>I</strong>ndustrial <strong>PC</strong>s) or any kind of <strong>SoC-based</strong> or <strong>Microcontroller-based</strong> Embedded System. The figure below shows a simplified conceptual model of such a device.</p>
<p><img src="architecture/images/simple-device-model.svg" alt="Simple Device Model" /></p>
<!--
* TODO: add somehow "Such a **device** is most often a specialized hardware that has been ruggedized to operate in harsh electrical, thermic and mechanical industrial environments."
-->
<ul>
<li>The <strong>Domain Application</strong> is a program, that contains the domain specific process logic.
<ul>
<li>On a <strong>PLC</strong> it's a <em>control application</em>, created by an <em>automation engineer</em> in a domain specific graphical programming language (like &quot;Ladder Diagram&quot; or &quot;Function block diagram&quot;)</li>
<li>Or on a <strong>SoC-based</strong> or <strong>Microcontroller-based</strong> system it's an <em>application program</em>, created by an <em>embedded software engineer</em> usually in C/C++</li>
</ul>
</li>
<li>The <strong>OS / Libs / Runtime</strong> provide basic functionality to the <strong>Domain Application</strong><!-- TODO: add somehow "used to abstract the hardware. But: on a microcontroller usually less abstraction, more hw dep on the domain app, and even no OS" -->
</li>
<li><strong>Sensors</strong> and <strong>Actuators</strong> enable the <strong>device</strong> to observe and control physical behaviour on the shopfloor or device's environment.
<ul>
<li>can be integrated in the <strong>device's</strong> hardware,
or connected to the <strong>device</strong> via some <strong>Fieldbus</strong> (e.g. Modbus, CANopen, PROFINET, EtherCAT, ...) or
some <strong>Local Interface</strong> as USB, UART, SPI, I2C, ...</li>
<li>can be simple peripherals as a light barrier, or a sensor for temperature or pressure;
or complex equipment as robotic arms or even other <strong>devices</strong></li>
</ul>
</li>
<li><strong>Inputs / Outputs</strong> are the communication channels between the <strong>Domain Application</strong> and <strong>Sensors</strong> and <strong>Actuators</strong>
<ul>
<li>drivers (as part of the <strong>OS / Libs / Runtime</strong> and/or the <strong>Domain Application</strong>) do expose all data from
<strong>Sensors</strong> and <strong>Actuators</strong> to the <strong>device</strong> as inputs or outputs</li>
<li>also the <strong>Domain Application</strong> can expose data as input or output (e.g. own <em>signals</em> or <em>states</em>)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thin-edge-data-model"><a class="header" href="#thin-edge-data-model">thin-edge Data Model</a></h1>
<p>The <strong>data model</strong> identifies all data send or received from/to <strong>thin-edge</strong> and its components, to interact with those.
For all data it defines format and explains behaviour.</p>
<h2 id="use-of-mqtt"><a class="header" href="#use-of-mqtt">Use of MQTT</a></h2>
<p><strong>thin-edge</strong> expects the MQTT broker <a href="https://mosquitto.org/">mosquitto</a> to be available on the device.
<strong>thin-edge</strong> uses <strong>mosquitto</strong> to consume and provide telemetry data. All telemetry data are reflected with specific MQTT topics and payload in JSON format.</p>
<p><strong>thin-edge</strong> assumes <strong>mosquitto</strong> is configured in a secure manner, to avoid any inappropriate access to <strong>thin-edge</strong> topics and payload.
Any malicious access to the broker can hazard <strong>thin-edge</strong> and all connected devices. Mosquitto provides a wide range of authentication and access control options. For more details see <em>Authentication</em> and <em>ACL</em> (Access Control List) in <a href="https://mosquitto.org/man/mosquitto-conf-5.html">mosquitto documentation</a>.</p>
<h3 id="telemetry-data-on-mqtt"><a class="header" href="#telemetry-data-on-mqtt">Telemetry Data on MQTT</a></h3>
<p>All telemetry data (<strong>Measurements</strong>, <strong>Events</strong>, <strong>Alarms</strong>) are reflected with MQTT topics, where each has its specific subtopic (e.g. <code>tedge/measurements</code>, <code>tedge/events</code>, <code>tedge/alarms</code> etc.).</p>
<ul>
<li>each provider of a <strong>measurement</strong>, <strong>event</strong> or <strong>alarm</strong> sends the occurring data to <strong>thin-edge's</strong> MQTT broker
<ul>
<li>a provider can be the domain application<sup class="footnote-reference"><a href="#1">1</a></sup>, other SW components / 3rd parties</li>
</ul>
</li>
<li>all processes (e.g. the domain application<sup class="footnote-reference"><a href="#1">1</a></sup>, other SW components / 3rd parties) on the main-device and all child-devices can consume those telemetry data from the MQTT broker</li>
<li>the cloud mapper on the <strong>main-device</strong> picks-up <em>all</em> telemetry data from the MQTT broker and transfers those to the cloud</li>
</ul>
<p>The communication diagram below illustrates that behaviour.</p>
<p><img src="architecture/images/MQTT-communication.svg" alt="MQTT communication flow" /></p>
<h3 id="telemetry-data-for-child-devices"><a class="header" href="#telemetry-data-for-child-devices">Telemetry Data for Child-Devices</a></h3>
<p>All telemetry data provided to the MQTT bus are associated by <strong>thin-edge</strong> and all consumers with the thin-edge <strong>main-device</strong> or some <strong>child-device</strong> (see more details about <strong>child-devices</strong> in the <a href="architecture/./domain-model.html#child-devices">domain model</a>).</p>
<p>Therefore the <code>child-id</code> of the <strong>child-device</strong> is can be appended to the MQTT topic, if the message is meant for a <strong>child-device</strong>;
or no <code>child-id</code> is appended, if the message is meant for the <strong>main-device</strong>.</p>
<p>MQTT topics for the <strong>main-device</strong>:</p>
<pre><code>tedge/measurements
tedge/events/&lt;event-type&gt;
tedge/alarms/&lt;severity&gt;/&lt;alarm-type&gt;
</code></pre>
<p>MQTT topics for a <strong>child-device</strong>, including the <strong>child-device's</strong> specific <code>child-id</code>:</p>
<pre><code>tedge/measurements/&lt;child-id&gt;
tedge/events/&lt;event-type&gt;/&lt;child-id&gt;
tedge/alarms/&lt;severity&gt;/&lt;alarm-type&gt;/&lt;child-id&gt;
</code></pre>
<h2 id="telemetry-data-1"><a class="header" href="#telemetry-data-1">Telemetry Data</a></h2>
<p><strong>Telemetry Data</strong> consists of <strong>measurements</strong>, <strong>events</strong> and <strong>alarms</strong>. Each is defined by a set of data-elements, each with specific behaviour.</p>
<h3 id="measurements"><a class="header" href="#measurements">Measurements</a></h3>
<p><strong>Measurements</strong> carry values from physical <strong>Sensors</strong><sup class="footnote-reference"><a href="#1">1</a></sup> or a device's <strong>Domain Application</strong><sup class="footnote-reference"><a href="#1">1</a></sup>;
e.g. voltage and current of an electricity meter, or current state of the manufacturing control process</p>
<h4 id="mqtt-topics-for-measurements"><a class="header" href="#mqtt-topics-for-measurements">MQTT topics for measurements</a></h4>
<pre><code>tedge/measurements

tedge/measurements/&lt;child-id&gt;
</code></pre>
<h4 id="mqtt-payload-for-measurements"><a class="header" href="#mqtt-payload-for-measurements">MQTT payload for measurements</a></h4>
<p>A measurement can carry a <strong>single value</strong>, or <strong>multiple values</strong> all taken at a single point in time.</p>
<p>One MQTT message can contain a mixture of more than one single-value and multi-value measurements.</p>
<h5 id="example-for-a-single-value-measurement-payload"><a class="header" href="#example-for-a-single-value-measurement-payload">Example for a single-value measurement payload</a></h5>
<pre><code class="language-javascript">{
  &quot;temperature&quot;:               // 'name' of that measurement
                 25.3,         // 'value' of that measurement
  &quot;time&quot;: &quot;2020-10-15T05:30:47+00:00&quot;,  // optional 'timestamp' of that measurement
}
</code></pre>
<h5 id="example-for-a-multi-value-measurement-payload"><a class="header" href="#example-for-a-multi-value-measurement-payload">Example for a multi-value measurement payload</a></h5>
<pre><code class="language-javascript">{
  &quot;current&quot;: {                // 'name' of that measurement
    &quot;L1&quot;: 9.5,               // the 1st 'value' of that measurement, named as &quot;L1&quot;
    &quot;L2&quot;: 1.3                // the 2nd 'value' of that measurement, named as &quot;L2&quot;
    // ...even more values can occur
  },
  &quot;time&quot;: &quot;2020-10-15T05:30:47+00:00&quot;,  // optional 'timestamp' of that measurement
}
</code></pre>
<table><thead><tr><th>Reference</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>a string that identifies the measurement uniquely in context of the device</td></tr>
<tr><td><code>value</code></td><td>the value that was sampled; can be named (especially in context of a multi-value measurement) or unnamed; must be an integer or floating point number</td></tr>
<tr><td><code>timestamp</code></td><td>optional time that indicates when values were sampled; when not provided, thin-edge.io uses the current system time as the time of the sample; when provided must be conform to ISO 8601</td></tr>
</tbody></table>
<h4 id="behaviour-of-measurements"><a class="header" href="#behaviour-of-measurements">Behaviour of measurements</a></h4>
<ul>
<li>thin-edge does not store any historical sampled values for measurements</li>
<li>there is no initialization value for measurements; i.e. a measurement is not visible on thin-edge before the 1st sample was sent to thin-edge</li>
<li>a measurement should never be published as MQTT retain message;
That is as a single retained measurement might be consumed and processed more than once by a consuming software
component (e.g. when that software component restarts and subscribes again).</li>
</ul>
<h3 id="events"><a class="header" href="#events">Events</a></h3>
<p><strong>Events</strong> are notifications that something happened on a device's environment or software system;
e.g. a sensor<sup class="footnote-reference"><a href="#1">1</a></sup> detected something like a door has been closed, or a system notification that e.g. a user has started an ssh session</p>
<h4 id="mqtt-topics-for-events"><a class="header" href="#mqtt-topics-for-events">MQTT topics for events</a></h4>
<pre><code>tedge/events/&lt;event-type&gt;

tedge/events/&lt;event-type&gt;/&lt;child-id&gt;
</code></pre>
<h4 id="mqtt-payload-for-events"><a class="header" href="#mqtt-payload-for-events">MQTT payload for events</a></h4>
<pre><code class="language-javascript">{
  // example of an event
  &quot;text&quot;: &quot;A user just logged in&quot;,     // 'text' message of that event
  &quot;time&quot;: &quot;2021-01-01T05:30:45+00:00&quot;  // optional 'timestamp' of that event
  &quot;someOtherCustomFragment&quot;: {         // optional 'custom fragments'
    &quot;nested&quot;: {
      &quot;value&quot;: &quot;extra info&quot;
    }
  }
}
</code></pre>
<table><thead><tr><th>Reference</th><th>Description</th></tr></thead><tbody>
<tr><td><code>event-type</code></td><td>a string part of the MQTT topic, that identifies the event uniquely in context of the device</td></tr>
<tr><td><code>text</code></td><td>carries a human readable event-text; must be UTF-8 encoded</td></tr>
<tr><td><code>timestamp</code></td><td>optional time that indicates when the event has occurred; when not provided, thin-edge.io uses the current system time as the time of the event; when provided must be conform to ISO 8601</td></tr>
<tr><td><code>custom fragments</code></td><td>additional fields are handled as custom specific information; if the connected cloud supports custom fragments its mapper transfers those accordingly to the cloud</td></tr>
</tbody></table>
<h4 id="behaviour-of-events"><a class="header" href="#behaviour-of-events">Behaviour of events</a></h4>
<ul>
<li>thin-edge does not store any historical occurrences for events</li>
<li>an event should never be published as MQTT retain message;
That is as a single retained event might be consumed and processed more than once by a consuming software
component (e.g. when that software component restarts and subscribes again).</li>
</ul>
<h3 id="alarms"><a class="header" href="#alarms">Alarms</a></h3>
<p><strong>Alarms</strong> are notifications about some critical behaviour of the device's environment or software system;
e.g. when a temperature sensor detects a temperature went out of its valid range</p>
<h4 id="mqtt-topics-for-alarms"><a class="header" href="#mqtt-topics-for-alarms">MQTT topics for alarms</a></h4>
<pre><code>tedge/alarms/&lt;severity&gt;/&lt;alarm-type&gt;

tedge/alarms/&lt;severity&gt;/&lt;alarm-type&gt;/&lt;child-id&gt;
</code></pre>
<h4 id="mqtt-payload-for-alarms"><a class="header" href="#mqtt-payload-for-alarms">MQTT payload for alarms</a></h4>
<pre><code class="language-javascript">{
  // example for an alarm
  &quot;text&quot;: &quot;Temperature is very high&quot;,  // 'text' message of that alarm
  &quot;time&quot;: &quot;2021-01-01T05:30:45+00:00&quot;, // optional 'timestamp' of that alarm
  &quot;someOtherCustomFragment&quot;: {         // optional 'custom fragments'
    &quot;nested&quot;: {
      &quot;value&quot;: &quot;extra info&quot;
    }
  }
}
</code></pre>
<table><thead><tr><th>Reference</th><th>Description</th></tr></thead><tbody>
<tr><td><code>alarm-type</code></td><td>a string part of the MQTT topic, that identifies the alarm uniquely in context of the device</td></tr>
<tr><td><code>severity</code></td><td>a string part of the MQTT topic, that indicates the severity of the alarm; must be <code>critical</code>, <code>major</code>, <code>minor</code> or <code>warning</code></td></tr>
<tr><td><code>text</code></td><td>carries a human readable alarm-text; must be UTF-8 encoded</td></tr>
<tr><td><code>timestamp</code></td><td>optional time that indicates when the alarm has occurred; when not provided, thin-edge.io uses the current system time as the time of the alarm; when provided must be conform to ISO 8601</td></tr>
<tr><td><code>custom fragments</code></td><td>additional fields are handled as custom specific information; if the connected cloud supports custom fragments its mapper transfers those accordingly to the cloud</td></tr>
</tbody></table>
<h4 id="behaviour-of-alarms"><a class="header" href="#behaviour-of-alarms">Behaviour of alarms</a></h4>
<ul>
<li>thin-edge does not store any historical occurrences for alarms</li>
<li><strong>alarms</strong> are stateful; i.e. once raised, an <strong>alarm</strong> is active until it was explicitly cleared by the device's software or the cloud</li>
<li>all alarms shall be published as MQTT retain message to reflect the alarm's stateful behaviour in the broker; The retain messages is kept in
the MQTT broker as long as the alarm is raised. When a raised alarm is gone again, an empty retain message shall be published to clear
the alarm message in the broker.</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>details see &quot;Domain Model&quot; appendix <a href="architecture/./domain-model.html#device-overview">Device Domain</a> --&gt;</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thin-edge-json-format"><a class="header" href="#thin-edge-json-format">Thin Edge JSON format</a></h1>
<p>Thin Edge JSON is a lightweight format used in <code>thin-edge.io</code> to represent measurements data.
This format can be used to represent single-valued measurements, multi-valued measurements
or a combination of both along with some auxiliary data like the timestamp at which the measurement(s) was generated.</p>
<h2 id="single-valued-measurements"><a class="header" href="#single-valued-measurements">Single-valued measurements</a></h2>
<p>Simple single-valued measurements like temperature or pressure measurement with a single value can be expressed as follows:</p>
<pre><code class="language-json">{
    &quot;temperature&quot;: 25
}
</code></pre>
<p>where the key represents the measurement type, and the value represents the measurement value.
The keys can only have alphanumeric characters, and the &quot;_&quot; (underscore) character but must not start with an underscore.
The values can only be numeric.
String, Boolean or other JSON object values are not allowed.</p>
<h2 id="multi-valued-measurements"><a class="header" href="#multi-valued-measurements">Multi-valued measurements</a></h2>
<p>A multi-valued measurement is a measurement that is comprised of multiple values. Here is the representation of a
<code>three_phase_current</code> measurement that consists of <code>L1</code>, <code>L2</code> and <code>L3</code> values, representing the current on each phase:</p>
<pre><code class="language-json">{
    &quot;three_phase_current&quot;: {
      &quot;L1&quot;: 9.5,
      &quot;L2&quot;: 10.3,
      &quot;L3&quot;: 8.8
    }
}
</code></pre>
<p>where the key is the top-level measurement type and value is a JSON object having further key-value pairs 
representing each aspect of the multi-valued measurement.
Only one level of nesting is allowed, meaning the values of the measurement keys at the inner level can only be numeric values.
For example, a multi-level measurement as follows is NOT valid: </p>
<pre><code class="language-json">{ 
    &quot;three_phase_current&quot;: {
        &quot;phase1&quot;: {
            &quot;L1&quot;: 9.5
        },
        &quot;phase2&quot;: {
            &quot;L2&quot;: 10.3
        },
        &quot;phase3&quot;: {
            &quot;L3&quot;: 8.8
        }
    }
}
</code></pre>
<p>because the values at the second level(<code>phase1</code>, <code>phase2</code> and <code>phase3</code>) are not numeric values.</p>
<h2 id="grouping-measurements"><a class="header" href="#grouping-measurements">Grouping measurements</a></h2>
<p>Multiple single-valued and multi-valued measurements can be grouped into a single Thin Edge JSON message as follows:</p>
<pre><code class="language-json">{ 
    &quot;temperature&quot;: 25,
    &quot;three_phase_current&quot;: {
        &quot;L1&quot;: 9.5,
        &quot;L2&quot;: 10.3,
        &quot;L3&quot;: 8.8
    },
    &quot;pressure&quot;: 98 
}
</code></pre>
<p>The grouping of measurements is usually done to represent measurements collected at the same instant of time.</p>
<h2 id="auxiliary-measurement-data"><a class="header" href="#auxiliary-measurement-data">Auxiliary measurement data</a></h2>
<p>When <code>thin-edge.io</code> receives a measurement, it will add a timestamp to it before any further processing.
If the user doesn't want to rely on <code>thin-edge.io</code> generated timestamps,
an explicit timestamp can be provided in the measurement message itself by adding the time value as a string 
in ISO 8601 format using <code>time</code> as the key name, as follows:</p>
<pre><code class="language-json">{ 
    &quot;time&quot;: &quot;2020-10-15T05:30:47+00:00&quot;, 
    &quot;temperature&quot;: 25, 
    &quot;location&quot;: { 
        &quot;latitude&quot;: 32.54, 
        &quot;longitude&quot;: -117.67, 
        &quot;altitude&quot;: 98.6 
    }, 
    &quot;pressure&quot;: 98 
}
</code></pre>
<p>The <code>time</code> key is a reserved keyword and hence can not be used as a measurement key.
The <code>time</code> field must be defined at the root level of the measurement JSON and not allowed at any other level,
like inside the object value of a multi-valued measurement.
Non-numeric values like the ISO 8601 timestamp string are allowed only for such reserved keys and not for regular measurements. </p>
<p>Here is the complete list of reserved keys that has special meanings inside the <code>thin-edge.io</code> framework
and hence must not be used as measurement keys:</p>
<table><thead><tr><th>Key</th><th>Description</th></tr></thead><tbody>
<tr><td>time</td><td>Timestamp in ISO 8601 string format</td></tr>
<tr><td>type</td><td>Internal to <code>thin-edge.io</code></td></tr>
</tbody></table>
<h2 id="sending-measurements-to-thin-edgeio"><a class="header" href="#sending-measurements-to-thin-edgeio">Sending measurements to thin-edge.io</a></h2>
<p>The <code>thin-edge.io</code> framework exposes some MQTT endpoints that can be used by local processes
to exchange data between themselves as well as to get some data forwarded to the cloud.
It will essentially act like an MQTT broker against which you can write your application logic.
Other thin-edge processes can use this broker as an inter-process communication mechanism by publishing and 
subscribing to various MQTT topics.
Any data can be forwarded to the connected cloud-provider as well, by publishing the data to some standard topics.</p>
<p>All topics with the prefix <code>tedge/</code> are reserved by <code>thin-edge.io</code> for this purpose.
To send measurements to <code>thin-edge.io</code>, the measurements represented in Thin Edge JSON format can be published 
to the <code>tedge/measurements</code> topic.
Other processes running on the thin-edge device can subscribe to this topic to process these measurements.</p>
<p>If the messages published to this <code>tedge/measurements</code> topic is not a well-formed Thin Edge JSON, 
then that message won’t be processed by <code>thin-edge.io</code>, not even partially,
and an appropriate error message on why the validation failed will be published to a dedicated <code>tedge/errors</code> topic.
The messages published to this topic will be highly verbose error messages and can be used for any debugging during development.
You should not rely on the structure of these error messages to automate any actions as they are purely textual data 
and bound to change from time-to-time.</p>
<p>More topics will be added under the <code>tedge/</code> topic in future to support more data types like events, alarms etc.
So, it is advised to avoid any sub-topics under <code>tedge/</code> for any other data exchange between processes.</p>
<p>Here is the complete list of topics reserved by <code>thin-edge.io</code> for its internal working:</p>
<table><thead><tr><th>Topic</th><th>Description</th></tr></thead><tbody>
<tr><td><code>tedge/</code></td><td>Reserved root topic of <code>thin-edge.io</code></td></tr>
<tr><td><code>tedge/measurements</code></td><td>Topic to publish measurements to <code>thin-edge.io</code></td></tr>
<tr><td><code>tedge/measurements/&lt;child-id&gt;</code></td><td>Topic to publish measurements to <code>thin-edge.io</code>'s child device</td></tr>
<tr><td><code>tedge/errors</code></td><td>Topic to subscribe to receive any error messages emitted by <code>thin-edge.io</code> while processing measurements</td></tr>
</tbody></table>
<h2 id="sending-measurements-to-the-cloud"><a class="header" href="#sending-measurements-to-the-cloud">Sending measurements to the cloud</a></h2>
<p>The <code>thin-edge.io</code> framework allows users forward all the measurements generated and published to
<code>tedge/measurements</code> MQTT topic in the thin-edge device to any IoT cloud provider that it is connected to,
with the help of a <em>mapper</em> component designed for that cloud.
The responsibility of a mapper is to subscribe to the <code>tedge/measurements</code> topic to receive all incoming measurements 
represented in the cloud vendor neutral Thin Edge JSON format, to a format that the connected cloud understands.
Refer to <a href="architecture/./mapper.html">Cloud Message Mapper Architecture</a> for more details on the mapper component.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tedge-mapper"><a class="header" href="#the-tedge-mapper">The tedge-mapper</a></h1>
<p>The tedge-mapper is a key concept to support multiple cloud providers.
The purpose is to translate
messages written using the cloud-agnostic <a href="architecture/thin-edge-json.html">Thin Edge JSON format</a>,
into cloud-specific messages.</p>
<p>The tedge-mapper is composed of multiple cloud-specific mappers, such as Cumulocity mapper and Azure mapper.
Each mapper is responsible for its dedicated cloud.
These specific mappers are launched by the respective <code>tedge connect</code> command.
For instance, <code>tedge connect c8y</code> establishes a bridge to Cumulocity and launches a Cumulocity mapper
that translates the messages in the background.</p>
<p>A mapper subscribes to the reserved MQTT topic <code>tedge/measurements</code> with the QoS level 1 (at least once).
The messages that arrive in the mapper should be formed in the <a href="architecture/thin-edge-json.html">Thin Edge JSON</a> format.
The mapper verifies whether the arrived messages are correctly formatted,
in case the verification fails, the mapper publishes a corresponded error message
on the topic <code>tedge/errors</code> with the QoS level 1 (at least once).</p>
<p>When the mapper receives a correctly formatted message,
the message will be translated into a cloud-specific format.</p>
<h2 id="cumulocity-mapper"><a class="header" href="#cumulocity-mapper">Cumulocity mapper</a></h2>
<p>The Cumulocity mapper translates <a href="architecture/thin-edge-json.html">Thin Edge JSON</a> into Cumulocity's <a href="https://cumulocity.com/guides/device-sdk/mqtt/#json">JSON via MQTT</a>.
The translated messages are published on the topic <code>c8y/measurement/measurements/create</code> from where they are forwarded to Cumulocity.
This mapper is launched by the <code>tedge connect c8y</code> command, and stopped by the <code>tedge disconnect c8y</code> command.</p>
<p>Example in Thin Edge JSON:</p>
<pre><code class="language-json">{
  &quot;temperature&quot;: 23
}
</code></pre>
<p>Translated into JSON via MQTT by the Cumulocity mapper:</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;ThinEdgeMeasurement&quot;,
  &quot;time&quot;: &quot;2021-04-22T17:05:26.958340390+00:00&quot;,
  &quot;temperature&quot;: {
    &quot;temperature&quot;: {
      &quot;value&quot;: 23
    }
  }
}
</code></pre>
<p>You can see the Cumulocity mapper added the three things which are not defined before translation.</p>
<ol>
<li><code>type</code> is added.</li>
<li><code>time</code> is added.</li>
<li>Another hierarchy level is added, as required by the cumulocity data model.
String <code>temperature</code> is used as fragment and series.</li>
</ol>
<p>(1) The <code>type</code> is a mandatory field in the Cumulocity's JSON via MQTT manner,
therefore, the Cumulocity mapper always adds <code>ThinEdgeMeasurement</code> as a type.
This value is not configurable by users.</p>
<p>(2) <code>time</code> will be added by the mapper <strong>only when it is not specified in a received Thin Edge JSON message</strong>.
In this case, the mapper uses the device's local timezone. If you want another timezone, specify the time filed in Thin Edge JSON.</p>
<p>(3) The mapper uses a measurement name (&quot;temperature&quot; in this example)
as both a fragment type and a fragment series in <a href="https://cumulocity.com/guides/reference/measurements/#examples">Cumulocity's measurements</a>.</p>
<p>After the mapper publishes a message on the topic <code>c8y/measurement/measurements/create</code>,
the message will be transferred to the topic <code>measurement/measurements/create</code> by <a href="architecture/../references/bridged-topics.html">the MQTT bridge</a>.</p>
<h3 id="for-child-devices"><a class="header" href="#for-child-devices">For child devices</a></h3>
<p>The Cumulocity mapper collects measurements not only from the main device but also from child devices.
These measurements are collected under the <code>tedge/measurements/&lt;child-id&gt;</code> topics and forwarded to Cumulocity to corresponding child devices created under the <code>thin-edge.io</code> parent device.
(<code>&lt;child-id&gt;</code> is your desired child device ID.)</p>
<p>The mapper works in the following steps.</p>
<ol>
<li>When the mapper receives a Thin Edge JSON message on the <code>tedge/measurements/&lt;child-id&gt;</code> topic,
the mapper sends a request to create a child device under the <code>thin-edge.io</code> parent device.
The child device is named after the <code>&lt;child-id&gt;</code> topic name, and the type is <code>thin-edge.io-child</code>.</li>
<li>Publish corresponded Cumulocity JSON measurements messages over MQTT.</li>
<li>The child device is created on receipt of the very first measurement for that child device.</li>
</ol>
<p>If the incoming Thin Edge JSON message (published on <code>tedge/measurements/child1</code>) is as follows,</p>
<pre><code class="language-json">{
  &quot;temperature&quot;: 23
}
</code></pre>
<p>it gets translated into JSON via MQTT by the Cumulocity mapper.</p>
<pre><code class="language-json">{
  &quot;type&quot;:&quot;ThinEdgeMeasurement&quot;,
  &quot;externalSource&quot;:{
    &quot;externalId&quot;:&quot;child1&quot;,
    &quot;type&quot;:&quot;c8y_Serial&quot;
  },
  &quot;time&quot;:&quot;2013-06-22T17:03:14+02:00&quot;,
  &quot;temperature&quot;:{
    &quot;temperature&quot;:{
      &quot;value&quot;:23
    }
  }
}
</code></pre>
<h2 id="azure-iot-hub-mapper"><a class="header" href="#azure-iot-hub-mapper">Azure IoT Hub mapper</a></h2>
<blockquote>
<p>Note: Child device measurements are not supported yet on Azure IoT Hub.</p>
</blockquote>
<p>The Azure IoT Hub mapper takes messages formatted in the <a href="architecture/thin-edge-json.html">Thin Edge JSON</a> as input.
It validates if the incoming message is correctly formatted Thin Edge JSON, then outputs the message.
The validated messages are published on the topic <code>az/messages/events/</code> from where they are forwarded to Azure IoT Hub.
This mapper is launched by the <code>tedge connect az</code> command, and stopped by the <code>tedge disconnect az</code> command.</p>
<p>The Azure IoT Hub Mapper processes a message in the following ways.</p>
<ol>
<li>Validates if it is a correct Thin Edge JSON message or not.</li>
<li>Validates the incoming message size is below 255 KB.
<a href="https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-d2c-guidance">The size of all device-to-cloud messages must be up to 256 KB</a>.
The mapper keeps 1 KB as a buffer for the strings added by Azure.</li>
<li>(default) Adds a current timestamp if a timestamp is not included in an incoming message. To stop this behavior, please refer to the following instruction.</li>
</ol>
<p>So, if the input is below,</p>
<pre><code class="language-json">{
  &quot;temperature&quot;: 23
}
</code></pre>
<p>the output of the mapper is</p>
<pre><code class="language-json">{
  &quot;temperature&quot;: 23,
  &quot;time&quot;: &quot;2021-06-01T17:24:48.709803664+02:00&quot;
}
</code></pre>
<h3 id="configure-whether-adding-a-timestamp-or-not"><a class="header" href="#configure-whether-adding-a-timestamp-or-not">Configure whether adding a timestamp or not</a></h3>
<p>However, if you don't want to add a timestamp in the output of Azure IoT Hub Mapper, you can change the behavior by running this:</p>
<pre><code class="language-shell">sudo tedge config set az.mapper.timestamp false 
</code></pre>
<p>After changing the configuration, you need to restart the mapper service by</p>
<pre><code class="language-shell">sudo systemctl restart tedge-mapper-az.service
</code></pre>
<h2 id="aws-mapper"><a class="header" href="#aws-mapper">AWS mapper</a></h2>
<p>The AWS mapper takes messages formatted in the <a href="architecture/thin-edge-json.html">Thin Edge JSON</a> as input.
It validates if the incoming message is correctly formatted Thin Edge JSON, then outputs the message.
The validated messages are published on the topic <code>aws/td/#</code> from where they are forwarded to AWS.
This mapper is launched by the <code>tedge connect aws</code> command, and stopped by the <code>tedge disconnect aws</code> command.</p>
<h2 id="error-cases"><a class="header" href="#error-cases">Error cases</a></h2>
<p>When some error occurs in a mapper process, the mapper publishes a corresponded error message
on the topic <code>tedge/errors</code> with the QoS level 1 (at least once).</p>
<p>Here is an example if you publish invalid Thin Edge JSON messages on <code>tedge/measurements</code>:</p>
<pre><code class="language-shell">tedge mqtt pub tedge/measurements '{&quot;temperature&quot;: 23,&quot;pressure&quot;: 220'
tedge mqtt pub tedge/measurements '{&quot;temperature&quot;: 23,&quot;time&quot;: 220}'
</code></pre>
<p>Then, you'll receive error messages from the mapper on the topic <code>tedge/errors</code>:</p>
<pre><code class="language-shell">tedge mqtt sub tedge/errors
</code></pre>
<pre><code>[tedge/errors] Invalid JSON: Unexpected end of JSON: {&quot;temperature&quot;:23,&quot;pressure&quot;:220
[tedge/errors] Not a timestamp: the time value must be an ISO8601 timestamp string in the YYYY-MM-DDThh:mm:ss.sss.±hh:mm format, not a number.
</code></pre>
<h2 id="topics-used-by-tedge-mapper"><a class="header" href="#topics-used-by-tedge-mapper">Topics used by tedge-mapper</a></h2>
<ul>
<li>
<p>Incoming topics</p>
<ul>
<li><code>tedge/measurements</code></li>
<li><code>tedge/measurements/&lt;child-id&gt;</code> (for Cumulocity)</li>
</ul>
</li>
<li>
<p>Outgoing topics</p>
<ul>
<li><code>tedge/errors</code> (for errors)</li>
<li><code>c8y/measurement/measurements/create</code> (for Cumulocity)</li>
<li><code>az/messages/events/</code> (for Azure IoT Hub)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-management-with-thin-edgeio"><a class="header" href="#software-management-with-thin-edgeio">Software Management with thin-edge.io</a></h1>
<p>With thin-edge.io you can ease the burden of managing packages on your device.
Software Management operates end to end from a cloud down to the OS of your device and reports statuses accordingly.</p>
<h2 id="software-management-components"><a class="header" href="#software-management-components">Software management components</a></h2>
<p>Software Management uses the following 3 components to perform software operations:
<strong>Cloud Mapper</strong>, <strong>Agent</strong>, and <strong>Software Management Plugin</strong>.</p>
<p>You can find the diagrams which explain how those 3 components interact with each other from <a href="https://thin-edge.github.io/thin-edge.io-specs/software-management/sm-agent.html">Software Management Agent Specification</a>.</p>
<h3 id="cloud-mapper"><a class="header" href="#cloud-mapper">Cloud Mapper</a></h3>
<p>The <strong>Cloud Mapper</strong> converts from/to cloud-specific format to/from cloud-agnostic format.
It communicates with the dedicated IoT cloud platform and the <strong>Tedge Agent</strong>.</p>
<h3 id="tedge-agent"><a class="header" href="#tedge-agent">Tedge Agent</a></h3>
<p>The <strong>Tedge Agent</strong> addresses cloud-agnostic software management operations e.g. listing current installed software list, software update, software removal.
Also, the Tedge Agent calls an <strong>SM Plugin(s)</strong> to execute an action defined by a received operation.</p>
<p>The key points are that the <strong>Tedge Agent</strong> is always generic in cloud platforms and software types, and <strong>Cloud Mapper</strong> handles cloud-specific actions.</p>
<h3 id="software-management-plugin"><a class="header" href="#software-management-plugin">Software Management Plugin</a></h3>
<p>The <strong>Software Management Plugin</strong> is dedicated to defining the behaviour of software actions (list, update, remove) per software type (apt, docker, etc.)</p>
<h2 id="related-documents"><a class="header" href="#related-documents">Related documents</a></h2>
<ol>
<li><a href="architecture/../howto-guides/012_install_and_enable_software_management.html">How to install and enable software management?</a></li>
<li><a href="architecture/../tutorials/software-management.html">Manage my device software</a></li>
<li><a href="architecture/../tutorials/write-my-software-management-plugin.html">Write my software management plugin</a></li>
<li><a href="architecture/../references/plugin-api.html">The Software Management Plugin API</a></li>
<li><a href="https://github.com/thin-edge/thin-edge.io-specs/tree/main/src/software-management">Software Management Specification</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-faq"><a class="header" href="#architecture-faq">Architecture FAQ</a></h1>
<h2 id="design-principles"><a class="header" href="#design-principles">Design principles</a></h2>
<p>The primary goal of thin-edge.io is to simplify the connection of edge devices to the cloud
by providing a secure and reliable cloud connectivity as well as a device management agent.
The primary goal of thin-edge.io is the ability to build IoT applications
around a large diversity of components provided by independent actors.</p>
<p>For that purpose, thin-edge.io focuses on:</p>
<ul>
<li><strong>Interoperability</strong> -
Thin-edge.io lets the users integrate components producing or consuming telemetry data,
northbound with cloud platforms, southbound with sensors
as well as for east-west communication between analytics components.</li>
<li><strong>Flexibility</strong> -
Thin-edge.io lets users integrate component provided by different IoT actors,
not even originally designed with thin-edge.io in-mind,
using various technologies and programming languages.</li>
<li><strong>Security</strong> -
Thin-edge.io provides a secure and stable foundation for cloud connections, software/firmware updates,
and remote device management.</li>
<li><strong>Reliability</strong> -
Thin-edge.io components can survive in chaotic environments as network outages and process restarts happen.</li>
<li><strong>Efficiency</strong> -
Thin-edge.io lets users build applications that can run on constrained device hardware and with limited bandwidth networks.</li>
<li><strong>Multi-cloud</strong> -
Thin-edge.io enables users to connect their edge devices with multiple clouds.
The actual cloud used can be decided at run-time by the end-user.</li>
</ul>
<h2 id="why-is-thin-edgeio-an-executable-binary-and-not-a-library"><a class="header" href="#why-is-thin-edgeio-an-executable-binary-and-not-a-library">Why is thin-edge.io an executable binary and not a library?</a></h2>
<p>Interoperability of software components can be addressed along very different approaches.
Thin-edge.io uses dynamic and loose inter-process communication (IPC) using messages exchange over an MQTT bus.</p>
<p>In the past and even today, many clouds provide a library (SDK) to help you connect your code to the cloud.</p>
<p>In thin-edge.io we decided not to follow this approach because:</p>
<ul>
<li>Libraries are <strong>programming language dependent</strong>,
and thus developing a library for a number of  programming languages always excludes developers using other
programming languages. Additionally the effort to support many libraries (C, C++, Rust, Python, etc) is huge,
including adding new features, testing, documentation, examples, stackoverflow.
Essentially we would create multiple small user groups instead of one large user group.</li>
<li>Using an IPC mechanism (and not a library) makes it easier to <strong>dynamically plug</strong> together components during runtime
(instead of recompiling the software). For example, it is easier to add additional protocol stacks
(OPC/UA, modbus, ProfiNet, IO-Link, KNX, ...) to thin-edge.io during run-time. </li>
<li>Linking libraries to existing code can be problematic for some developers, for example for licensing reasons.
While thin-edge.io has a very user-friendly licensing (Apache 2.0),
some developers prefer to reduce the number of libraries that they link to their software.</li>
</ul>
<h2 id="why-does-thin-edgeio-use-mqtt-for-ipc"><a class="header" href="#why-does-thin-edgeio-use-mqtt-for-ipc">Why does thin-edge.io use MQTT for IPC?</a></h2>
<p><a href="https://mqtt.org/">MQTT</a> is a lightweight and flexible messaging protocol widely used by IoT applications.</p>
<p>We were looking for a widely-used, performant IPC mechanism and we investigated a number of alternatives.
In the end, we decided to use MQTT for the following reasons:</p>
<ul>
<li>The approach is used by other industrial IoT organisations and software,
for example by <a href="https://openindustry4.com/">Open Industry 4.0 Alliance</a>.</li>
<li>Existing components (like <a href="https://nodered.org/">Node-RED</a> or <a href="https://collectd.org/">collectd</a> )
that support MQTT can be easily integrated. In this case, thin-edge.io acts as an MQTT proxy:
existing components connect to the local MQTT bus of thin-edge.io,
and thin-edge.io routes the messages to different clouds in a secure and reliable manner.</li>
<li>MQTT is message oriented and bi-directional, which matches well with the event oriented programming model of industrial IoT.</li>
<li>MQTT is available on many platforms, including Linux and Windows.</li>
<li>MQTT client libraries are available for 25+ programming languages (see <a href="https://mqtt.org/software/">MQTT.org</a>]) </li>
<li>MQTT overhead is relatively small in terms of client library size and network overhead.</li>
<li>MQTT is message payload agnostic which enables sending not only JSON messages, but also text, CSV or binary data.</li>
</ul>
<p>Alternatives considered where: DBus, gRPC and REST over HTTP. </p>
<h2 id="why-does-thin-edgeio-use-mqtt-for-cloud-communication"><a class="header" href="#why-does-thin-edgeio-use-mqtt-for-cloud-communication">Why does thin-edge.io use MQTT for cloud communication?</a></h2>
<p><a href="https://mqtt.org/">MQTT</a> is a lightweight and flexible messaging protocol widely used by IoT applications.
Nearly all the IoT cloud platforms provide an MQTT endpoint to consume and publish messages from a fleet of devices.
Therefore, MQTT was an obvious choice for edge to cloud communication.</p>
<p>Using MQTT for cloud communication is not mandatory. You are free to add additional protocols beside MQTT:
Because thin-edge.io has an internal bus, you can implement a bridge to another protocol (e.g. LWM2M or plain HTTPS).
In that case, MQTT is used inside the edge devices, and another protocol is used for external communication.</p>
<h2 id="why-is-the-thin-edgeio-canonical-format-based-on-json"><a class="header" href="#why-is-the-thin-edgeio-canonical-format-based-on-json">Why is the thin-edge.io canonical format based on JSON?</a></h2>
<p><a href="architecture/./thin-edge-json.html">Thin-Edge-Json</a>, the cloud-agnostic message format of thin-edge.io, is based on JSON.</p>
<p>Supported by nearly all programming languages, JSON provides a nice compromise between simplicity and flexibility.
Notably, it features <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a>,
a flexible way to group different data fields that can be read
by consumers with different expectations over the message content.
For instance, a consumer expecting a temperature can process messages
where the temperature measurements are produced along with other kinds of measurements.</p>
<p>Additionally, JSON is supported by most (if not all) cloud vendors, which makes the transformation easier.</p>
<p>JSON is also used by other (Industrial) IoT standards, including OPC/UA and LWM2M.</p>
<h2 id="why-use-rust"><a class="header" href="#why-use-rust">Why use Rust?</a></h2>
<p>The command line interface, and the daemon processes of thin-edge.io are implemented in <a href="https://www.rust-lang.org/">Rust</a>,
<em>a language empowering everyone to build reliable and efficient software</em>.</p>
<p>The main motivation to use Rust is security: Rust avoids many security vulnerabilities and threading issues at compile time.
With the type system of Rust you write software that is free from typical security flaws:
undefined behavior, data races or any memory safety issues.</p>
<p>The second motivation is efficiency. Rust software is typically as efficient as C/C++ software. 
One reason is that Rust does not have (by default) a garbage collector. Instead, memory lifetime is calculated at compile time.</p>
<p>Note that, even if the core of thin-edge.io is written in Rust,
any programming language can be used to implement thin-edge.io components.
For that, one just needs an MQTT library that lets them interact with the thin-edge.io MQTT broker.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thin-edgeio-platform-support"><a class="header" href="#thin-edgeio-platform-support">thin-edge.io platform support</a></h1>
<p>Common requirements for all systems are:</p>
<ul>
<li>minimum 16MB of RAM</li>
<li>systemd (for production systems)</li>
<li>mosquitto minimum version 1.6 (for security reasons we recommend the latest 1.x version)</li>
<li>dpkg (if you want to use our prebuilt deb packages)</li>
</ul>
<h1 id="level-1"><a class="header" href="#level-1">Level 1</a></h1>
<p>Level 1 supported platforms are officially supported and are actively tested in the CI/CD.</p>
<ul>
<li>ARMv7 Raspberry Pi OS 10</li>
<li>ARMv8 Raspberry Pi OS 10</li>
<li>AMD64 Ubuntu 20.04</li>
</ul>
<h1 id="level-2"><a class="header" href="#level-2">Level 2</a></h1>
<p>Level 2 platforms are not officially supported and tested yet, but we know from our experiences that these systems used to work for some maintainers or users. If your os is not listed here, this does not mean it is not working, just give it a try. We are happy to hear about your experience in the Github discussions.</p>
<ul>
<li>Ubuntu 20.04 in WSL (only for development, not for running thin-edge.io due to missing systemd)</li>
<li>AMD64 Debian 10</li>
<li>ARMv6 Raspberry Pi OS 10 (needs to be built for this specific target, please refer to <a href="https://github.com/thin-edge/thin-edge.io/issues/161">Issue-161</a>)</li>
<li>ARMv7 Raspberry Pi OS 11</li>
<li>ARMv8 Raspberry Pi OS 11</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="init-system-configuration-file"><a class="header" href="#init-system-configuration-file">Init System Configuration File</a></h1>
<p>To support multiple init systems and service managers, <code>tedge</code> requires the <code>/etc/tedge/system.toml</code> file.
The file contains configurations about the init system and the supported actions.</p>
<p>The format of the file is:</p>
<pre><code class="language-toml">[init]
name = &quot;systemd&quot;
is_available = [&quot;/bin/systemctl&quot;, &quot;--version&quot;]
restart = [&quot;/bin/systemctl&quot;, &quot;restart&quot;, &quot;{}&quot;]
stop =  [&quot;/bin/systemctl&quot;, &quot;stop&quot;, &quot;{}&quot;]
enable =  [&quot;/bin/systemctl&quot;, &quot;enable&quot;, &quot;{}&quot;]
disable =  [&quot;/bin/systemctl&quot;, &quot;disable&quot;, &quot;{}&quot;]
is_active = [&quot;/bin/systemctl&quot;, &quot;is-active&quot;, &quot;{}&quot;]
</code></pre>
<h2 id="placeholder"><a class="header" href="#placeholder">Placeholder</a></h2>
<p><code>{}</code> will be replaced by a service name (<code>mosquitto</code>, <code>tedge-mapper-c8y</code>, <code>tedge-mapper-az</code>, <code>tedge-mapper-aws</code>, etc.).
For example,</p>
<pre><code class="language-toml">restart = [&quot;/bin/systemctl&quot;, &quot;restart&quot;, &quot;{}&quot;]
</code></pre>
<p>will be interpreted as</p>
<pre><code class="language-shell">/bin/systemctl restart mosquitto
</code></pre>
<h2 id="keys"><a class="header" href="#keys">Keys</a></h2>
<ul>
<li><strong>name</strong>: An identifier of the init system. 
It is used in the output of <code>tedge connect</code> and <code>tedge disconnect</code>.</li>
<li><strong>is_available</strong>: The command to check if the init is available on your system.</li>
<li><strong>restart</strong>: The command to restart a service by the init system.</li>
<li><strong>stop</strong>: The command to stop a service by the init system.</li>
<li><strong>enable</strong>: The command to enable a service by the init system.</li>
<li><strong>disable</strong>: The command to disable a service by the init system.</li>
<li><strong>is_active</strong>: The command to check if the service is running by the init system.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-my-software-management-plugin-1"><a class="header" href="#write-my-software-management-plugin-1">Write my software management plugin</a></h1>
<p><strong>thin-edge.io</strong> Software Management natively supports APT (Debian) packages.
However, there are many package management systems in the world,
and you may want to have a plugin that is suitable for your device.
For such a demand, we provide the <a href="tutorials/./../references/plugin-api.html"><strong>Package Manager Plugin API</strong></a>
to write a custom Software Management plugin in your preferred programming language.</p>
<p>In this tutorial, we will look into the <strong>Package Manager Plugin API</strong>,
and learn how to write your own plugin with a docker plugin shell script example.</p>
<h2 id="create-a-plugin-1"><a class="header" href="#create-a-plugin-1">Create a plugin</a></h2>
<p>Create a <em>docker</em> file in the directory <em>/etc/tedge/sm-plugins/</em>. 
A plugin must be an executable file located in that directory.</p>
<p>Filename: /etc/tedge/sm-plugins/docker</p>
<pre><code class="language-shell">#!/bin/sh

COMMAND=&quot;$1&quot;
IMAGE_NAME=&quot;$2&quot;

case &quot;$COMMAND&quot; in
    list)
        docker image list --format '{{.Repository}}\t{{.Tag}}' || exit 2
        ;;
    install)
        docker pull $IMAGE_NAME || exit 2
        ;;
    remove)
        docker rmi $IMAGE_NAME || exit 2
        ;;
    prepare)
        ;;
    finalize)
        ;;
    update-list)
        exit 1
        ;;
esac
exit 0
</code></pre>
<blockquote>
<p><strong>Info</strong>: the filename will be used as a plugin type to report the software list to a cloud.
If you name it <code>docker.sh</code>, you will see <code>docker.sh</code> as a plugin type in cloud.</p>
</blockquote>
<p>If you execute <code>./docker list</code>, you will see this kind of output.</p>
<pre><code class="language-csv">alpine  3.14
eclipse-mosquitto   2.0-openssl
...
</code></pre>
<p>The Software Management Agent runs executable plugins with a special argument, like <code>list</code>.
Let's call the pre-defined argument such as <code>list</code>, <code>install</code>, and <code>remove</code> a <strong>command</strong> here. 
As you can see from this example, a plugin should be an executable file 
that accepts the commands and outputs to stdout and stderr.
Hence, you can implement a plugin in your preferred language.</p>
<p>Here is the table of the commands that you can use in a plugin.</p>
<table><thead><tr><th>Command</th><th>Input arguments</th><th>Expected output</th><th>Description</th></tr></thead><tbody>
<tr><td>list</td><td>-</td><td>lines with tab separated values</td><td>Returns the list of software modules that have been installed with this plugin.</td></tr>
<tr><td>prepare</td><td>-</td><td>-</td><td>Executes the provided actions before a sequence of install and remove commands.</td></tr>
<tr><td>finalize</td><td>-</td><td>-</td><td>Executes the provided actions after a sequence of install and remove commands.</td></tr>
<tr><td>install</td><td>NAME [--module-version VERSION] [--file FILE]</td><td>-</td><td>Executes the action of installation.</td></tr>
<tr><td>remove</td><td>NAME [--module-version VERSION]</td><td>-</td><td>Executes the action of uninstallation.</td></tr>
<tr><td>update-list</td><td>COMMAND NAME [--module-version VERSION] [--file FILE]</td><td>-</td><td>Executes the list of <code>install</code> and <code>remove</code> commands.</td></tr>
</tbody></table>
<p>The order of the commands invoked by the Software Management Agent is:
<code>prepare</code> -&gt; <code>update-list</code> or [<code>install</code>, <code>remove</code>] -&gt;<code>finalize</code></p>
<blockquote>
<p><strong>info</strong>: There is no guarantee of the order between <code>install</code> and <code>remove</code>.
If you need a specific order, use <code>update-list</code> command instead.</p>
</blockquote>
<p>In the following sections, we will dive into each command and other rules deeply.</p>
<h2 id="input-output-and-errors-1"><a class="header" href="#input-output-and-errors-1">Input, Output, and Errors</a></h2>
<p>Before we dive into each command, we should clarify the basic rules of plugins.</p>
<h3 id="input-1"><a class="header" href="#input-1">Input</a></h3>
<p>The command themselves and further required arguments must be given as command-line arguments.
The only exception is <code>update-list</code>, which requires <strong>stdin</strong> input.</p>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<p>The <strong>stdout</strong> and <strong>stderr</strong> of the process running a plugin command are captured by the Software Management Agent.</p>
<h3 id="exit-status-1"><a class="header" href="#exit-status-1">Exit status</a></h3>
<p>The exit status of plugins are interpreted by sm-agent as follows:</p>
<ul>
<li><strong>0</strong>: success.</li>
<li><strong>1</strong>: usage. The command arguments cannot be interpreted, and the command has not been launched.</li>
<li><strong>2</strong>: failure. The command failed and there is no point to retry.</li>
<li><strong>3</strong>: retry. The command failed but might be successful later (for instance, when the network will be back).</li>
</ul>
<h2 id="list-1"><a class="header" href="#list-1">List</a></h2>
<p>The <code>list</code> command is responsible to return the list of the installed software modules.</p>
<p>Rules:</p>
<ul>
<li>This command takes no arguments.</li>
<li>The list is returned using <a href="https://en.wikipedia.org/wiki/Tab-separated_values">CSV with tabulations as separators</a>,
including:
<ul>
<li><strong>name</strong>: the name of the software module, e.g. <code>mosquitto</code>.
This name is the name that has been used to install it and that needs to be used to remove it.</li>
<li><strong>version</strong>: the version currently installed.
This is a string that can only be interpreted in the context of the plugin.
&gt;Note: If the version is not present for a module, then list can return only the module name without trailing tabulation.
Given that your plugin is named <code>docker</code>, then the Software Management Agent calls</li>
</ul>
</li>
</ul>
<pre><code class="language-shell">sudo /etc/tedge/sm-plugins/docker list
</code></pre>
<p>to report the list of software modules installed.</p>
<blockquote>
<p><strong>Important</strong>: the Software Management Agent executes a plugin using <code>sudo</code> and as <code>tedge-agent</code> user.</p>
</blockquote>
<p><code>docker</code> should output in the CSV with tabulations as separators like</p>
<pre><code class="language-csv">alpine  3.14
eclipse-mosquitto   2.0-openssl
rust    1.51-alpine
</code></pre>
<p>with exit code <code>0</code> (successful).</p>
<p>In most cases, the output of the <code>list</code> command is multi-lines.
The line separator should be <code>\n</code>.</p>
<p>A plugin must return a CSV line per software module, using a tabulation <code>\t</code> as separator.
If there is no version field then only the module name will be returned.
In the <em>docker</em> file example, the following command outputs CSV structures with tabulations as separator.</p>
<pre><code class="language-shell">docker image list --format '{{.Repository}}\t{{.Tag}}'
</code></pre>
<h2 id="prepare-1"><a class="header" href="#prepare-1">Prepare</a></h2>
<p>The <code>prepare</code> command is invoked by the sm-agent before a sequence of install and remove commands.</p>
<p>Rules:</p>
<ul>
<li>It takes no argument and no output is expected.</li>
<li>If the <code>prepare</code> command fails,
then the whole Software Management operation is cancelled.</li>
</ul>
<p>For many plugins, this command has nothing specific to do, and can simply return with a <code>0</code> exit status.</p>
<p>In some plugin types, this <code>prepare</code> command can help you.
For example, assume that you want to implement a plugin for APT,
and want to run <code>apt-get update</code> always before calling the <code>install</code> command. 
In this example, the <code>prepare</code> command is the right place to invoke <code>apt-get update</code>.</p>
<h2 id="finalize-1"><a class="header" href="#finalize-1">Finalize</a></h2>
<p>The <code>finalize</code> command closes a sequence of install and removes commands started by a prepare command.</p>
<p>Rules:</p>
<ul>
<li>It takes no argument and no output is expected.</li>
<li>If the <code>finalize</code> command fails, then the whole Software Management operation is reported as failed,
even if all the atomic actions have been successfully completed.</li>
</ul>
<p>Similar to the <code>prepare</code> plugin, you must define the command even if you want nothing in the <code>finalize</code> command.</p>
<p>The command can be used in several situations. For example, </p>
<ul>
<li>remove any unnecessary software module after a sequence of actions.</li>
<li>commit or roll back the sequence of actions.</li>
<li>restart any processes using the modules,
e.g. restart the analytics engines if the modules have changed.</li>
</ul>
<h2 id="install-1"><a class="header" href="#install-1">Install</a></h2>
<p>The <code>install</code> command installs a software module, possibly of some expected version.
A plugin must be executable in the below format.</p>
<pre><code class="language-shell">myplugin install NAME [--module-version VERSION] [--file FILE]
</code></pre>
<p>This command takes 1 mandatory argument and has 2 optional flags.</p>
<ul>
<li><strong>NAME</strong>: the name of the software module to be installed, e.g. <code>mosquitto</code>. (Mandatory)</li>
<li><strong>VERSION</strong>: the version to be installed. e.g. <code>1.5.7-1+deb10u1</code>.
The version can be blank, so it's recommended to define the behaviour if a version is not provided. 
For example, always installs the &quot;latest&quot; version if a version is not provided. (Optional)</li>
<li><strong>FILE</strong>: the path to the software to be installed. (Optional)</li>
</ul>
<p>The installation phase may fail due to the following reasons.
An error must be reported if:</p>
<ul>
<li>The module name is unknown.</li>
<li>There is no version for the module that matches the constraint provided by the <code>--module-version</code> option.</li>
<li>The file content provided by <code>--file</code> option:
<ul>
<li>is not in the expected format,</li>
<li>doesn't correspond to the software module name,</li>
<li>has a version that doesn't match the constraint provided by the <code>--module-version</code> option (if any).</li>
</ul>
</li>
<li>The module cannot be downloaded.</li>
<li>The module cannot be installed.</li>
</ul>
<p>At the API level, there is no command to distinguish install or upgrade.</p>
<p>Back to the first <em>docker</em> example, it doesn't address the case with version. 
Let's expand the example file as below.</p>
<p>Filename: /etc/tedge/sm-plugins/docker</p>
<pre><code class="language-shell">#!/bin/sh

COMMAND=&quot;$1&quot;
IMAGE_NAME=&quot;$2&quot;
VERSION_FLAG=&quot;$3&quot;
IMAGE_TAG=&quot;$4&quot;

case &quot;$COMMAND&quot; in
    list)
        docker image list --format '{{.Repository}}\t{{.Tag}}' || exit 2
        ;;
    install)
        if [ $# -eq 2 ]; then
            docker pull $IMAGE_NAME || exit 2
        elif [ $# -eq 4 ] &amp;&amp; [ $VERSION_FLAG = &quot;--module-version&quot; ]; then
            docker pull $IMAGE_NAME:$IMAGE_TAG || exit 2
        else
            echo &quot;Invalid arguments&quot;
            exit 1
        fi
        ;;
    remove)
        if [ $# -eq 2 ]; then
            docker rmi $IMAGE_NAME || exit 2
        elif [ $# -eq 4 ] &amp;&amp; [ $VERSION_FLAG = &quot;--module-version&quot; ]; then
            docker rmi $IMAGE_NAME:$IMAGE_TAG || exit 2
        else
            echo &quot;Invalid arguments&quot;
            exit 1
        fi
        ;;
    prepare)
        ;;
    finalize)
        ;;
    update-list)
        exit 1
        ;;
esac
exit 0
</code></pre>
<p>Pay attention to the exit statuses.
In case of invalid arguments, the plugin returns <code>1</code>.
If a command is executed but fails, the plugin returns <code>2</code>.
Each exit status is defined <a href="tutorials/write-my-software-management-plugin.html#exit-status">here</a>.</p>
<p>If the given NAME is <code>mosquitto</code>, and the given VERSION is <code>1.5.7-1+deb10u1</code>,
the Software Management Agent calls</p>
<pre><code class="language-shell">sudo /etc/tedge/sm-plugins/docker install mosquitto --module-version 1.5.7-1+deb10u1
</code></pre>
<p>Then, the plugin executes</p>
<pre><code class="language-shell">docker pull mosquitto:1.5.7-1+deb10u1
</code></pre>
<h2 id="remove-1"><a class="header" href="#remove-1">Remove</a></h2>
<p>The <code>remove</code> command uninstalls a software module,
and possibly its dependencies if no other modules are dependent on those.
A plugin must be executable in the below format.</p>
<pre><code class="language-shell">myplugin remove NAME [--module-version VERSION]
</code></pre>
<p>This command takes 1 mandatory argument and 1 optional argument with a flag.</p>
<ul>
<li><strong>NAME</strong>: the name of the software module to be removed, e.g. <code>mosquitto</code>. (Mandatory)</li>
<li><strong>VERSION</strong>: the version to be installed. e.g. <code>1.5.7-1+deb10u1</code>.
The version can be blank, so it's recommended to define the behaviour if a version is not provided.
For example, uninstall a software module regardless of its version if a version is not provided. (Optional)</li>
</ul>
<p>The uninstallation phase can be failed due to several reasons. An error must be reported if:</p>
<ul>
<li>The module name is unknown.</li>
<li>The module cannot be uninstalled.</li>
</ul>
<p>Back to the first <em>docker</em> plugin example,
if the NAME is <code>mosquitto</code>, and the VERSION is <code>1.5.7-1+deb10u1</code>,
the Software Management Agent calls</p>
<pre><code class="language-shell">sudo /etc/tedge/sm-plugins/docker remove mosquitto --module-version 1.5.7-1+deb10u1
</code></pre>
<p>Then, the plugin executes</p>
<pre><code class="language-shell">docker rmi mosquitto:1.5.7-1+deb10u1
</code></pre>
<h2 id="update-list-1"><a class="header" href="#update-list-1">Update-list</a></h2>
<p>The <code>update-list</code> command accepts a list of software modules and associated operations as <code>install</code> or <code>remove</code>.
This basically achieves the same purpose as original commands install and remove,
but gets passed all software modules to be processed in one command.
This can be needed when an order of processing software modules is relevant.</p>
<p>In other words, you can choose a combination of the <code>install</code> or <code>remove</code> commands or this <code>update-list</code> command up to your requirement.
If you don't want to use <code>update-list</code>, the plugin must return <code>1</code> like the first <em>docker</em> plugin example.</p>
<pre><code class="language-shell">case &quot;$COMMAND&quot; in
    ...
    update-list)
        exit 1
        ;;
esac
</code></pre>
<p>Let's expand the first <em>docker</em> plugin example to use <code>update-list</code>.
First, learn what is the input of <code>update-list</code>.</p>
<p>The Software Management Agent calls a plugin as below. Note that each argument is tab separated:</p>
<pre><code class="language-shell">sudo /etc/tedge/sm-plugins/docker update-list &lt;&lt;EOF
  install	name1	version1
  install	name2		path2
  remove	name3	version3
  remove	name4
EOF
</code></pre>
<p>The point is that it doesn't take any command-line argument, 
but the software action list is sent through <strong>stdin</strong>.</p>
<p>The behaviour of operations <code>install</code> and <code>remove</code> is the same as for original commands <code>install</code> and <code>remove</code>. 
The above input is equivalent to the use of original commands (<code>install</code> and <code>remove</code>):</p>
<pre><code class="language-shell">/etc/tedge/sm-plugins/docker install name1 --module-version version1
/etc/tedge/sm-plugins/docker install name2 --file path2
/etc/tedge/sm-plugins/docker remove &quot;name 3&quot; --module-version version3
/etc/tedge/sm-plugins/docker remove name4
</code></pre>
<p>To make the <em>docker</em> plugin accept a list of install and remove actions,
let's change the file as below.
Note that this example works only in bash.</p>
<p>Filename: /etc/tedge/sm-plugins/docker</p>
<pre><code class="language-shell">#!/bin/bash

COMMAND=&quot;$1&quot;

case &quot;$COMMAND&quot; in
    list)
        docker image list --format '{{.Repository}}\t{{.Tag}}' || exit 2
        ;;
    install)
        echo docker pull &quot;$2:$3&quot;
        ;;
    remove)
        echo docker rmi &quot;$2:$3&quot;
        ;;
    prepare)
        ;;
    finalize)
        ;;
    update-list)
        while IFS=$'\t' read -r ACTION MODULE VERSION FILE
        do
            bash -c &quot;$0 $ACTION $MODULE $VERSION&quot;
        done
        ;;
esac
exit 0
</code></pre>
<p>You can find that <code>install</code> and <code>remove</code> are replaced by <code>update-list</code>.
<code>update-list</code> should define the behaviour to read line by line for the case <code>install</code> and <code>remove</code>.</p>
<p>Also, <code>update-list</code> must be <strong>fail-fast</strong>.
That example exists immediately if one of the commands fails.</p>
<h2 id="project-references-1"><a class="header" href="#project-references-1">Project references</a></h2>
<p>You can also refer to:</p>
<ul>
<li>the specification of the <a href="https://github.com/thin-edge/thin-edge.io/blob/main/docs/src/references/plugin-api.md">Package Manager Plugin API</a>.</li>
<li><a href="https://github.com/thin-edge/thin-edge.io/tree/main/plugins/tedge_apt_plugin">the APT plugin</a> written in Rust. </li>
<li><a href="https://github.com/thin-edge/thin-edge.io/blob/main/sm/plugins/tedge_docker_plugin/tedge_docker_plugin.sh">the example Docker plugin</a> written in POSIX standard shell script.
This plugin can install/remove docker containers using docker image tags. This plugin is <strong>not</strong> to be used in production without necessary enhancements. It is to be used only as a reference to write your own plugin.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="device-configuration-management-using-cumulocity"><a class="header" href="#device-configuration-management-using-cumulocity">Device Configuration Management using Cumulocity</a></h1>
<p>Thin-edge provides an operation plugin to
<a href="https://cumulocity.com/guides/users-guide/device-management/#to-retrieve-and-apply-a-configuration-snapshot-to-a-device-which-supports-multiple-configuration-types">manage device configurations using Cumulocity</a>.</p>
<ul>
<li>This management is bi-directional:
<ul>
<li>A device can be taken as reference, all the managed files being uploaded to the cloud
and stored there as a configuration snapshot.</li>
<li>A configuration snapshot can be pushed from the cloud to any devices of the same type,
i.e. supporting the same kind of configuration files.</li>
</ul>
</li>
<li>With this operation plugin, the device owner defines the list of files
(usually configuration files, but not necessarily),
that will be managed from the cloud tenant.</li>
<li>Notably, <strong>the plugin configuration itself is managed from the cloud</strong>,
meaning, the device owner can update from the cloud the list of files to be managed.</li>
<li>Cumulocity manages the configuration files accordingly to their type,
a name that is chosen by the device owner to categorise each configuration.
By default, the full path of a configuration file on the device is used as its type.</li>
<li>When files are downloaded from the cloud to the device,
<strong>these files are stored in a temporary directory first</strong>.
They are atomically moved to their target path, only after a fully successful download.
The aim is to avoid breaking the system with half downloaded files.</li>
<li>When a downloaded file is copied to its target, the unix user, group and mod are preserved.</li>
<li>Once a snapshot has been downloaded from Cumulocity to the device,
<strong>the plugin publishes a notification message on the local thin-edge MQTT bus</strong>.
The device software has to subscribe to these messages if any action is required,
say to check the content of file, to preprocess it or to restart a daemon.</li>
<li>The configuration plugin also manage configuration files for child-devices connected to the main thin-edge device.
From the cloud point of view, these child-devices are configured exactly using the same user interface,
with the ability to focus on a device, to upload the current configuration files,
to push configuration updates and to configure the list of configuration files.
Behind the scene, the behavior is a bit more complex,
the configuration plugin acting as a proxy between the cloud and the child-devices.
The configuration updates are downloaded from the cloud on the thin-edge device
then made available to the child-devices over HTTP,
MQTT being used to notify the availability of these configuration updates.
The child-device software has to subscribe to these messages, download the corresponding updates,
and notify the main thin-edge configuration plugin of the update status.
A similar combination of MQTT and HTTP is used to let the main device
request a child device for a configuration file actually in use.</li>
<li>In other words, the responsibilities of the plugin are:
<ul>
<li>to define the list of files under configuration management</li>
<li>to notify the cloud when this list is updated,</li>
<li>to upload these files to the cloud on demand,</li>
<li>to download the files pushed from the cloud,</li>
<li>to make sure that the target files are updated atomically after successful download,</li>
<li>to notify the device software when the configuration is updated,</li>
<li>to act as proxy for the child-devices that need configuration management,</li>
<li>to publish over a local HTTP server the configuration files and make them available to the child-devices,</li>
<li>to notify the child-devices when configuration updates are available,</li>
<li>to notify the child-devices when current configuration files are requested from the cloud,</li>
<li>to consume over a local HTTP server the configuration files pushed by the child-devices.</li>
</ul>
</li>
<li>By contrast, the plugin is not responsible for:
<ul>
<li>checking the uploaded files are well-formed,</li>
<li>restarting the configured processes,</li>
<li>installing the configuration files on the child-devices.</li>
</ul>
</li>
<li>For each child-device, a device-specific software component, referred to as a child-device agent, 
is required to listen for configuration related MQTT notification
and behave accordingly along the protocol defined by this configuration plugin.
<ul>
<li>Being specific to each type of child devices, this software has to be implemented specifically.</li>
<li>This software can be installed on the child device.</li>
<li>This software can also be installed on the main device,
when the target device cannot be altered
or connected to the main device over MQTT and HTTP.</li>
</ul>
</li>
<li>A user-specific component, installed on the device,
can implement more sophisticated configuration use-cases by:
<ul>
<li>listening for configuration updates on the local thin-edge MQTT bus,</li>
<li>restarting the appropriate processes when appropriate,</li>
<li>declaring intermediate files as the managed files,
to have the opportunity to check or update their content
before moving them to the actual targets.</li>
</ul>
</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Assuming the configuration plugin <code>c8y-configuration-plugin</code>
has been installed in <code>/usr/bin/c8y-configuration-plugin</code>,
two files must be added under <code>/etc/tedge/operations/c8y/</code>
to declare that this plugin supports two Cumulocity operations:
uploading and downloading configuration files
(which respective SmartRest2 codes are <code>526</code> and <code>524</code>).</p>
<p>These two files can be created using the <code>c8y-configuration-plugin --init</code> option:</p>
<pre><code class="language-shell">sudo c8y-configuration-plugin --init
</code></pre>
<pre><code class="language-shell">ls -l /etc/tedge/operations/c8y/c8y_UploadConfigFile
</code></pre>
<pre><code>-rw-r--r-- 1 tedge tedge 95 Mar 22 14:24 /etc/tedge/operations/c8y/c8y_UploadConfigFile
</code></pre>
<pre><code class="language-shell">ls -l /etc/tedge/operations/c8y/c8y_DownloadConfigFile
</code></pre>
<pre><code>-rw-r--r-- 1 tedge tedge 97 Mar 22 14:24 /etc/tedge/operations/c8y/c8y_DownloadConfigFile
</code></pre>
<p>The configuration plugin can also act as configuration proxy for child-devices.
For that to work for a child device named <code>$CHILD_DEVICE_ID</code>,
two files must be added under <code>/etc/tedge/operations/c8y/$CHILD_DEVICE_ID</code>
in order to declare the associated capabilities to Cumulocity.
These files are just empty files owned by the <code>tedge</code> user.</p>
<p>These two files are created by the plugin when the child-device agent uploads its supported configuration list to thin-edge.</p>
<pre><code class="language-shell">ls -l /etc/tedge/operations/c8y/child-1
</code></pre>
<pre><code>-rw-r--r-- 1 tedge tedge 97 Mar 22 14:24 /etc/tedge/operations/c8y/child-1/c8y_DownloadConfigFile
-rw-r--r-- 1 tedge tedge 95 Mar 22 14:24 /etc/tedge/operations/c8y/child-1/c8y_UploadConfigFile
</code></pre>
<pre><code class="language-shell">ls -l /etc/tedge/operations/c8y/child-2
</code></pre>
<pre><code>-rw-r--r-- 1 tedge tedge 97 Mar 22 14:24 /etc/tedge/operations/c8y/child-2/c8y_DownloadConfigFile
-rw-r--r-- 1 tedge tedge 95 Mar 22 14:24 /etc/tedge/operations/c8y/child-2/c8y_UploadConfigFile
</code></pre>
<p>The <code>c8y-configuration-plugin</code> has to be run as a daemon on the device, the latter being connected to Cumulocity.</p>
<p>On start of <code>tedge-mapper c8y</code> and on <code>/etc/tedge/operations/c8y</code> directory updates,
one can observe on the MQTT bus of the thin-edge device
the messages sent to Cumulocity to declare the capabilities of the main and child devices.
Here, the capabilities to upload and download configuration files
(possibly with other capabilities added independently):</p>
<pre><code class="language-shell">tedge mqtt sub 'c8y/s/us/#'
</code></pre>
<pre><code>[c8y/s/us] 114,c8y_Restart,c8y_SoftwareList,c8y_UploadConfigFile,c8y_DownloadConfigFile
[c8y/s/us/child-1] 114,c8y_UploadConfigFile,c8y_DownloadConfigFile
[c8y/s/us/child-2] 114,c8y_UploadConfigFile,c8y_DownloadConfigFile
</code></pre>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>The <code>c8y-configuration-plugin</code> configuration is stored by default under <code>/etc/tedge/c8y/c8y-configuration-plugin.toml</code></p>
<p>This <a href="https://toml.io/en/">TOML</a> file defines the list of files to be managed from the cloud tenant.
Each configuration file is defined by a record with:</p>
<ul>
<li>The full <code>path</code> to the file.</li>
<li>An optional configuration <code>type</code>. If not provided, the <code>path</code> is used as <code>type</code>.
This <code>type</code> is used to declare the configuration file to Cumulocity and then to trigger operations on that file.
All the configuration <code>type</code>s for the main device are declared to the cloud on start
and on change of the <code>c8y/c8y-configuration-plugin.toml</code> file.</li>
<li>Optional unix file ownership: <code>user</code>, <code>group</code> and octal <code>mode</code>.<br />
These are only used when a configuration file pushed from the cloud doesn't exist on the device.
When a configuration file is already present on the device, this plugin never changes file ownership,
ignoring these parameters.</li>
</ul>
<pre><code class="language-shell">cat /etc/tedge/c8y/c8y-configuration-plugin.toml
</code></pre>
<pre><code class="language-toml">files = [
  { path = '/etc/tedge/tedge.toml', type = 'tedge.toml' },
  { path = '/etc/tedge/mosquitto-conf/c8y-bridge.conf' },
  { path = '/etc/tedge/mosquitto-conf/tedge-mosquitto.conf' },
  { path = '/etc/mosquitto/mosquitto.conf', type = 'mosquitto', user = 'mosquitto', group = 'mosquitto', mode = 0o644 }
]
</code></pre>
<p>Along this <code>c8y-configuration-plugin</code> configuration for the main device,
the configuration plugin expects a configuration file per child device
that needs to be configured from the cloud.</p>
<ul>
<li>The configuration for a child-device <code>$CHILD_DEVICE_ID</code>
is stored by default under <code>/etc/tedge/c8y/$CHILD_DEVICE_ID/c8y-configuration-plugin.toml</code></li>
<li>These TOML files have the same schema as for the main device,
listing the configuration <code>files</code> and giving for each a <code>path</code> and possibly a <code>type</code>.</li>
<li>Note that the <code>path</code> doesn't need to be a file path.
It can be a key path in some registry of the child device or any name that makes sense for the child device.</li>
<li>As for the main device, the <code>type</code> is used to name the configuration file on the cloud.
All the configuration <code>type</code>s for a child devices are declared to the cloud on start
and on change of the <code>c8y/$CHILD_DEVICE_ID/c8y-configuration-plugin.toml</code> file.</li>
<li>The <code>user</code>, <code>group</code> and <code>mode</code> can be provided for a child-device configuration file,
notably when used by the child device,
but will not be used by the main device if provided.</li>
</ul>
<pre><code class="language-shell">ls /etc/tedge/c8y/*/c8y-configuration-plugin.toml
</code></pre>
<pre><code>/etc/tedge/c8y/child-1/c8y-configuration-plugin.toml 
/etc/tedge/c8y/child-2/c8y-configuration-plugin.toml
</code></pre>
<pre><code class="language-shell">cat /etc/tedge/c8y/child-1/c8y-configuration-plugin.toml
</code></pre>
<pre><code class="language-toml">files = [
  { path = '/var/camera.conf', type = 'camera' },
  { path = '/var/sounds.conf', type = 'sounds' },
]
</code></pre>
<pre><code class="language-shell">cat /etc/tedge/c8y/child-2/c8y-configuration-plugin.toml
</code></pre>
<pre><code class="language-toml">files = [
  { path = '/var/ai/model' },
]
</code></pre>
<p>On start and when one of these files is updated, the configuration plugin sends
one <a href="https://cumulocity.com/guides/10.14.0/reference/smartrest-two/#119"><code>119 SmartRest2 message</code></a> per device
to Cumulocity with the set of <code>type</code>s listed by the configuration
(adding implicitly the <code>c8y-configuration-plugin</code> themselves).
These messages can be observed over the MQTT bus of the thin-edge device.
In the case of the example, 3 messages are sent - one for the main device and 2 for the child devices:</p>
<pre><code class="language-shell">tedge mqtt sub 'c8y/s/us/#'
</code></pre>
<pre><code>[c8y/s/us] 119,c8y-configuration-plugin,tedge.toml,/etc/tedge/mosquitto-conf/c8y-bridge.conf,/etc/tedge/mosquitto-conf/tedge-mosquitto.conf,mosquitto
[c8y/s/us/child-1] 119,c8y-configuration-plugin,camera,sounds
[c8y/s/us/child-2] 119,c8y-configuration-plugin,/var/ai/model
</code></pre>
<p>Note that:</p>
<ul>
<li>The file <code>/etc/tedge/c8y/c8y-configuration-plugin.toml</code> itself doesn't need to be listed.
This is implied, so the list can <em>always</em> be configured from the cloud.
The <code>type</code> for this self configuration file is <code>c8y-configuration-plugin</code>.</li>
<li>If the file <code>/etc/tedge/c8y/c8y-configuration-plugin.toml</code>
is not found, empty, ill-formed or not-readable
then only <code>c8y-configuration-plugin.toml</code> is managed from the cloud.</li>
<li>Similarly, when there is a directory <code>/etc/tedge/c8y/$CHILD_DEVICE_ID/</code>
but the file <code>/etc/tedge/c8y/$CHILD_DEVICE_ID/c8y-configuration-plugin.toml</code>
is not found , empty, ill-formed or not-readable
then only <code>$CHILD_DEVICE_ID/c8y-configuration-plugin.toml</code> is managed from the cloud.</li>
<li>If the file <code>/etc/tedge/c8y/c8y-configuration-plugin.toml</code> is ill-formed
or cannot be read then an error is logged, but the operation proceed
as if the file were empty.
Similarly, for any file <code>/etc/tedge/c8y/$CHILD_DEVICE_ID/c8y-configuration-plugin.toml</code>.
So, the issue can be fixed from the cloud.</li>
</ul>
<p>The behavior of the <code>c8y-configuration-plugin</code> is also controlled
by the configuration of thin-edge:</p>
<ul>
<li><code>tedge config get mqtt.bind_address</code>: the address of the local MQTT bus.</li>
<li><code>tedge config get mqtt.port</code>: the TCP port of the local MQTT bus.</li>
<li><code>tedge config get tmp.path</code>: the directory where the files are updated
before being copied atomically to their targets.</li>
</ul>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><code class="language-shell">c8y-configuration-plugin --help
</code></pre>
<pre><code>c8y-configuration-plugin 0.9.0

Thin-edge device configuration management for Cumulocity

USAGE:
    c8y-configuration-plugin [OPTIONS]

OPTIONS:
        --config-dir &lt;CONFIG_DIR&gt;      [default: /etc/tedge]
        --debug                        Turn-on the debug log level
    -h, --help                         Print help information
    -V, --version                      Print version information

    On start, `c8y-configuration-plugin` notifies the cloud tenant of the managed configuration files,
    listed in `CONFIG_DIR/c8y/c8y-configuration-plugin.toml`, sending this list with a `119` on `c8y/s/us`.
    `c8y-configuration-plugin` subscribes then to `c8y/s/ds` listening for configuration operation
    requests (messages `524` and `526`).
    notifying the Cumulocity tenant of their progress (messages `501`, `502` and `503`).
    
    The thin-edge `CONFIG_DIR` is used to find where:
    * to store the configuration file: `c8y/c8y-configuration-plugin.toml`
    * to store temporary files on download: `tedge config get tmp.path`,
    * to connect the MQTT bus: `tedge config get mqtt.port`.
</code></pre>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>The <code>c8y-configuration-plugin</code> reports progress and errors on its <code>stderr</code>.</p>
<ul>
<li>All upload and download operation requests are logged, when received and when completed,
with one line per file.</li>
<li>All changes to the list of managed file is logged, one line per change.</li>
<li>All errors are reported with the operation context (upload or download? which file?).</li>
</ul>
<h2 id="notifications"><a class="header" href="#notifications">Notifications</a></h2>
<p>When a configuration file is successfully downloaded from the cloud,
the <code>c8y-configuration-plugin</code> service notifies this update over MQTT.</p>
<ul>
<li>The notification messages are published on the topic <code>tedge/configuration_change/{type}</code>,
where <code>{type}</code> is the type of the configuration file that have been updated,
for instance <code>tedge/configuration_change/tedge.toml</code></li>
<li>Each message provides the path to the freshly updated file as in <code>{ &quot;path&quot;: &quot;/etc/tedge/tedge.toml&quot; }</code>.</li>
</ul>
<p>Note that:</p>
<ul>
<li>If no specific type has been assigned to a configuration file, then the path to this file is used as its type.
Update notifications for that file are then published on the topic <code>tedge/configuration_change/{path}</code>,
for instance <code>tedge/configuration_change//etc/tedge/mosquitto-conf/c8y-bridge.conf</code>.</li>
<li>Since the type of configuration file is used as an MQTT topic name, the characters <code>#</code> and <code>+</code> cannot be used in a type name.
If such a character is used in a type name (or in the path of a configuration file without explicit type),
then the whole plugin configuration <code>/etc/tedge/c8y/c8y-configuration-plugin.toml</code> is considered ill-formed.</li>
</ul>
<h2 id="configuration-protocol-between-thin-edge-and-the-child-devices"><a class="header" href="#configuration-protocol-between-thin-edge-and-the-child-devices">Configuration protocol between thin-edge and the child-devices</a></h2>
<p>The configuration plugin <code>c8y-configuration-plugin</code> can act as a proxy between the cloud and a child-device.
However, for that to work, a client, referred to as child-device-agent, must be installed on the child device
to perform the actual configuration updates pushed by thin-edge on behalf of the cloud.
While the configuration plugin tells what need to be updated and when,
only the child device specific client can control where and how these updates can be applied.</p>
<ul>
<li>The responsibility of the configuration plugin is to
<ul>
<li>interact with the cloud, receiving the configuration update and configuration snapshot requests,</li>
<li>download/upload configuration files from/to the cloud to be exchanged with the child device</li>
<li>exchange configuration files with the child device via an HTTP-based file transfer service over the local network,</li>
<li>notify the child devices via MQTT when configuration files are to be updated or requested from the cloud,</li>
<li>listen to child devices' configuration operation status via MQTT messages and mirror those to the cloud.</li>
</ul>
</li>
<li>The child-device agent is an MQTT+HTTP client that
<ul>
<li>interact with the child-device system, accessing the actual configuration files</li>
<li>connect the main thin-edge device over the local MQTT bus,</li>
<li>listen over MQTT for configuration snapshot and update requests,</li>
<li>download and upload the configuration files on demand,</li>
<li>notify the progress of the configuration operations to the main device via MQTT.</li>
</ul>
</li>
</ul>
<p>For each kind of child device such an agent has to be implemented
and installed on the child-device hardware.
For a child device with closed software that cannot be altered,
one might have to install that agent with protocol adaptor on the main device.</p>
<p>Here is the protocol that has to be implemented by the child-device configuration client.
This protocol covers 4 interactions, the child devices:</p>
<ol>
<li>Connecting to thin-edge</li>
<li>Uploading its supported configuration list to thin-edge</li>
<li>Downloading configuration file updates from thin-edge</li>
<li>Uploading current configuration files to thin-edge</li>
<li>Notifying thin-edge of configuration operation status updates</li>
</ol>
<h3 id="the-child-device-connects-to-the-thin-edge-parent-device"><a class="header" href="#the-child-device-connects-to-the-thin-edge-parent-device">The child device connects to the thin-edge parent device</a></h3>
<p>From a TCP point of view, the child devices act as clients
and all the connections to thin-edge are established by the child devices.</p>
<ul>
<li>Thin-edge opens two ports for MQTT and HTTP over the local network.
These ports are controlled on the main device <code>tedge config</code>:
<ul>
<li><code>mqtt.external.bind_address</code></li>
<li><code>mqtt.external.port</code></li>
<li><code>http.external.port</code></li>
</ul>
</li>
<li>The child devices must know the main device IP address.
<ul>
<li>This is the address set for <code>mqtt.external.bind_address</code> on the main device.</li>
<li>For the very specific case, where the child-device agent runs on the main device,
this connection address can be the <code>localhost</code>.</li>
</ul>
</li>
<li>On start, the child-device agent for configuration management,
must connect over MQTT to thin-edge device.
<ul>
<li>It must use a session name that is unique on the thin-edge bus.
<code>&quot;$CHILD_DEVICE_ID/configuration&quot;</code> is the recommendation.</li>
<li>It must subscribe to <code>tedge/$CHILD_DEVICE_ID/commands/req/#</code> to receive requests.</li>
<li>It has to publish responses under <code>tedge/$CHILD_DEVICE_ID/commands/res/#</code>.</li>
</ul>
</li>
<li>On demand, the child-device agent has to send HTTP requests to thin-edge.
<ul>
<li>These requests are REST requests (GET/PUT/DELETE) to exchange files.</li>
<li>The urls are forged by thin-edge telling the child devices
where to get and put configuration files.</li>
</ul>
</li>
<li>Currently, all these connections are done without TLS support.
<ul>
<li>Hence, the main device must be configured so these MQTT and HTTP ports
are only open on a local trusted network.</li>
</ul>
</li>
</ul>
<h3 id="the-child-device-downloads-configuration-updates-on-notification"><a class="header" href="#the-child-device-downloads-configuration-updates-on-notification">The child device downloads configuration updates on notification</a></h3>
<p>When a configuration file for a child device
is received from the cloud by the <code>c8y-configuration-plugin</code> daemon,
the configuration plugin manages the transfer of this file to the child device
and notifies the cloud on the progress of this configuration update operation.</p>
<p>The following diagram captures the required interactions between all relevant parties:</p>
<pre class="mermaid">sequenceDiagram
    participant C8Y Cloud
    participant C8Y Config Plugin
    participant Tedge Agent
    participant Child Device Agent
    

        C8Y Cloud-&gt;&gt;C8Y Config Plugin: MQTT: c8y_DownloadConfigFile request with `child-id`, `type` and `c8y.url` for the updated config file
        C8Y Config Plugin-&gt;&gt;C8Y Cloud: Download the config-file from `c8y.url`
        C8Y Config Plugin-&gt;&gt;Tedge Agent: Move the downloaded config file to file-transfer repository and generate a `tedge.url` for it
        C8Y Config Plugin-&gt;&gt;Child Device Agent: MQTT: config_update request to `child-id` with `type` and `tedge.url`

        Child Device Agent -&gt;&gt; C8Y Config Plugin: MQTT: config_update response with operation status: &quot;executing&quot; 
        C8Y Config Plugin -&gt;&gt; C8Y Cloud: MQTT: Update c8y_DownloadConfigFile operation status to &quot;EXECUTING&quot;
        Child Device Agent-&gt;&gt;Tedge Agent: HTTP: Download the config file update from `tedge.url`
        Child Device Agent-&gt;&gt;Child Device Agent: Apply downloaded file as new config for `type`
        Child Device Agent -&gt;&gt; C8Y Config Plugin: MQTT: config_update response with operation status: &quot;successful&quot; 

        C8Y Config Plugin -&gt;&gt; C8Y Cloud: MQTT: Update c8y_DownloadConfigFile operation status to &quot;SUCCESSFUL&quot;
        C8Y Config Plugin -&gt;&gt; C8Y Config Plugin: Remove local copy of config file update from local filesystem
</pre>
<ol>
<li>On reception of a configuration update for a child device named <code>$CHILD_DEVICE_ID</code>
of a file <code>{ path = $PATH, type = $TYPE }</code> defined in <code>$CHILD_DEVICE_ID/c8y-configuration-plugin.toml</code> 
the <code>c8y-configuration-plugin</code> downloads the new configuration content to the temporary directory defined by <code>tedge config get tmp.path</code>,
and, on success, moves this content under the thin-edge file transfer HTTP root.
<ul>
<li>The file is moved to <code>$TEDGE_HTTP_ROOT/$CHILD_DEVICE_ID/config_update/$TYPE</code>
making this file available under <code>http://$TEDGE_HTTP/tedge/file-transfer/$CHILD_DEVICE_ID/config_update/$TYPE</code>.</li>
<li>Note that the <code>$TYPE</code> is by default the <code>$PATH</code> if not provided by the configuration.</li>
</ul>
</li>
<li>Once the updated configuration is available over the local HTTP file transfer service,
the <code>c8y-configuration-plugin</code> notifies the child device by publishing an MQTT message.
<ul>
<li>The topic is <code>tedge/$CHILD_DEVICE_ID/commands/req/config_update</code></li>
<li>The payload is a JSON record with 3 fields
<ul>
<li><code>&quot;url&quot;: &quot;http://$TEDGE_HTTP/tedge/file-transfer/$CHILD_DEVICE_ID/config_update/$TYPE&quot;</code></li>
<li><code>&quot;path&quot;: &quot;$PATH&quot;</code></li>
<li><code>&quot;type&quot;: &quot;$TYPE&quot;</code> (if no <code>type</code> has been specified, then this field is omitted)</li>
</ul>
</li>
</ul>
</li>
<li>On reception of a configuration update on the topic <code>tedge/$CHILD_DEVICE_ID/commands/req/config_update</code>,
The child-device agent for configuration management:
<ol>
<li><code>GET</code>s the content from the <code>url</code> specified by the notification message.</li>
<li>Uses the <code>path</code> and <code>type</code> information to apply the new configuration content.
Note that these pieces of information are provided by the child-device agent itself,
and make sense only in the specific context of the device operating system and software.</li>
</ol>
</li>
<li>While the configuration update is applied,
the child-device agent for configuration management,
notifies thin-edge over MQTT about the progress of this operation.
<ol>
<li>These messages are published on the topic
<code>tedge/$CHILD_DEVICE_ID/commands/res/config_update</code></li>
<li>There is three different payloads to notify the configuration operation started,
succeed or failed for some reason.</li>
<li>All these payloads are JSON records with 3 required fields:
<ul>
<li><code>&quot;status&quot;: &quot;$STATUS&quot;</code> where the status is either &quot;executing&quot;, &quot;successful&quot; or &quot;failed&quot;</li>
<li><code>&quot;path&quot;: &quot;$PATH&quot;</code></li>
<li><code>&quot;type&quot;: &quot;$TYPE&quot;</code></li>
<li><code>&quot;reason&quot;: &quot;$ERROR_MSG&quot;</code> telling the cause of the error if any.</li>
</ul>
</li>
<li>The child-device agent must send at least a success or an error message,
depending on the success of the <code>GET</code> and configuration operations.
It should also send an executing message before starting to process the request.</li>
</ol>
</li>
<li>On reception an operation status message,
the <code>c8y-configuration-plugin</code> notifies the cloud accordingly.
<ol>
<li>When a success or error message is finally received,
then the configuration plugin cleans up all the temporary resources,
notably removing the file under <code>$TEDGE_HTTP_ROOT/$CHILD_DEVICE_ID/config_update/$TYPE</code>.</li>
<li>If a notification message is received while none is expected,
i.e with a configuration file <code>type</code> that doesn't exist under <code>TEDGE_HTTP_ROOT/$CHILD_DEVICE_ID/config_update/</code>,
then this notification message is ignored.</li>
</ol>
</li>
</ol>
<h3 id="the-child-device-uploads-current-configuration-snapshot-on-request"><a class="header" href="#the-child-device-uploads-current-configuration-snapshot-on-request">The child device uploads current configuration snapshot on request</a></h3>
<p>The configuration files actually used by a child device can be requested from the cloud.
As for configuration updates, the <code>c8y-configuration-plugin</code> daemon drive these requests
using a combination of MQTT to notify the child device of the request
and of HTTP to let the child device <code>PUT</code> the requested file.</p>
<p>The following diagram captures the required interactions between all relevant parties:</p>
<pre class="mermaid">sequenceDiagram
    participant C8Y Cloud
    participant C8Y Config Plugin
    participant Tedge Agent
    participant Child Device Agent

        C8Y Cloud -&gt;&gt; C8Y Config Plugin: MQTT: c8y_UploadConfigFile request with `child-id` and `type`
        C8Y Config Plugin -&gt;&gt; C8Y Config Plugin: Generate file-transfer repository `tedge.url` for child device using `child-id` and `type`
        C8Y Config Plugin -&gt;&gt; Child Device Agent: MQTT: config_snapshot request to `child-id` with `type` and `tedge.url`

        Child Device Agent -&gt;&gt; C8Y Config Plugin: MQTT: config_snapshot response with operation status: &quot;executing&quot; 
        C8Y Config Plugin -&gt;&gt; C8Y Cloud: MQTT: Update c8y_UploadConfigFile operation status to &quot;EXECUTING&quot;
        Child Device Agent -&gt;&gt; Tedge Agent: HTTP: Upload config file content for `type` to `tedge.url`
        Child Device Agent -&gt;&gt; C8Y Config Plugin: MQTT: config_snapshot response with operation status: &quot;successful&quot; 

        C8Y Config Plugin -&gt;&gt; Tedge Agent: Retrieve the config file uploaded by the child device from file-transfer repository
        C8Y Config Plugin -&gt;&gt; C8Y Cloud: HTTP: Upload the config file to cloud
        C8Y Config Plugin -&gt;&gt; C8Y Cloud: MQTT: Update c8y_UploadConfigFile operation status to &quot;SUCCESSFUL&quot;
        C8Y Config Plugin -&gt;&gt; C8Y Config Plugin: Remove local copy of config file snapshot from local filesystem
</pre>
<ol>
<li>On reception of a configuration request for a child device named <code>$CHILD_DEVICE_ID</code>
for a file <code>{ path = $PATH, type = $TYPE }</code> defined in <code>$CHILD_DEVICE_ID/c8y-configuration-plugin.toml</code>
the <code>c8y-configuration-plugin</code> forwards this request to the child device by publishing an MQTT message
telling which configuration is expected and where to upload it.
<ul>
<li>The topic is <code>tedge/$CHILD_DEVICE_ID/commands/req/config_snapshot</code></li>
<li>The payload is a JSON record with 3 fields
<ul>
<li><code>&quot;url&quot;: &quot;http://$TEDGE_HTTP/tedge/file-transfer/$CHILD_DEVICE_ID/config_snapshot/$TYPE&quot;</code></li>
<li><code>&quot;path&quot;: &quot;$PATH&quot;</code></li>
<li><code>&quot;type&quot;: &quot;$TYPE&quot;</code> (if no <code>type</code> has been specified, then this field is omitted) </li>
</ul>
</li>
<li>The <code>url</code> conveys the fact the <code>c8y-configuration-plugin</code> expects that, on transfer success,
the file will be stored <code>$TEDGE_HTTP_ROOT/$CHILD_DEVICE_ID/config_snapshot/$TYPE</code>.
Note that when the <code>$TYPE</code> is not explicitly defined in <code>$CHILD_DEVICE_ID/c8y-configuration-plugin.toml</code>,
then the <code>$PATH</code> is used as the configuration type.</li>
</ul>
</li>
<li>On reception of a configuration request on the topic <code>tedge/$CHILD_DEVICE_ID/commands/req/config_snapshot</code>,
The child-device agent for configuration management:
<ol>
<li>Uses the <code>path</code> and <code>type</code> information to retrieve the requested configuration content.
Note that these pieces of information are provided by the child-device agent itself,
and make sense only in the specific context of the device operating system and software.</li>
<li><code>PUT</code>s the content to the <code>url</code> specified by the request message.</li>
</ol>
</li>
<li>The child-device agent for configuration management,
notifies thin-edge over MQTT about the progress of the configuration snapshot request.
<ol>
<li>These messages are published on the topic
<code>tedge/$CHILD_DEVICE_ID/commands/res/config_snapshot</code></li>
<li>There is three different payloads to notify the configuration operation started,
succeed or failed for some reason.</li>
<li>All these payloads are JSON records with 3 required fields:
<ul>
<li><code>&quot;status&quot;: &quot;$STATUS&quot;</code> where the status is either &quot;executing&quot;, &quot;successful&quot; or &quot;failed&quot;</li>
<li><code>&quot;path&quot;: &quot;$PATH&quot;</code></li>
<li><code>&quot;type&quot;: &quot;$TYPE&quot;</code></li>
<li><code>&quot;reason&quot;: &quot;$ERROR_MSG&quot;</code> telling the cause of the error if any.</li>
</ul>
</li>
<li>The child-device agent must send at least a success or an error message,
depending on the success of the <code>PUT</code> operation.
It should also send an executing message before starting to process the request.</li>
</ol>
</li>
<li>On reception of an operation status message,
the <code>c8y-configuration-plugin</code> notifies the cloud accordingly.
<ol>
<li>When a success message is received,
then the configuration plugin transfers to the cloud the content <code>PUT</code> by the child-device
under <code>$TEDGE_HTTP_ROOT/$CHILD_DEVICE_ID/config_snapshot/$TYPE</code> and
finally removes this file when acknowledged by the cloud.</li>
<li>If a notification message is received while none is expected for this type of configuration,
then this notification message is ignored.</li>
</ol>
</li>
</ol>
<h3 id="the-child-device-uploads-its-configuration-file-list-on-start-and-on-change"><a class="header" href="#the-child-device-uploads-its-configuration-file-list-on-start-and-on-change">The child device uploads its configuration file list on start and on change</a></h3>
<p>The configuration files for a child device <code>$CHILD_DEVICE_ID</code> are defined in
the file <code>$TEDGE_CONFIG_DIR/c8y/$CHILD_DEVICE_ID/c8y-configuration-plugin.toml</code> on the thin-edge device.
But, the content of this file must be provided by the child-device agent
by uploading a <code>c8y-configuration-plugin.toml</code> with <code>&quot;type&quot;: &quot;c8y-configuration-plugin&quot;</code> in its prescribed format.</p>
<p>The child-device must upload this file on its startup as well as when updated,
as if it received a config snapshot request for <code>c8y-configuration-plugin</code> type as follows:</p>
<ol>
<li>
<p>On start-up, the child-device uploads this file (as well as on update of this file list),
as if it received a config snapshot request for <code>c8y-configuration-plugin</code> type:</p>
<ol>
<li>Generate a <code>c8y-configuration-plugin.toml</code> with the supported config list in the prescribed format.</li>
<li>Uploads this file to <code>http://$TEDGE_HTTP/tedge/file-transfer/$CHILD_DEVICE_ID/c8y-configuration-plugin</code> with a <code>PUT</code> call.</li>
<li>On success of the upload, the child-device agent
notifies the <code>c8y-configuration-plugin</code> with an MQTT message published on the topic
<code>tedge/$CHILD_DEVICE_ID/commands/res/config_snapshot</code>
with the payload containing a JSON record with <code>&quot;type&quot;: &quot;c8y-configuration-plugin&quot;</code> but without the <code>status</code> field.</li>
<li>Note that there is no need to send executing notification messages here,
since this is a spontaneous operation and not triggered by an explicit config snapshot request.</li>
</ol>
</li>
<li>
<p>The plugin does the following on receipt of the response with <code>&quot;type&quot;: &quot;c8y-configuration-plugin&quot;</code>,
received for the upload on <code>tedge/$CHILD_DEVICE_ID/commands/res/config_snapshot</code> topic.</p>
<ol>
<li>Take a copy of the transferred file under <code>$TEDGE_HTTP_ROOT/$CHILD_DEVICE_ID/config_snapshot/c8y-configuration-plugin</code>
and puts this copy under <code>$TEDGE_CONFIG_DIR/c8y/$CHILD_DEVICE_ID/c8y-configuration-plugin.toml</code></li>
<li>Create two empty files <code>c8y_DownloadConfigFile</code> and <code>c8y_UploadConfigFile</code> under <code>/etc/tedge/operations/c8y/$CHILD_DEVICE_ID</code>
to inform the Cumulocity mapper that this child device supports configuration management.
On creation of these files, the mapper will automatically update child device twin with these supported operations.</li>
<li>Send a SmartREST 119 message with the list of configuration files listed in the file
(to which this file <code>$TEDGE_CONFIG_DIR/c8y/$CHILD_DEVICE_ID/c8y-configuration-plugin.toml</code>
is implicitly added with type <code>c8y-configuration-plugin</code>).</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apis"><a class="header" href="#apis">APIs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-bridged-topics"><a class="header" href="#the-bridged-topics">The bridged topics</a></h1>
<p>This document lists the MQTT topics that are supported by the thin-edge.io.</p>
<h2 id="thin-edge-json-mqtt-topics"><a class="header" href="#thin-edge-json-mqtt-topics">Thin Edge JSON MQTT Topics</a></h2>
<p>To send the Thin Edge JSON measurements to a supported IoT cloud, the device should publish the measurements on
<strong>tedge/measurements</strong> topic. Internally the tedge-mapper will consume the measurements from this topic, translates and
send them to the cloud that the device has been connected to by the <code>tedge connect</code> command.</p>
<h2 id="cumulocity-mqtt-topics"><a class="header" href="#cumulocity-mqtt-topics">Cumulocity MQTT Topics</a></h2>
<p>The topics follow the below format
<code>&lt;protocol&gt;/&lt;direction&gt;&lt;type&gt;[/&lt;template&gt;][/&lt;child id&gt;]</code></p>
<table><thead><tr><th>Protocol</th><th>Direction</th><th>Type</th></tr></thead><tbody>
<tr><td>s = standard</td><td>u = upstream</td><td>s =  static (built-in)</td></tr>
<tr><td>t = transient</td><td>d = downstream</td><td>c = custom (device-defined)</td></tr>
<tr><td></td><td>e = error</td><td>d = default (defined in connect)</td></tr>
<tr><td></td><td></td><td>t = template</td></tr>
<tr><td></td><td></td><td>cr = credentials</td></tr>
</tbody></table>
<h3 id="smartrest20-topics"><a class="header" href="#smartrest20-topics">SmartREST2.0 topics</a></h3>
<p>All Cumulocity topics have been prefixed by <code>c8y/</code>.</p>
<ul>
<li>
<p>Registration topics
c8y/s/dcr
c8y/s/ucr</p>
</li>
<li>
<p>Creating template topics
c8y/s/dt
c8y/s/ut/#</p>
</li>
<li>
<p>Static templates topics
c8y/s/us
c8y/t/us
c8y/q/us
c8y/c/us
c8y/s/ds</p>
</li>
<li>
<p>Debug topics
c8y/s/e</p>
</li>
<li>
<p>Custom template topics
c8y/s/uc/#
c8y/t/uc/#
c8y/q/uc/#
c8y/c/uc/#
c8y/s/dc/#</p>
</li>
</ul>
<h3 id="c8y-json-topics"><a class="header" href="#c8y-json-topics">C8Y JSON topics</a></h3>
<pre><code>c8y/measurement/measurements/create
c8y/error
</code></pre>
<p>You can find more information about Cumulocity topics
<a href="https://tech.forums.softwareag.com/t/cumulocity-iot-tips-and-tricks-mqtt-cheat-sheet/237187">Here</a></p>
<h2 id="azure-mqtt-topics"><a class="header" href="#azure-mqtt-topics">Azure MQTT Topics</a></h2>
<p>MQTT clients on Thin Edge device must use the below topics to communicate with the Azure cloud.
The Azure topics are prefixed by <code>az/</code>.</p>
<ul>
<li>
<p><code>az/messages/events/</code>  - Use this topic to send the messages from device to
cloud. The messages are forwarded to the Azure topic named
<code>devices/{device_id}/messages/events/</code> where device_id is the Thin Edge device
id.</p>
</li>
<li>
<p><code>az/messages/devicebound/#</code> - Use this topic to subscribe for the messages that were sent from cloud to device.
Any message published by Azure on one the subtopics of <code>devices/{device_id}/messages/devicebound/#</code>
is republished here.</p>
</li>
</ul>
<h2 id="aws-mqtt-topics"><a class="header" href="#aws-mqtt-topics">AWS MQTT Topics</a></h2>
<p>MQTT clients on Thin Edge device must use the below topics to communicate with the AWS cloud.
The AWS topics are prefixed by <code>aws/</code>.</p>
<ul>
<li>
<p><code>aws/td/#</code> - Use this topic to send the messages from device to cloud. The messages are forwarded to the AWS topic
named <code>thinedge/{device_id}/td</code> where {device_id} is the Thin Edge device id.</p>
</li>
<li>
<p><code>aws/cmd/#</code> - Use this topic to subscribe for the messages that were sent from cloud to device. Any message published
by AWS on one the subtopics of <code>thinedge/{device_id}/cmd/#</code> is republished here.</p>
</li>
<li>
<p><code>aws/shadow/#</code> Use this topic to interact with unnamed and named shadows of the device. It's mapped to
<code>$aws/things/{device_id}/shadow</code>.</p>
</li>
</ul>
<h2 id="collectd-topics"><a class="header" href="#collectd-topics">Collectd topics</a></h2>
<p>When the <a href="references/../tutorials/device-monitoring.html">device monitoring feature is enabled</a>,
monitoring metrics are emitted by <code>collectd</code> on a hierarchy of MQTT topics.</p>
<ul>
<li><code>collectd/$HOSTNAME/#</code> - All the metrics collected on the device (which hostname is <code>$HOSTNAME</code>).</li>
<li><code>collectd/$HOSTNAME/$PLUGIN/#</code> - All the metrics collected by a given collectd plugin, named <code>$PLUGIN</code>.</li>
<li><code>collectd/$HOSTNAME/$PLUGIN/$METRIC</code> - The topic for a given metric, named <code>$METRIC</code>.
All the measurements are published as a pair of a Unix timestamp in milli-seconds and a numeric value
in the format <code>$TIMESTAMP:$VALUE</code>. For example, <code>1623155717:98.6</code>.</li>
</ul>
<p>The <code>collectd-mapper</code> daemon process ingests these measurements and emits translated messages
the <code>tedge/measurements</code> topic.</p>
<ul>
<li>This process groups the atomic measurements that have been received during the same time-window (currently 200 ms)</li>
<li>and produces a single thin-edge-json for the whole group of measurements.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-management-plugin-api"><a class="header" href="#software-management-plugin-api">Software Management Plugin API</a></h1>
<p>Thin-edge uses plugins to delegate software management operations to the appropriate package manager/installer. The plugins are responsible for: installation of packages, uninstalls and queries.</p>
<ul>
<li>A package manager plugin acts as a facade for a specific package manager.</li>
<li>A plugin is an executable that follows the <a href="references/plugin-api.html#plugin-api">plugin API</a>.</li>
<li>On a device, several plugins can be installed to deal with different kinds of software modules.</li>
<li>The filename of a plugin is used by thin-edge to determine the appropriate plugin for a software module.</li>
<li>All the actions on a software module are directed to the plugin bearing the name that matches the module type name.</li>
<li>The plugins are loaded and invoked by the sm-agent in a systematic order (in practice the alphanumerical order of their names in the file system).</li>
<li>The software modules to be installed/removed are also passed to the plugins in a consistent order.</li>
<li>Among all the plugins, one can be marked as the default plugin using the <code>tedge config</code> cli.</li>
<li>The default plugin is invoked when an incoming software module in the cloud request doesn't contain any explicit type annotation.</li>
<li>Several plugins can co-exist for a given package manager as long as they are given different names.
Each can implement a specific software management policy.
For instance, for a debian package manager, several plugins can concurrently be installed, say one named <code>apt</code> to handle regular packages from the public apt repository and another named <code>company-apt</code> to install packages from a company's private package repository.</li>
</ul>
<h2 id="plugin-repository"><a class="header" href="#plugin-repository">Plugin repository</a></h2>
<ul>
<li>To be used by thin-edge, a plugin has to be stored in the directory <code>/etc/tedge/sm-plugins</code>.</li>
<li>A plugin must be named after the software module type as specified in the cloud request.
That is, a plugin named <code>apt</code> handles software modules that are defined with type <code>apt</code> in the cloud request.
Consequently a plugin to handle software module defined for <code>docker</code> must be named <code>docker</code>.</li>
<li>The same plugin can be given different names, using virtual links.</li>
<li>When there are multiple plugins on a device, one can be marked as the default plugin using the command
<pre><code class="language-sh">tedge config set software.plugin.default &lt;plugin-name&gt;
</code></pre>
</li>
<li>If there's only one plugin available on a device, it is selected by default, even without an explicit configuration.</li>
</ul>
<p>On start-up, the sm-agent registers the plugins as follows:</p>
<ol>
<li>Iterate over the executable file of the directory <code>/etc/tedge/sm-plugins</code>.</li>
<li>Check the executable is indeed a plugin, calling the <a href="references/plugin-api.html#the-list-command"><code>list</code></a> command.</li>
</ol>
<h2 id="plugin-api"><a class="header" href="#plugin-api">Plugin API</a></h2>
<ul>
<li>A plugin must implement all the commands used by the sm-agent of thin-edge,
and support all the options for these commands.</li>
<li>A plugin should not support extra commands or options.</li>
<li>A plugin might have a configuration file.
<ul>
<li>It can be a list of remote repositories, or a list of software modules to be excluded.</li>
<li>These configuration files can be managed from the cloud via the configuration management feature.</li>
</ul>
</li>
</ul>
<h3 id="input-output-and-errors-2"><a class="header" href="#input-output-and-errors-2">Input, Output and Errors</a></h3>
<ul>
<li>The plugins are called by the sm-agent using a child process for each action.</li>
<li>Besides the <code>update-list</code> command, there is no input beyond the command arguments, and a plugin that does not
implement <code>update-list</code> can close its <code>stdin</code>.</li>
<li>The <code>stdout</code> and <code>stderr</code> of the process running a plugin command are captured by the sm-agent.
<ul>
<li>These streams don't have to be the streams returned by the underlying package manager.
It can be a one sentence summary of the error, redirecting the administrator to the package manager logs.</li>
</ul>
</li>
<li>A plugin must return the appropriate exit status after each command.
<ul>
<li>It is important that under no circumstances should the error status of the underlying package manager should be reported, instead return one of the exit codes mentioned in the next section.</li>
</ul>
</li>
<li>The exit status are interpreted by the sm-agent as follows:
<ul>
<li><strong><code>0</code></strong>: success.</li>
<li><strong><code>1</code></strong>: usage. The command arguments cannot be interpreted, and the command has not been launched.</li>
<li><strong><code>2</code></strong>: failure. The command failed and there is no point to retry.</li>
<li><strong><code>3</code></strong>: retry. The command failed but might be successful later (for instance, when the network will be back).</li>
</ul>
</li>
<li>If the command fails to return within 5 minutes, the sm-agent reports a timeout error:
<ul>
<li><strong><code>4</code></strong>: timeout.</li>
</ul>
</li>
</ul>
<h3 id="the-list-command"><a class="header" href="#the-list-command">The <code>list</code> command</a></h3>
<p>When called with the <code>list</code> command, a plugin returns the list of software modules that have been installed with this plugin,
using tab separated values.</p>
<pre><code class="language-shell">debian-plugin list
</code></pre>
<pre><code>...
collectd-core  5.8.1-1.3
mosquitto   1.5.7-1+deb10u1
...
</code></pre>
<p>Contract:</p>
<ul>
<li>This command take no arguments.</li>
<li>If an error status is returned, the executable is removed from the list of plugins.</li>
<li>The list is returned using <a href="https://en.wikipedia.org/wiki/Tab-separated_values">CSV with tabulations as separators</a>.
Each line has two values separated by a tab: the name of the module then the version of that module.
If there is no version for a module, then the trailing tabulation is not required and be skipped.</li>
</ul>
<h3 id="the-prepare-command"><a class="header" href="#the-prepare-command">The <code>prepare</code> command</a></h3>
<p>The <code>prepare</code> command is invoked by the sm-agent before a sequence of install and remove commands</p>
<pre><code class="language-shell">/etc/tedge/sm-plugins/debian prepare
/etc/tedge/sm-plugins/debian install x
/etc/tedge/sm-plugins/debian install y
/etc/tedge/sm-plugins/debian remove z
/etc/tedge/sm-plugins/debian finalize
</code></pre>
<p>For many plugins this command will do nothing. However, It gives an opportunity to the plugin to:</p>
<ul>
<li>Update the dependencies before an operation, *i.e. a sequence of actions.
Notably, a debian plugin can update the <code>apt</code> cache issuing an <code>apt-get update</code>.</li>
<li>Start a transaction, in case the plugin is able to manage rollbacks.</li>
</ul>
<p>Contract:</p>
<ul>
<li>This command take no arguments.</li>
<li>No output is expected.</li>
<li>If the <code>prepare</code> command fails, then the planned sequences of actions (.i.e the whole sm operation) is cancelled.</li>
</ul>
<h3 id="the-finalize-command"><a class="header" href="#the-finalize-command">The <code>finalize</code> command</a></h3>
<p>The <code>finalize</code> command closes a sequence of install and remove commands started by a <code>prepare</code> command.</p>
<p>This can be a no-op, but this is also an opportunity to:</p>
<ul>
<li>Remove any unnecessary software module after a sequence of actions.</li>
<li>Commit or rollback the sequence of actions.</li>
<li>Restart any processes using the modules, e.g. restart the analytics engines if the modules have changed</li>
</ul>
<p>Contract:</p>
<ul>
<li>This command take no arguments.</li>
<li>No output is expected.</li>
<li>This command might check (but doesn't have to) that the list of install and remove command has been consistent.
<ul>
<li>For instance, a plugin might raise an error after the sequence <code>prepare;install a; remove a-dependency; finalize</code>.</li>
</ul>
</li>
<li>If the <code>finalize</code> command fails, then the planned sequences of actions (.i.e the whole sm operation) is reported as failed,
even if all the atomic actions has been successfully completed.</li>
</ul>
<h3 id="the-install-command"><a class="header" href="#the-install-command">The <code>install</code> command</a></h3>
<p>The <code>install</code> command installs a software module, possibly of some expected version.</p>
<pre><code class="language-shell">plugin install NAME [--module-version VERSION] [--file FILE]
</code></pre>
<p>Contract:</p>
<ul>
<li>The command requires a single mandatory argument: the software module name.
<ul>
<li>This module name is meaningful only to the plugin.</li>
</ul>
</li>
<li>An optional version string can be provided.
<ul>
<li>This version string is meaningful only to the plugin
and is transmitted unchanged from the cloud to the plugin.</li>
<li>The version string can include constraints (as at least that version),
from the sm-agent viewpoint this is no more than a string.</li>
<li>If no version is provided the plugin is free to install the more appropriate version.</li>
</ul>
</li>
<li>An optional file path can be provided.
<ul>
<li>When the device administrator provides a url,
the sm-agent downloads the software module on the device,
then invoke the install command with a path to that file.</li>
<li>If no file is provided, the plugin has to derive the appropriate location from its repository
and to download the software module accordingly.</li>
</ul>
</li>
<li>The command installs the requested software module and any dependencies that might be required.
<ul>
<li>It is up to the plugin to define if this command triggers an installation or an upgrade.
It depends on the presence of a previous version on the device and
of the ability of the package manager to deal with concurrent versions for a module.</li>
<li>A plugin might not be able to install dependencies.
In that case, the device administrator will have to request explicitly the dependencies to be installed first.</li>
<li>After a successful sequence <code>prepare; install foo; finalize</code> the module <code>foo</code> must be reported by the <code>list</code> command.</li>
<li>After a successful sequence <code>prepare; install foo --module-version v; finalize</code> the module <code>foo</code> must be reported by the <code>list</code> command with the version <code>v</code>.
If the plugin manage concurrent versions, the module <code>foo</code> might also be reported with versions already installed before the operation.</li>
<li>A plugin is not required to detect inconsistent actions as <code>prepare; install a; remove a-dependency; finalize</code>.</li>
<li>This is not an error to run this command twice or when the module is already installed.</li>
</ul>
</li>
<li>An error must be reported if:
<ul>
<li>The module name is unknown.</li>
<li>There is no version for the module that matches the constraint provided by the <code>--module-version</code> option.</li>
<li>The file content provided by <code>--file</code> option:
<ul>
<li>is not in the expected format,</li>
<li>doesn't correspond to the software module name,</li>
<li>has a version that doesn't match the constraint provided by the <code>--module-version</code> option (if any).</li>
</ul>
</li>
<li>The module cannot be downloaded.</li>
<li>The module cannot be installed.</li>
</ul>
</li>
</ul>
<h3 id="the-remove-command"><a class="header" href="#the-remove-command">The <code>remove</code> command</a></h3>
<p>The <code>remove</code> command uninstalls a software module, and possibly its dependencies if no other modules are dependent on those.</p>
<pre><code class="language-shell">plugin remove NAME [--module-version VERSION]
</code></pre>
<p>Contract:</p>
<ul>
<li>The command requires a single mandatory argument: the module name.
<ul>
<li>This module name is meaningful only to the plugin
and is transmitted unchanged from the cloud to the plugin.</li>
</ul>
</li>
<li>An optional version string can be provided.
<ul>
<li>This version string is meaningful only to the plugin
and is transmitted unchanged from the cloud to the plugin.</li>
</ul>
</li>
<li>The command uninstalls the requested module and possibly any dependencies that are no more required.
<ul>
<li>If a version is provided, only the module of that version is removed.
This is in-practice useful only for a package manager that is able to install concurrent versions of a module.</li>
<li>After a successful sequence <code>prepare; remove foo; finalize</code> the module <code>foo</code> must no more be reported by the <code>list</code> command.</li>
<li>After a successful sequence <code>prepare; remove foo --module-version v; finalize</code> the module <code>foo</code> no more be reported by the <code>list</code> command with the version <code>v</code>.
If the plugin manage concurrent versions, the module <code>foo</code> might still be reported with versions already installed before the operation.</li>
<li>A plugin is not required to detect inconsistent actions as <code>prepare; remove a; install a-reverse-dependency; finalize</code>.</li>
<li>This is not an error to run this command twice or when the module is not installed.</li>
</ul>
</li>
<li>An error must be reported if:
<ul>
<li>The module name is unknown.</li>
<li>The module cannot be uninstalled.</li>
</ul>
</li>
</ul>
<h3 id="the-update-list-command"><a class="header" href="#the-update-list-command">The <code>update-list</code> command</a></h3>
<p>The <code>update-list</code> command accepts a list of software modules and associated operations as <code>install</code> or <code>remove</code>.</p>
<p>This basically achieves same purpose as original commands <code>install</code> and <code>remove</code>, but gets passed all software modules to be processed in one command.
This can be necessary when the processing order of software modules is relevant - e.g. when dependencies between packages inside the software list do occur.</p>
<pre><code class="language-shell"># building list of software modules and operations, 
# and passing to plugin's stdin via pipe:
# NOTE that each argument is tab separated:

echo '\
  install	name1	version1
  install	name2		path2
  remove	name3	version3
  remove	name4'\
 | plugin update-list
</code></pre>
<p>Contract:</p>
<ul>
<li>This command is optional for a plugin. It can be implemented alternatively to original commands <code>install</code> and <code>remove</code> as both are specified above.
<ul>
<li>If a plugin does not implement this command it must return exit status <code>1</code>. In that case, the sm-agent will call the plugin again, calling it package-by-package using the <code>install</code> and <code>remove</code> commands.</li>
<li>If a plugin implements this command, the sm-agent uses it instead of original commands <code>install</code> and <code>remove</code>.</li>
</ul>
</li>
<li>This command takes no command line arguments, but expects a software list sent from the sm-agent to the plugin's <code>stdin</code>.</li>
<li>In the software list, each software module is represented by exactly one line, using tab separated values.</li>
<li>The position of each argument in the argument list has its defined meaning:
<ul>
<li>1st argument: Is the operation and can be <code>install</code> or <code>remove</code></li>
<li>2nd argument: Is the software module's name.</li>
<li>3rd argument: Is the software module's version. That argument is optional and can be empty (then empty string &quot;&quot; is used).</li>
<li>4th argument: Is the software module's path. That argument is optional and can be empty (then empty string &quot;&quot; is used). For operation <code>remove</code> that argument does not exist.</li>
</ul>
</li>
<li>Behaviour of operations <code>install</code> and <code>remove</code> is same as for original commands <code>install</code> and <code>remove</code> as specified above.
<ul>
<li>For details about operations' arguments &quot;name&quot;, &quot;version&quot; and &quot;path&quot;, see specification of original command <code>install</code> or <code>remove</code>.</li>
<li>For details about <code>exitstatus</code> see according specification of original command <code>install</code> or <code>remove</code>.</li>
</ul>
</li>
<li>An overall error must be reported (via process's exit status) when at least one software module operation has failed.</li>
</ul>
<p>Example how to invoke a plugin's <code>update-list</code> command. Note that each argument is tab separated:</p>
<pre><code class="language-shell">plugin update-list &lt;&lt;EOF
  install	name1	version1
  install	name2		path2
  remove	name3	version3
  remove	name4
EOF
</code></pre>
<p>That is equivalent to use of original commands (<code>install</code> and <code>remove</code>):</p>
<pre><code class="language-shell">plugin install name1 --module-version version1
plugin install name2 --file path2
plugin remove &quot;name 3&quot; --module-version version3
plugin remove name4
</code></pre>
<p>Below shows an example implementation (in <code>bash</code>) to parse the software list from <code>stdin</code>:</p>
<pre><code class="language-shell">#!/bin/bash

echo &quot;&quot;
echo &quot;---+++ reading software list +++---&quot;
while IFS=$'\t' read -r ACTION MODULE VERSION FILE
do
    echo &quot;$0 $ACTION $MODULE $VERSION&quot;
done
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-thin-edgeio"><a class="header" href="#building-thin-edgeio">Building thin-edge.io</a></h1>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<p>You can use any OS to build from source (below has been tested on Ubuntu, but we also use Debian, macOS, and FreeBSD successfully).</p>
<p>Our recommended setup and required tools are:</p>
<ul>
<li>Ubuntu 20.04 or Debian 10.9 (Buster)</li>
<li>git</li>
<li>Rust toolchain</li>
</ul>
<p>Following packages are required:</p>
<ul>
<li>build-essentials</li>
<li>curl</li>
<li>gcc</li>
</ul>
<p>A list of our test platforms can be found <a href="./supported-platforms.html">here</a>.</p>
<h2 id="get-the-code"><a class="header" href="#get-the-code">Get the code</a></h2>
<p>thin-edge.io code is in git repository on github to acquire the code use following command:</p>
<ul>
<li>via SSH:</li>
</ul>
<pre><code class="language-shell">git clone git@github.com:thin-edge/thin-edge.io.git
</code></pre>
<ul>
<li>or via HTTPS:</li>
</ul>
<pre><code class="language-shell">git clone https://github.com/thin-edge/thin-edge.io.git
</code></pre>
<h2 id="installing-toolchain"><a class="header" href="#installing-toolchain">Installing toolchain</a></h2>
<h3 id="rust-toolchain"><a class="header" href="#rust-toolchain">Rust toolchain</a></h3>
<p>To install Rust follow <a href="https://www.rust-lang.org/tools/install">Official installation guide</a>.
To get started you need Cargo's bin directory (<code>$HOME/.cargo/bin</code>) in your <code>PATH</code> environment variable.</p>
<pre><code class="language-shell">export PATH=$PATH:$HOME/.cargo/bin
</code></pre>
<p>And then you can run <code>rustc</code> to view current version:</p>
<pre><code class="language-shell">rustc --version
</code></pre>
<pre><code>rustc 1.64.0 (a55dd71d5 2022-09-19)
</code></pre>
<blockquote>
<p>Note: Above command will add rust to path only for existing session,
after you restart the session you will have to add it again,
to add rust to the path permanently it will depend on your shell but for Bash,
you simply need to add the line from above, <code>export PATH=$PATH:$HOME/.cargo/bin</code> to your ~/.bashrc.</p>
</blockquote>
<blockquote>
<p>For other shells, you'll want to find the appropriate place to set a configuration at start time,
eg. zsh uses ~/.zshrc. Check your shell's documentation to find what file it uses.</p>
</blockquote>
<p>thin-edge.io operates the <code>MSRV</code> (Minimum Supported Rust Version) and uses stable toolchain.</p>
<p>Current MSRV is <code>1.64</code>.</p>
<h3 id="cross-compilation-toolchain-optional"><a class="header" href="#cross-compilation-toolchain-optional">Cross compilation toolchain (optional)</a></h3>
<p>thin-edge.io can be compiled for target architecture on non-target device, this is called cross compilation.
Currently we support <code>Raspberry Pi 3B</code> for <code>armv7</code> architecture with Rust's cross compilation toolchain called <a href="https://github.com/rust-embedded/cross">cargo cross</a>.</p>
<p>To install <a href="https://github.com/rust-embedded/cross">cargo cross</a>:</p>
<pre><code class="language-shell">cargo install cross
</code></pre>
<h3 id="debian-packaging-optional"><a class="header" href="#debian-packaging-optional">Debian packaging (optional)</a></h3>
<p>We use <a href="https://github.com/mmstick/cargo-deb">cargo deb</a> to build our debian packages, the tool takes care of all the work to package thin-edge.io.</p>
<p>To install <a href="https://github.com/mmstick/cargo-deb">cargo deb</a> use:</p>
<pre><code class="language-shell">cargo install cargo-deb
</code></pre>
<h2 id="compiling"><a class="header" href="#compiling">Compiling</a></h2>
<p>To build thin-edge.io we are using <code>cargo</code>.</p>
<p>As we are using  <code>cargo workspace</code> for all our crates. All compiled files are put in <code>./target/</code> directory with target's name eg: <code>./target/debug</code> or <code>./target/release</code> for native builds and for cross compiled targets <code>./target/&lt;architecture&gt;/debug</code> or <code>./target/&lt;architecture&gt;/release</code> dependent on the target of the build.</p>
<h3 id="compiling-dev"><a class="header" href="#compiling-dev">Compiling dev</a></h3>
<p>To compile dev profile (with debug symbols) we use following command:</p>
<pre><code class="language-shell">cargo build
</code></pre>
<p>Build artifacts can be found in <code>./target/debug</code> and will include executables:</p>
<pre><code class="language-shell">ls ./target/debug/tedge*
</code></pre>
<pre><code>-rwxrwxr-x   2 user user 11111 Jan 1 00:00 tedge
-rwxrwxr-x   2 user user 11111 Jan 1 00:00 tedge-mapper
</code></pre>
<p>Binaries can be run eg: <code>./target/debug/tedge</code>.
Alternatively, you can use <code>cargo</code> to build and run executable in a single command:</p>
<pre><code class="language-shell">cargo run --bin tedge
</code></pre>
<h3 id="compiling-release"><a class="header" href="#compiling-release">Compiling release</a></h3>
<p>To compile release profile we use following command:</p>
<pre><code class="language-shell">cargo build --release
</code></pre>
<p>Build artifacts can be found in <code>./target/release</code> and will include executables:</p>
<pre><code class="language-shell">ls ./target/release/tedge*
</code></pre>
<pre><code>-rwxrwxr-x   2 user user 11111 Jan 1 00:00 tedge
-rwxrwxr-x   2 user user 11111 Jan 1 00:00 tedge-mapper
</code></pre>
<p>Binaries can be run eg: <code>./target/release/tedge</code>.</p>
<h2 id="building-deb-package"><a class="header" href="#building-deb-package">Building deb package</a></h2>
<p>Currently thin-edge.io contains 2 binaries, <code>tedge</code> (cli) and <code>tedge-mapper</code> which are packaged as separate debian packages. To create following commands are to be issued:</p>
<pre><code class="language-shell">cargo deb -p tedge
</code></pre>
<pre><code class="language-shell">cargo deb -p tedge-mapper
</code></pre>
<p>All resulting packages are going to be in: <code>./target/debian/</code> directory:</p>
<pre><code class="language-shell">ls ./target/debian -l
</code></pre>
<pre><code>total 2948
-rw-rw-r-- 1 user user 11111 Jan 1 00:00 tedge_0.9.0_amd64.deb
-rw-rw-r-- 1 user user 11111 Jan 1 00:00 tedge-mapper_0.9.0_amd64.deb
</code></pre>
<h2 id="cross-compiling"><a class="header" href="#cross-compiling">Cross compiling</a></h2>
<p>To create binaries which can run on different platform than one you are currently on you can use <a href="https://github.com/rust-embedded/cross">cargo cross</a>:</p>
<pre><code class="language-shell">cross build --target armv7-unknown-linux-gnueabihf
</code></pre>
<p>Build artifacts can be found in <code>./target/armv7-unknown-linux-gnueabihf/debug</code> and will include executables:</p>
<pre><code class="language-shell">ls ./target/armv7-unknown-linux-gnueabihf/debug/tedge*
</code></pre>
<pre><code>-rwxrwxr-x   2 user user 11111 Jan 1 00:00 tedge
-rwxrwxr-x   2 user user 11111 Jan 1 00:00 tedge-mapper
</code></pre>
<p>To cross compile release version of the binaries just add <code>--release</code> to the above command like so:</p>
<pre><code class="language-shell">cross build --target armv7-unknown-linux-gnueabihf --release
</code></pre>
<h2 id="running-tests"><a class="header" href="#running-tests">Running tests</a></h2>
<p>When contributing to thin-edge.io we ask you to write tests for the code you have written. The tests will be run by build pipeline when you create pull request, but you can easily run all the tests when you are developing with following command:</p>
<pre><code class="language-shell">cargo test
</code></pre>
<p>This will run all tests from the repository and sometime may take long time, <code>cargo</code> allows you to run specific test or set of tests for binary:</p>
<pre><code class="language-shell">cargo test --bin tedge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-guides"><a class="header" href="#reference-guides">Reference Guides</a></h1>
<p>The thin-edge.io command-line interface (tedge CLI) is a set of commands used to create and manage thin-edge.io resources.</p>
<p>Following sections show the tedge sub commands.</p>
<ul>
<li><a href="references/../references/tedge.html"><code>tedge</code> command</a></li>
<li><a href="references/../references/tedge-cert.html"><code>tedge cert</code> command</a></li>
<li><a href="references/../references/tedge-config.html"><code>tedge config</code> command</a></li>
<li><a href="references/../references/tedge-connect.html"><code>tedge connect</code> command</a></li>
<li><a href="references/../references/tedge-disconnect.html"><code>tedge disconnect</code> command</a></li>
<li><a href="references/../references/tedge-mqtt.html"><code>tedge mqtt</code> command</a></li>
<li><a href="references/../references/bridged-topics.html">Bridged Topics</a></li>
</ul>
<p>Software Management (under development)</p>
<ul>
<li><a href="references/./plugin-api.html">Plugin API</a></li>
</ul>
<p>Thin-edge.io configuration files</p>
<ul>
<li><a href="references/./thin-edge-config-files.html">Thin-edge.io configuration files</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tedge-command"><a class="header" href="#the-tedge-command">The <code>tedge</code> command</a></h1>
<pre><code class="language-console">tedge 0.9.0
tedge is the cli tool for thin-edge.io

USAGE:
    tedge [OPTIONS] [SUBCOMMAND]

OPTIONS:
        --config-dir &lt;CONFIG_DIR&gt;    [default: /etc/tedge]
    -h, --help                       Print help information
        --init                       Initialize the tedge
    -V, --version                    Print version information

SUBCOMMANDS:
    cert          Create and manage device certificate
    config        Configure Thin Edge
    connect       Connect to connector provider
    disconnect    Remove bridge connection for a provider
    help          Print this message or the help of the given subcommand(s)
    mqtt          Publish a message on a topic and subscribe a topic
    reconnect     Reconnect command, calls disconnect followed by connect
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tedge-config-command"><a class="header" href="#the-tedge-config-command">The <code>tedge config</code> command</a></h1>
<pre><code class="language-console">tedge-config 
Configure Thin Edge

USAGE:
    tedge config &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    get      Get the value of the provided configuration key
    help     Print this message or the help of the given subcommand(s)
    list     Print the configuration keys and their values
    set      Set or update the provided configuration key with the given value
    unset    Unset the provided configuration key
</code></pre>
<h2 id="get"><a class="header" href="#get">Get</a></h2>
<pre><code class="language-console">tedge-config-get 
Get the value of the provided configuration key

USAGE:
    tedge config get &lt;KEY&gt;

ARGS:
    &lt;KEY&gt;    Configuration key. Run `tedge config list --doc` for available keys

OPTIONS:
    -h, --help    Print help information
</code></pre>
<h2 id="set"><a class="header" href="#set">Set</a></h2>
<pre><code class="language-console">tedge-config-set 
Set or update the provided configuration key with the given value

USAGE:
    tedge config set &lt;KEY&gt; &lt;VALUE&gt;

ARGS:
    &lt;KEY&gt;      Configuration key. Run `tedge config list --doc` for available keys
    &lt;VALUE&gt;    Configuration value

OPTIONS:
    -h, --help    Print help information
</code></pre>
<h2 id="list-2"><a class="header" href="#list-2">List</a></h2>
<pre><code class="language-console">tedge-config-list 
Print the configuration keys and their values

USAGE:
    tedge config list [OPTIONS]

OPTIONS:
        --all     Prints all the configuration keys, even those without a configured value
        --doc     Prints all keys and descriptions with example values
    -h, --help    Print help information
</code></pre>
<h2 id="unset"><a class="header" href="#unset">Unset</a></h2>
<pre><code class="language-console">tedge-config-unset 
Unset the provided configuration key

USAGE:
    tedge config unset &lt;KEY&gt;

ARGS:
    &lt;KEY&gt;    Configuration key. Run `tedge config list --doc` for available keys

OPTIONS:
    -h, --help    Print help information
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tedge-cert-command"><a class="header" href="#the-tedge-cert-command">The <code>tedge cert</code> command</a></h1>
<pre><code class="language-console">tedge-cert 
Create and manage device certificate

USAGE:
    tedge cert &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    create    Create a self-signed device certificate
    help      Print this message or the help of the given subcommand(s)
    remove    Remove the device certificate
    show      Show the device certificate, if any
    upload    Upload root certificate
</code></pre>
<h2 id="create"><a class="header" href="#create">Create</a></h2>
<pre><code class="language-console">tedge-cert-create 
Create a self-signed device certificate

USAGE:
    tedge cert create --device-id &lt;ID&gt;

OPTIONS:
        --device-id &lt;ID&gt;    The device identifier to be used as the common name for the certificate
    -h, --help              Print help information
</code></pre>
<h2 id="show"><a class="header" href="#show">Show</a></h2>
<pre><code class="language-console">tedge-cert-show 
Show the device certificate, if any

USAGE:
    tedge cert show

OPTIONS:
    -h, --help    Print help information
</code></pre>
<h2 id="remove-2"><a class="header" href="#remove-2">Remove</a></h2>
<pre><code class="language-console">tedge-cert-remove 
Remove the device certificate

USAGE:
    tedge cert remove

OPTIONS:
    -h, --help    Print help information
</code></pre>
<h2 id="upload"><a class="header" href="#upload">Upload</a></h2>
<pre><code class="language-console">tedge-cert-upload 
Upload root certificate

USAGE:
    tedge cert upload &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    c8y     Upload root certificate to Cumulocity
    help    Print this message or the help of the given subcommand(s)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tedge-connect-command"><a class="header" href="#the-tedge-connect-command">The <code>tedge connect</code> command</a></h1>
<pre><code class="language-console">tedge-connect 
Connect to connector provider

USAGE:
    tedge connect &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    aws     Create connection to AWS
    az      Create connection to Azure
    c8y     Create connection to Cumulocity
    help    Print this message or the help of the given subcommand(s)
</code></pre>
<h2 id="aws"><a class="header" href="#aws">AWS</a></h2>
<pre><code class="language-console">tedge-connect-aws 
Create connection to AWS

The command will create config and start edge relay from the device to AWS instance

USAGE:
    tedge connect aws [OPTIONS]

OPTIONS:
    -h, --help
            Print help information

        --test
            Test connection to AWS
</code></pre>
<h2 id="azure-1"><a class="header" href="#azure-1">Azure</a></h2>
<pre><code class="language-console">tedge-connect-az 
Create connection to Azure

The command will create config and start edge relay from the device to az instance

USAGE:
    tedge connect az [OPTIONS]

OPTIONS:
    -h, --help
            Print help information

        --test
            Test connection to Azure
</code></pre>
<h2 id="cumulocity-1"><a class="header" href="#cumulocity-1">Cumulocity</a></h2>
<pre><code class="language-console">tedge-connect-c8y 
Create connection to Cumulocity

The command will create config and start edge relay from the device to c8y instance

USAGE:
    tedge connect c8y [OPTIONS]

OPTIONS:
    -h, --help
            Print help information

        --test
            Test connection to Cumulocity
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tedge-disconnect-command"><a class="header" href="#the-tedge-disconnect-command">The <code>tedge disconnect</code> command</a></h1>
<pre><code class="language-console">tedge-disconnect 
Remove bridge connection for a provider

USAGE:
    tedge disconnect &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    aws     Remove bridge connection to AWS
    az      Remove bridge connection to Azure
    c8y     Remove bridge connection to Cumulocity
    help    Print this message or the help of the given subcommand(s)
</code></pre>
<h2 id="aws-1"><a class="header" href="#aws-1">AWS</a></h2>
<pre><code class="language-console">tedge-disconnect-aws 
Remove bridge connection to AWS

USAGE:
    tedge disconnect aws

OPTIONS:
    -h, --help    Print help information
</code></pre>
<h2 id="azure-2"><a class="header" href="#azure-2">Azure</a></h2>
<pre><code class="language-console">tedge-disconnect-az 
Remove bridge connection to Azure

USAGE:
    tedge disconnect az

OPTIONS:
    -h, --help    Print help information
</code></pre>
<h2 id="cumulocity-2"><a class="header" href="#cumulocity-2">Cumulocity</a></h2>
<pre><code class="language-console">tedge-disconnect-c8y 
Remove bridge connection to Cumulocity

USAGE:
    tedge disconnect c8y

OPTIONS:
    -h, --help    Print help information
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tedge-mqtt-command"><a class="header" href="#the-tedge-mqtt-command">The <code>tedge mqtt</code> command</a></h1>
<pre><code class="language-console">tedge-mqtt 
Publish a message on a topic and subscribe a topic

USAGE:
    tedge mqtt &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    help    Print this message or the help of the given subcommand(s)
    pub     Publish a MQTT message on a topic
    sub     Subscribe a MQTT topic
</code></pre>
<h2 id="pub"><a class="header" href="#pub">Pub</a></h2>
<pre><code class="language-console">tedge-mqtt-pub 
Publish a MQTT message on a topic

USAGE:
    tedge mqtt pub [OPTIONS] &lt;TOPIC&gt; &lt;MESSAGE&gt;

ARGS:
    &lt;TOPIC&gt;      Topic to publish
    &lt;MESSAGE&gt;    Message to publish

OPTIONS:
    -h, --help         Print help information
    -q, --qos &lt;QOS&gt;    QoS level (0, 1, 2) [default: 0]
    -r, --retain       Retain flag
</code></pre>
<h2 id="sub"><a class="header" href="#sub">Sub</a></h2>
<pre><code class="language-console">tedge-mqtt-sub 
Subscribe a MQTT topic

USAGE:
    tedge mqtt sub [OPTIONS] &lt;TOPIC&gt;

ARGS:
    &lt;TOPIC&gt;    Topic to subscribe to

OPTIONS:
    -h, --help         Print help information
        --no-topic     Avoid printing the message topics on the console
    -q, --qos &lt;QOS&gt;    QoS level (0, 1, 2) [default: 0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thin-edge-config-files"><a class="header" href="#thin-edge-config-files">Thin-edge config files</a></h1>
<p>Thin-edge.io requires config files for its operation. The <code>tedge --init</code> option is used to create
the base directory and other directories inside the base directory with appropriate user and permissions.
The <code>tedge-mapper --init c8y/az</code> and <code>tedge-agent --init</code> will create the
directories/files inside the base directory that are required for their operation.</p>
<p>By default, the config files are created in <code>/etc/tedge</code> directory. To create the config files in
a custom base directory one has to use <code>--config-dir &lt;Path to base directory&gt;</code> option.</p>
<h2 id="creating-thin-edge-config-files"><a class="header" href="#creating-thin-edge-config-files">Creating <code>thin-edge</code> config files</a></h2>
<p>The config files are created using <code>tedge --init</code> as below.</p>
<pre><code class="language-shell">sudo tedge --init
</code></pre>
<p>All the directories will be created in the <code>/etc/tedge</code> directory. The directories layout looks as below.</p>
<pre><code class="language-shell">ls -l /etc/tedge

total 16
drwxrwxr-x 2 mosquitto mosquitto 4096 Jun 10 14:49 device-certs
drwxrwxr-x 2 tedge     tedge     4096 Jun 10 14:49 mosquitto-conf
drwxrwxr-x 2 tedge     tedge     4096 Jun 10 14:49 operations
drwxrwxr-x 2 tedge     tedge     4096 Jun 10 14:49 plugins
</code></pre>
<p>Use the below command to create the config directories in a custom directory.</p>
<pre><code class="language-shell">sudo tedge --config-dir /global/path/to/config/dir --init
</code></pre>
<p>Now all the config directories will be created inside the <code>/global/path/to/config/dir</code> directory.</p>
<p>The directories and files that are required by the <code>tedge-mapper</code> are created as below.</p>
<pre><code class="language-shell">sudo tedge-mapper --init c8y
</code></pre>
<pre><code>ls -l /etc/tedge/operations/c8y
total 0
-rw-r--r-- 1 tedge tedge 0 Jun 14 14:37 c8y_Restart
-rw-r--r-- 1 tedge tedge 0 Jun 14 14:37 c8y_SoftwareUpdate
</code></pre>
<p>To create these directories in a custom directory, use <code>--config-dir</code> option as below.</p>
<pre><code class="language-shell">sudo tedge_mapper --config-dir /global/path/to/config/dir --init c8y
</code></pre>
<p>The directories and files that are required by the <code>tedge-agent</code> are created as below.</p>
<pre><code class="language-shell">sudo tedge-agent --init
</code></pre>
<pre><code>ls -l /etc/tedge/.agent
-rw-r--r-- 1 tedge tedge 0 Jun 15 11:51 /etc/tedge/.agent/current-operation
</code></pre>
<p>To create these directories and files in a custom directory, use the <code>--config-dir</code> option as below as below.</p>
<pre><code class="language-shell">sudo tedge-agent --config-dir /global/path/to/config/dir --init
</code></pre>
<h2 id="manage-the-configuration-parameters"><a class="header" href="#manage-the-configuration-parameters">Manage the configuration parameters</a></h2>
<p>The configuration parameters can be set/unset/list in a config file as below</p>
<p>For example, the config parameter can be set as below.</p>
<pre><code class="language-shell">sudo tedge config set c8y.url your.cumulocity.io
</code></pre>
<p>Now the configuration will be added into <code>/etc/tedge/tedge.toml</code></p>
<p>Use the below command to set/unset/list configuration parameters in a config file that is present
in a custom directory.</p>
<pre><code class="language-shell">sudo tedge --config-dir /global/path/to/config/dir config set c8y.url your.cumulocity.io
</code></pre>
<p>Now the config will be set in <code>/global/path/to/config/dir/tedge/tedge.toml</code></p>
<h2 id="manage-the-certificate"><a class="header" href="#manage-the-certificate">Manage the certificate</a></h2>
<p>To create/remove/upload the certificate, one can use the below command.</p>
<pre><code class="language-shell">sudo tedge cert create --device-id thinedge
Certificate was successfully created

# Find the certificates that are created as below.

ls -l /etc/tedge/device-certs/
total 8
-r--r--r-- 1 mosquitto mosquitto 638 Jun 14 14:38 tedge-certificate.pem
-r-------- 1 mosquitto mosquitto 246 Jun 14 14:38 tedge-private-key.pem
</code></pre>
<p>Use the below command to create/remove/upload the certificate.</p>
<pre><code class="language-shell">sudo tedge --config-dir /global/path/to/config/dir cert create --device-id thinedge

# Find the certificates that are created as below.

ls -l /global/path/to/config/dir/tedge/device-certs/
total 8
-r--r--r-- 1 mosquitto mosquitto 638 Jun 14 14:38 tedge-certificate.pem
-r-------- 1 mosquitto mosquitto 246 Jun 14 14:38 tedge-private-key.pem
</code></pre>
<h2 id="connecting-to-the-cloud"><a class="header" href="#connecting-to-the-cloud">Connecting to the cloud</a></h2>
<p>Use the<code>tedge connect c8y/az/aws</code> command to connect to the cloud using the default configuration files
that are present in <code>/etc/tedge</code>.</p>
<p>To connect to the cloud with config files that are present in a custom location use
the <code>tedge connect --config-dir &lt;Path to custom dir&gt; c8y/az/aws</code> option.</p>
<p>This is a two step process.</p>
<h3 id="step-1-update-the-mosquittoconf"><a class="header" href="#step-1-update-the-mosquittoconf">Step 1: Update the <code>mosquitto.conf</code></a></h3>
<p>Since the bridge configuration files for Cumulocity IoT, Azure IoT Hub or AWS IoT will be created in a directory given through <code>--config-dir</code>,
the path to the bridge configuration files (tedge-mosquitto.conf, c8y/az/aws-bridge.conf) must be found by <code>mosquitto</code>.
So, the below line has to be added to your <code>mosquitto.conf</code> file manually.</p>
<p><code>include_dir /global/path/to/config/dir/tedge/mosquitto-conf</code></p>
<h3 id="step-2-tedge-connect-cloudc8yazaws-using-the---config-dir-option"><a class="header" href="#step-2-tedge-connect-cloudc8yazaws-using-the---config-dir-option">Step 2: <code>tedge connect &lt;cloud[c8y/az/aws]&gt;</code> using the <code>--config-dir</code> option</a></h3>
<p>Use the below command to connect to <code>Cumulocity IoT, Azure IoT Hub or AWS IoT</code> cloud using <code>--config-dir</code></p>
<pre><code class="language-shell">sudo tedge --config-dir /global/path/to/config/dir connect c8y/az/aws
</code></pre>
<p>Here the <code>path/to/config/dir</code> is the directory where the configuration files are present.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
